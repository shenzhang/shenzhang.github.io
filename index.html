
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>章显魅颖</title>
  <meta name="author" content="zshen">

  
  <meta name="description" content="`jcl-over-slf4j&#8217;如同名字一样就是用来将java commons logging桥接到slf4j上。现在J2EE的一个项目通常会引用五花八门的类库，不同的类库又会使用不同的日志门面系统，有的是slf4j，有的是jcl。现在随着slf4j的越来越流行， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://shenzhang.github.io">
  <link href="/favicon.jpeg" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Keep going" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Keep going</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:shenzhang.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/13/commons-logging-over-slf4j/">Jcl-over-slf4j</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-13T02:27:00+08:00" pubdate data-updated="true">Apr 13<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>`jcl-over-slf4j&#8217;如同名字一样就是用来将java commons logging桥接到slf4j上。现在J2EE的一个项目通常会引用五花八门的类库，不同的类库又会使用不同的日志门面系统，有的是slf4j，有的是jcl。现在随着slf4j的越来越流行，那么将系统里的所有日志系统都统一到slf4j上也成了一个很平常的需求，jcl-over-slf4j也成了项目依赖中的常客。这周和同事也讨论了该桥接类的应用，尤其是spring本身也是直接以来jcl的，其官方文档也给出了如何替换成slf4j的说明。今天看了下代码，这里做下记录。</p>

<h2>jcl的绑定流程</h2>

<p>使用jcl的标准方法如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Log</span> <span class="n">log</span> <span class="o">=</span> <span class="n">LogFactory</span><span class="o">.</span><span class="na">getLog</span><span class="o">(</span><span class="n">XXX</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>LogFactory中给出了如下绑定流程：</p>

<ol>
<li>检查系统属性<code>org.apache.commons.logging.LogFactory</code>，其中记录了具体的LogFactory的实现类。</li>
<li>通过java的service loading机制加载<code>META-INF/services/org.apache.commons.logging.LogFactory</code>配置文件，其中记录了LogFactory的实现类。</li>
<li>检查classpath中的<code>commons-logging.properties</code>配置文件，里面记录了具体的LogFactory的实现类。</li>
<li>使用jcl提供的默认实现类：<code>org.apache.commons.logging.impl.LogFactoryImpl</code>来创建Log。</li>
</ol>


<p>如果不幸进入了最后一个步骤使用<code>org.apache.commons.logging.impl.LogFactoryImpl</code>来创建Log，那么它又会使用一套发现机制类查找合适的日志实现：</p>

<ol>
<li>检查<code>org.apache.commons.logging.impl.LogFactoryImpl</code>是否已经配置了<code>org.apache.commons.logging.Log</code>属性，如果配置了该属性，则使用该属性指定的Log。</li>
<li>使用系统属性<code>org.apache.commons.logging.Log</code>中所定义的Log实现</li>
<li>检查是否存在log4j的实现类:<code>org.apache.commons.logging.impl.Log4JLogger</code>。</li>
<li>检查<code>org.apache.commons.logging.impl.Jdk14Logger</code></li>
<li>检查<code>org.apache.commons.logging.impl.Jdk13LumberjackLogger</code></li>
<li>检查<code>org.apache.commons.logging.impl.SimpleLog</code></li>
</ol>


<h2>jcl-over-slf4j桥接模式</h2>

<p>其实仔细看看jcl-over-slf4j的实现，可以发现它提供了两种桥接方法。</p>

<h3>1.引入jcl-over-slf4j并排除jcl</h3>

<p>该方法也是spring官方推荐的方法，它的实现也是很巧妙也很直接。因为我们使用jcl都是通过<code>LogFactory.getLog(XXX.class)</code>来获得Log，jcl-over-slf4j中也就提供了名称完全一样的LogFactory，只不过它的getLog方法直接通过Slf4jLogFactory返回Slf4jLog。如果在dependencies中排除掉jcl，那么所有引用jcl的地方就偷天换日的直接使用了slf4j的日志。</p>

<h3>2.引入jcl-over-slf4j并且没有排除jcl</h3>

<p>有些人可能发现如果没有在dependencies中排除掉jcl也是可以工作的，这又是为什么呢？实际上jcl-over-slf4j提供了方法1外，还参考了jcl的绑定机制，并且参考上面提到的步骤2提供了<code>META-INF/services/org.apache.commons.logging.LogFactory</code>，其中说明了jcl需要绑定的LogFactory实现是<code>org.apache.commons.logging.impl.SLF4JLogFactory</code>。这不，也委托回slf4j上让其提供Log。</p>

<p>实际上，上面的两种方法都是可以的。但是推荐使用第一种方法，因为更加直接和清晰。第二种方法会让classpath中存在两个完全同名的jcl的LogFactory，但是不论jvm加载哪一个都是OK的。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/04/13/which-one-is-faster-java-heap-or-native-memory/">哪个更快：Java堆还是本地内存[译]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-04-13T01:27:00+08:00" pubdate data-updated="true">Apr 13<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://mentablog.soliveirajr.com/2012/11/which-one-is-faster-java-heap-or-native-memory/">原文链接</a></p>

<p>使用Java的一个好处就是你可以不用亲自来管理内存的分配和释放。当你用<code>new</code>关键字来实例化一个对象时，它所需的内存会自动的在Java堆中分配。堆会被垃圾回收器进行管理，并且它会在对象超出作用域时进行内存回收。但是在JVM中有一个‘后门’可以让你访问不在堆中的本地内存(native memory)。在这篇文章中，我会给你演示一个对象是怎样以连续的字节码的方式在内存中进行存储，并且告诉你是应该怎样存储这些字节，是在Java堆中还是在本地内存中。最后我会就怎样从JVM中访问内存更快给一些结论：是用Java堆还是本地内存。</p>

<h1>使用<code>Unsafe</code>来分配和回收内存</h1>

<p><code>sun.misc.Unsafe</code>可以让你在Java中分配和回收本地内存，就像C语言中的<code>malloc</code>和<code>free</code>。通过它分配的内存不在Java堆中，并且不受垃圾回收器的管理，因此在它被使用完的时候你需要自己来负责释放和回收。下面是我写的一个使用<code>Unsafe</code>来管理本地内存的一个工具类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Direct</span> <span class="kd">implements</span> <span class="n">Memory</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Unsafe</span> <span class="n">unsafe</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="n">AVAILABLE</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">static</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">Field</span> <span class="n">field</span> <span class="o">=</span> <span class="n">Unsafe</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&quot;theUnsafe&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="n">field</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span><span class='line'>            <span class="n">unsafe</span> <span class="o">=</span> <span class="o">(</span><span class="n">Unsafe</span><span class="o">)</span><span class="n">field</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
</span><span class='line'>            <span class="n">AVAILABLE</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">// NOOP: throw exception later when allocating memory</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isAvailable</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">AVAILABLE</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Direct</span> <span class="n">INSTANCE</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Memory</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">INSTANCE</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Direct</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">INSTANCE</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="nf">Direct</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">alloc</span><span class="o">(</span><span class="kt">long</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">AVAILABLE</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">&quot;sun.misc.Unsafe is not accessible!&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">allocateMemory</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">free</span><span class="o">(</span><span class="kt">long</span> <span class="n">address</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">unsafe</span><span class="o">.</span><span class="na">freeMemory</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">long</span> <span class="nf">getLong</span><span class="o">(</span><span class="kt">long</span> <span class="n">address</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">putLong</span><span class="o">(</span><span class="kt">long</span> <span class="n">address</span><span class="o">,</span> <span class="kt">long</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">unsafe</span><span class="o">.</span><span class="na">putLong</span><span class="o">(</span><span class="n">address</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getInt</span><span class="o">(</span><span class="kt">long</span> <span class="n">address</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">putInt</span><span class="o">(</span><span class="kt">long</span> <span class="n">address</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">unsafe</span><span class="o">.</span><span class="na">putInt</span><span class="o">(</span><span class="n">address</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>在本地内存中分配一个对象</h2>

<p>让我们来将下面的Java对象放到本地内存中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SomeObject</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">long</span> <span class="n">someLong</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">someInt</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getSomeLong</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">someLong</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setSomeLong</span><span class="o">(</span><span class="kt">long</span> <span class="n">someLong</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">someLong</span> <span class="o">=</span> <span class="n">someLong</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getSomeInt</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">someInt</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setSomeInt</span><span class="o">(</span><span class="kt">int</span> <span class="n">someInt</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">someInt</span> <span class="o">=</span> <span class="n">someInt</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们所做的仅仅是把对象的属性放入到<code>Memory</code>中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SomeMemoryObject</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">someLong_OFFSET</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">someInt_OFFSET</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">SIZE</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">4</span><span class="o">;</span> <span class="c1">// one long + one int</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">long</span> <span class="n">address</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Memory</span> <span class="n">memory</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">SomeMemoryObject</span><span class="o">(</span><span class="n">Memory</span> <span class="n">memory</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">memory</span> <span class="o">=</span> <span class="n">memory</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">address</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="na">alloc</span><span class="o">(</span><span class="n">SIZE</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">finalize</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">memory</span><span class="o">.</span><span class="na">free</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">setSomeLong</span><span class="o">(</span><span class="kt">long</span> <span class="n">someLong</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">memory</span><span class="o">.</span><span class="na">putLong</span><span class="o">(</span><span class="n">address</span> <span class="o">+</span> <span class="n">someLong_OFFSET</span><span class="o">,</span> <span class="n">someLong</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">long</span> <span class="nf">getSomeLong</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">memory</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="n">address</span> <span class="o">+</span> <span class="n">someLong_OFFSET</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">setSomeInt</span><span class="o">(</span><span class="kt">int</span> <span class="n">someInt</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">memory</span><span class="o">.</span><span class="na">putInt</span><span class="o">(</span><span class="n">address</span> <span class="o">+</span> <span class="n">someInt_OFFSET</span><span class="o">,</span> <span class="n">someInt</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getSomeInt</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">memory</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="n">address</span> <span class="o">+</span> <span class="n">someInt_OFFSET</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在我们来看看对两个数组的读写性能：其中一个含有数百万的<code>SomeObject</code>对象，另外一个含有数百万的<code>SomeMemoryObject</code>对象。</p>

<pre><code>// with JIT:
Number of Objects:  1,000     1,000,000     10,000,000    60,000,000
Heap Avg Write:      107         2.30          2.51         2.58       
Native Avg Write:    305         6.65          5.94         5.26
Heap Avg Read:       61          0.31          0.28         0.28
Native Avg Read:     309         3.50          2.96         2.16


// without JIT: (-Xint)
Number of Objects:  1,000     1,000,000     10,000,000    60,000,000
Heap Avg Write:      104         107           105         102       
Native Avg Write:    292         293           300         297
Heap Avg Read:       59          63            60          58
Native Avg Read:     297         298           302         299
</code></pre>

<p><strong>结论：</strong>跨越JVM的屏障来读本地内存大约会比直接读Java堆中的内存慢10倍，而对于写操作会慢大约2倍。<em>但是需要注意的是，由于每一个SomeMemoryObject对象所管理的本地内存空间都是独立的，因此读写操作都不是连续的。</em>那么我们接下来就来对比下读写连续的内存空间的性能。</p>

<h2>访问一大块的连续内存空间</h2>

<p>这个测试分别在堆中和一大块连续本地内存中包含了相同的测试数据。然后我们来做多次的读写操作看看哪个更快。并且我们会做一些随机地址的访问来对比结果。</p>

<pre><code>// with JIT and sequential access:
Number of Objects:  1,000     1,000,000     1,000,000,000
Heap Avg Write:      12          0.34           0.35 
Native Avg Write:    102         0.71           0.69 
Heap Avg Read:       12          0.29           0.28 
Native Avg Read:     110         0.32           0.32

// without JIT and sequential access: (-Xint)
Number of Objects:  1,000     1,000,000      10,000,000
Heap Avg Write:      8           8              8
Native Avg Write:    91          92             94
Heap Avg Read:       10          10             10
Native Avg Read:     91          90             94

// with JIT and random access:
Number of Objects:  1,000     1,000,000     1,000,000,000
Heap Avg Write:      61          1.01           1.12
Native Avg Write:    151         0.89           0.90 
Heap Avg Read:       59          0.89           0.92 
Native Avg Read:     156         0.78           0.84

// without JIT and random access: (-Xint)
Number of Objects:  1,000     1,000,000      10,000,000
Heap Avg Write:      55          55              55
Native Avg Write:    141         142             140
Heap Avg Read:       55          55              55 
Native Avg Read:     138         140             138
</code></pre>

<p><strong>结论:</strong>在做连续访问的时候，Java堆内存通常都比本地内存要快。对于随机地址访问，堆内存仅仅比本地内存慢一点点，并且是针对大块连续数据的时候，而且没有慢很多。</p>

<h2>最后的结论</h2>

<p>在Java中使用本地内存有它的意义，比如当你要操作大块的数据时(>2G)并且不想使用垃圾回收器(GC)的时候。从延迟的角度来说，直接访问本地内存不会比访问Java堆快。这个结论其实是有道理的，因为跨越JVM屏障肯定是有开销的。这样的结论对使用本地还是堆的<code>ByteBuffer</code>同样适用。使用本地ByteBuffer的速度提升不在于访问这些内存，而是它可以直接与操作系统提供的本地IO进行操作。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/15/something-about-maven/">Maven杂谈(生命周期,插件绑定,effective-xx)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-15T01:27:00+08:00" pubdate data-updated="true">Sep 15<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>1.生命周期</h2>

<h3>Clean</h3>

<pre><code>pre-clean
clean
post-clean
</code></pre>

<h3>Default</h3>

<pre><code>validate
initialize
generate-sources
process-sources
generate-resources
process-resources
compile
process-classes
generate-test-sources
process-test-sources
generate-test-resources
process-test-resources
test-compile
process-test-classes
test
prepare-package
package
pre-integration-test
integration-test
post-integration-test
verify
install
deploy
</code></pre>

<h3>Site</h3>

<pre><code>pre-site
site
post-site
site-deploy
</code></pre>

<h2>2.插件绑定</h2>

<p>maven在不同的生命周期中会按顺序进入不同的阶段，每个阶段又会执行与该阶段绑定的plugins。如何将plugins绑定到生命周期中呢，maven-compile-plugin又是怎么知道在每次的compile阶段执行的呢？</p>

<p>plugin绑定到生命周期中需要在pom.xml中的<build>=><plugins>中进行声明，有些是在pom.xml中，有些可能是在super pom中，有些甚至是maven默认的绑定，但是最终都会出现在effective pom中（mvn help:effective-pom查看)。</p>

<p>那么具体是在哪个阶段执行呢？看effective pom中对maven-compile-plugin的描述：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>  <span class="nt">&lt;plugin&gt;</span>
</span><span class='line'>    <span class="nt">&lt;artifactId&gt;</span>maven-compiler-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;version&gt;</span>2.3.2<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>    <span class="nt">&lt;executions&gt;</span>
</span><span class='line'>      <span class="nt">&lt;execution&gt;</span>
</span><span class='line'>        <span class="nt">&lt;id&gt;</span>default-testCompile<span class="nt">&lt;/id&gt;</span>
</span><span class='line'>        <span class="nt">&lt;phase&gt;</span>test-compile<span class="nt">&lt;/phase&gt;</span>
</span><span class='line'>        <span class="nt">&lt;goals&gt;</span>
</span><span class='line'>          <span class="nt">&lt;goal&gt;</span>testCompile<span class="nt">&lt;/goal&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/goals&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/execution&gt;</span>
</span><span class='line'>      <span class="nt">&lt;execution&gt;</span>
</span><span class='line'>        <span class="nt">&lt;id&gt;</span>default-compile<span class="nt">&lt;/id&gt;</span>
</span><span class='line'>        <span class="nt">&lt;phase&gt;</span>compile<span class="nt">&lt;/phase&gt;</span>
</span><span class='line'>        <span class="nt">&lt;goals&gt;</span>
</span><span class='line'>          <span class="nt">&lt;goal&gt;</span>compile<span class="nt">&lt;/goal&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/goals&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/execution&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/executions&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/plugin&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>主要是在phase节点和goals节点，上面的配置说明了maven-compile-plugin被分别绑定到了compile阶段和test-compile阶段，并且分别执行该插件的compile goal和testCompile goal。</p>

<p>另外有些plugin可能并没有在pom.xml中说明具体的执行阶段，那么就要看该插件中的/META-INF/maven/plugin.xml插件描述文件了，该描述文件说明了该plugin的前缀(goalPrefix)，所有的mojos或者说是goal，并且这些goal的名字以及默认的执行阶段，比如compile:testCompile节点就说明了&lt;phase&gt;test-compile&lt;/phase&gt;。因此如果没有在pom.xml中说明执行阶段的话，就按照该plugin的goal的自描述中的phase进行绑定。</p>

<h2>3.effective-xx</h2>

<p>maven有关于自己运行的配置文件settings.xml，该文件可以是$MAVEN_HOME/conf/settings.xml或者$USER/.m2/setttings.xml，并且后者会覆盖前者，可以通过mvn help:effective-settings查看相对于默认的settings.xml所改变的部分。</p>

<p>同样，前面提到的effective-pom也是由多个部分合并而来，首先是项目下的pom.xml，然后是maven的super pom($MAVEN_HOME/lib/maven-model-builder-x.x.x.jar#org/apache/maven/model/pom-x.x.x.xml)，还有一些是maven针对不同的生命周期默认绑定的插件信息($MAVEN_HOME/lib/maven-core-x.x.x.jar#/META-INF/plexus/components.xml)。最终的pom可以通过help:effective-pom查看)</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/13/scope-in-maven/">Maven依赖的scope</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-13T01:27:00+08:00" pubdate data-updated="true">Sep 13<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>maven中一些常用的scope及其介绍。</p>

<h3>compile:</h3>

<p>maven的默认依赖scope，并且会应用于所有的classpath，也就是说不论在compile, test compile, 还是直接用mvn来运行(runtime)都会起作用.</p>

<h3>runtime:</h3>

<p>在compile相关的阶段都不会起作用，仅仅是在运行(runtime)或者测试(test)的时候有效。</p>

<h3>provided:</h3>

<p>和compile类似，但是往往这些依赖不需要随应用一起发布，一般是由外部环境或者容器来提供，不需要自己准备，比如说servlet-api, jsp-api这些都可以由container提供。</p>

<h3>test:</h3>

<p>这个最好理解，仅仅是在测试的时候有用，compile和runtime都不需要</p>

<h3>system:</h3>

<p>有些依赖是仓库没有的，那么可以通过使用system范围来告诉maven在指定的本地路径上查找依赖。因此需要在dependency中指定systemPath元素，告诉maven依赖的具体位置。一般来说是不应该使用该范围的，很可能大家不能共享你的配置。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/12/add-source-to-repository/">如何针对缺少source包的jar添加source包</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-12T01:27:00+08:00" pubdate data-updated="true">Sep 12<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>repository中的有些jar是没有对应的source的，比如在使用hadoop-core-1.0.4.jar包，但是由于缺少sources包，因此无法在依赖中查看源文件。</p>

<p>那么可以自己准备对应的源码包：hadoop-core-1.0.4-srouces.jar并安装到本地仓库中。</p>

<pre><code>mvn install:install-file -Dfile=e:\hadoop-core-1.0.4-sources.jar -DgroupId=org.apache.hadoop -DartifactId=hadoop-core -Dversion=1.0.4 -DgeneratePom=false -Dpackaging=java-source
</code></pre>

<p>注意<code>packaging=java-source</code>，不要使用<code>packaging=jar</code></p>

<p>从中我们可以推测maven打包和依赖查找的机制：</p>

<p>我们发布一个包，指定了groupId, artifacteId, version, packaging，那么maven会自动帮我们给要发布的文件重命名：</p>

<pre><code>packaging=jar =&gt; artifacteId-version.jar
packaging=java-srouce =&gt; artifacteId-version-sources.jar
packaging=java-doc =&gt; artifacteId-version-doc.jar
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/11/jasmine/">Javascript测试框架jasmine</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-11T01:27:00+08:00" pubdate data-updated="true">Sep 11<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://pivotal.github.io/jasmine/">jasmine</a>是一个javascript的测试框架，不同于qunit等其他测试框架，它可以用于很多js环境，比如web，nodejs等。它上手简单，并且官方有很详细的实例和描述，这里将大部分实用的api和用法记录下来。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/09/11/jasmine/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/10/inspect-seajs/">SeaJS原理解析</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-10T01:27:00+08:00" pubdate data-updated="true">Sep 10<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>对于前台javascript代码的模块化组织和依赖加载目前业界比较流行的有RequireJS和玉伯写的的SeaJS。看了下玉伯本人对这两款模块加载器的对比分析，个人还是比较喜欢SeaJS的，尤其是RequireJS在加载一个模块后就立刻执行的做法表示不能理解，可能也跟具体的应用场景有关系，不能用SeaJS的风格来使用RequireJS吧。</p>

<p>今天粗略看了下SeaJS的源码，不对源码的细节进行分析，仅仅对其模块的组织和加载原理做简单的分析，知道了原理剩下的就是代码效率和浏览器兼容性的问题了。</p>

<p>主要解决一下问题：</p>

<ol>
<li>怎么用SeaJS</li>
<li>怎么解析、加载和执行模块</li>
<li>模块标识符（依赖名）的path解析</li>
</ol>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/09/10/inspect-seajs/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/05/settimeout-and-setinterval/">setTimeout和setInterval</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-05T01:27:00+08:00" pubdate data-updated="true">Sep 5<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>setTimeout和setInterval是浏览器环境中两个可用的定时器方案。在使用过程中曾经遇到了两个坑，在这里记录下：</p>

<h3>setInterval:</h3>

<p>可以定期按照一定的频率做一个事情，比如funA。但是如果funA中抛出了异常会怎样呢？  firefox和chrome不会因为抛出异常而做出什么奇怪的事情，毕竟调用setInterval只是告诉浏览器我要定期做一个事情，哪怕这个事情出错了；但是IE却在出现异常后停止继续定期做这个事情，所以千万要保证funA中的事情一定不要有异常出现。</p>

<h3>setTimeout:</h3>

<p>延时一段时间做某个事情funcB。比如：</p>

<p>setTimeout(tick, 1000)会在1秒之后将tick加入到事件队列中准备执行，并且tick方法的arguments是空的，但是在firefox13以下的tick的arguments却不一定是空的，有可能会有一个表示延时时间的数值(小于0)来表示执行该函数比预期时间推后了多少。新版本的firefox已经解决了该问题，但是还是不要试图在tick方法中根据arguments的数量来决定行为。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/04/status-of-thread/">Thread的状态</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-04T01:27:00+08:00" pubdate data-updated="true">Sep 4<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>每个Thread在创建出来之后就有一个状态信息，可以通过Thread.getState()来获得该thread的状态，虽然javadoc中对thread的状态有详细的描述，但是很多人还是不能很好的说出所有的状态，以及不同状态的含义，理解这些状态还有助于使用java的线程分析工具，比如jstack</p>

<p>Thread的状态是由Thread.State枚举表示的，有下面的6个值：</p>

<h3>NEW</h3>

<p>当线程刚被new出来，并且没有start的时候处于NEW状态</p>

<h3>BLOCKED</h3>

<p>线程被阻塞，一般是由于锁的原因等待进入临界区时候的状态</p>

<h3>RUNNABLE</h3>

<p>正在运行，就算是没有获得CPU时间片的线程也是在RUNNABLE</p>

<h3>WAITING</h3>

<p>顾名思义，线程处于等待状态。它正在等待其他的操作被触发，比如wait()后等待notify()或者notifyAll()；Thread.join()后等待目标线程被结束；LockSupport.park()后等待LockSupport.unpark()。</p>

<p>注意，在调用wait()后会首先进入WAITING状态，如果被notify()了，并且无法获得锁并进入临界区，那么就在BLOCKED；如果进入临界区了，那么就是RUNNABLE</p>

<h3>TIMED_WAITING</h3>

<p>相比WAITING状态，只是多了一个时间参数，比如Thread.sleep(10)，object.wait(10)等等。</p>

<h3>TERMINATED</h3>

<p>运行完毕</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/16/gc-stop-minor-gc-in-hotspot/">理解GC暂停 - Hotspot中的minor Gc[译]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-16T02:27:00+08:00" pubdate data-updated="true">Aug 16<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.ragozin.info/2011/06/understanding-gc-pauses-in-jvm-hotspots.html">原文链接</a></p>

<p>当JVM进行垃圾搜集的时候会Stop-The-World暂停，它们是java应用程序的天敌。Hotspot JVM多种先进的、被优化的垃圾收集器，但是要想找到一个最优的配置需要首先了解垃圾搜集算法的机制。这篇文章介绍了GC在STW时怎么使用CPU，并且还介绍了一个新生代的垃圾搜集算法。</p>

<h2>堆结构</h2>

<p>大多数现代GC算法都是分代收集的，这意味着java的堆被划分为了多个空间。不同的空间用其中保存的对象的年龄划分。对象首先被分配到新生代，然后经过多次存活后，最终被放到了老年代。这个是基于“大多数的对象在创建后很快就会消亡”的假设。所有的Hotspot垃圾收集器都将内存划分为5个部分（对于G1收集器，空间可能不是连续的）。</p>

<p><img src="/images/2013/08/java_heap_struct.png"></p>

<ol>
<li>Eden:eden区是对象被分配的地方</li>
<li>Survivor: Survivor区被用来在young gc或者minor gc中接收存活的对象</li>
<li>Tenured:Tenured区是保存长时间存活的对象</li>
<li>Permanent:Permanent是供JVM自己使用，比如classes或者被JIT编译后的代码，它的行为和tenured区类似，因此在文章的后面我们将忽略该区域。</li>
</ol>


<p>Eden和2个Survivor区在一起被称作新生代（yound space)。</p>

<h3>Hotspot GC算法</h3>

<ol>
<li>串行垃圾收集(-XX:+UseSerialGC)</li>
<li>新生代并行，老年代串行的分代收集(-XX:+UseParallelGC)</li>
<li>新生代和老年代都并行的分代收集(-XX:+UseParallelOldGC)</li>
<li>CMS收集算法和串行化的新生代收集器(-XX:+UseConcMarkSweep, -XX:-UseParNewGC)</li>
<li>CMS收集算法和并行化的新生代收集器(-XX:+UseConcMarkSweep, -XX:+UseParNewGC)</li>
<li>G1收集算法(-XX:+UseG1GC)</li>
</ol>


<p>除了G1之外，其他所有的垃圾收集算法在新生代部分都使用了类似的算法（串行或者并行）</p>

<h3>写屏障(Write barrier)</h3>

<p>分代垃圾收集器的关键点在于，是否有必要每次都对整个java堆进行垃圾收集，还是对其中的一部分进行收集（比如新生代)。但是JVM为了实现这个效果，需要实现一个特殊的机制“写屏障”。在Hotspot中实现了两种类型的写屏障：dirty cards和snaphot-at-the-beginning(SATB)。SATB被用于G1算法中（该文没有对其描述）。其他所有的垃圾收集算法都使用dirty cards。</p>

<h3>Dirty cards写屏障(卡片标记)</h3>

<p>Dirty cards写屏障的原理非常简单。每当应用程序改变内存中的引用时，都需要标记该内存页是脏(dirty)的。JVM中有一个特殊的卡片表(card table)，每512字节的页都对应其中的1个字节。</p>

<p><img src="/images/2013/08/card-table.png"></p>

<h3>新生代垃圾收集算法</h3>

<p>绝大部分的对象会被首先分配到eden区（除了在一些特殊的情况下，对象可能会直接被分配到老年代）。为了更高效的分配内存，Hotspot使用了线程本地分配块（thread local allocation block, TLAB)来分配新的对象，但是TLAB本身又被分配在eden区。一旦eden区满了就会触发minor gc。minor gc的目标是清理eden区，释放内存。在这里使用的是拷贝算法，存活的对象被拷贝到另外的一块区域，之前的区域的所有空间被标记为可用（free）。但是在开始垃圾收集之前，JVM首先需要找到根（root）引用，所有用于minor gc的根引用是来自堆栈的引用或者来自老年代的引用。</p>

<p>通常情况下，搜集来自于老年代的引用需要扫描整个老年代对象的所有引用，因此我们需要写屏障（write-barrier）。所有在新生代中的对象都是在上次写屏障被复位之后分配的，也就意味着非脏(no-dirty)页是不可能引用新生代的对象，最后意味着我们没必要扫描整个老年代，而只需要扫描dirty pages中的对象即可。</p>

<p><img src="/images/2013/08/dirty-pages.png"></p>

<p>最开始的dirty cards是空的，并且开始young gc后，JVM拷贝eden和其中一个survivor中存活的对象到另外一个survivor区。JVM只需要花费时间在存活对象上，拷贝和再分配（relocate）对象也需要更新指向它们的引用。</p>

<p><img src="/images/2013/08/dirty-pages1.png"></p>

<p>当JVM更新移动后的对象的引用时，内存也同时也被修改了，自然会打上dirty的标记。最终在我们下次开始young gc的时候，只有位于dirty pages中的页才有可能引用新生代的对象。</p>

<p><img src="/images/2013/08/dirty-pages2.png"></p>

<h3>对象升级</h3>

<p>如果对象没有在young gc中被清除，那么最终会被拷贝到老年代。对象升级会在下述情况下发生：</p>

<ol>
<li>-XX:+AlwaysTenure:让JVM直接将eden中的对象升级到老年代，而不通过survivor区（survivor区在这里不再使用）</li>
<li>其中一个survivor区已经满了，那么所有剩下的存活对象都直接升级到老年代。</li>
<li>如果对象在新生代的垃圾收集中存活了足够多的周期，就会被升级到老年代（存活周期数通过–XX:MaxTenuringThreshol选项和-XX:TargetSurvivorRatio选项调整）</li>
</ol>


<h3>对象直接被分配到老年代</h3>

<p>如果我们可以将存活时间较长的对象直接分配到老年代，那么我们会获得性能提升。但是很不幸，我们无法告诉JVM这么做。但是仍然还是有一些情况，对象可以直接被分配到老年代：</p>

<ol>
<li>-XX:PretenureSizeThreshold=<n>：告诉JVM如果对象的大小大于<n>时，就可以直接将该对象分配到老年代。</li>
<li>如果对象的大小大于了eden区，那么也会直接分配到老年代。</li>
</ol>


<p>不同于应用程序对象，系统级的对象会直接分配到永久带。</p>

<h3>并行执行</h3>

<p>在young gc中的大部分任务都可以并行执行。如果有多个CPU可用，那么JVM可以充分利用它们以减少STW的时间。可以通过选项–XX:ParallelGCTreads=<n>来告诉JVM使用多少个线程来执行GC。默认情况下，JVM会使用当前可用的CPU数量作为GC的线程数。但是串行版的收集器会忽律给选项，因为它只使用一个CPU线程。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/04/13/commons-logging-over-slf4j/">Jcl-over-slf4j</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/04/13/which-one-is-faster-java-heap-or-native-memory/">哪个更快：Java堆还是本地内存[译]</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/15/something-about-maven/">Maven杂谈(生命周期,插件绑定,effective-xx)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/13/scope-in-maven/">Maven依赖的scope</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/12/add-source-to-repository/">如何针对缺少source包的jar添加source包</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - zshen -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
