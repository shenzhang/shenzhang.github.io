
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>章显魅颖</title>
  <meta name="author" content="zshen">

  
  <meta name="description" content="maven中一些常用的scope及其介绍。 compile: maven的默认依赖scope，并且会应用于所有的classpath，也就是说不论在compile, test compile, 还是直接用mvn来运行(runtime)都会起作用. runtime: &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://shenzhang.github.io/blog/page/2">
  <link href="/favicon.jpeg" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Keep going" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Keep going</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:shenzhang.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/13/scope-in-maven/">Maven依赖的scope</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-13T01:27:00+10:00" pubdate data-updated="true">Sep 13<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>maven中一些常用的scope及其介绍。</p>

<h3>compile:</h3>

<p>maven的默认依赖scope，并且会应用于所有的classpath，也就是说不论在compile, test compile, 还是直接用mvn来运行(runtime)都会起作用.</p>

<h3>runtime:</h3>

<p>在compile相关的阶段都不会起作用，仅仅是在运行(runtime)或者测试(test)的时候有效。</p>

<h3>provided:</h3>

<p>和compile类似，但是往往这些依赖不需要随应用一起发布，一般是由外部环境或者容器来提供，不需要自己准备，比如说servlet-api, jsp-api这些都可以由container提供。</p>

<h3>test:</h3>

<p>这个最好理解，仅仅是在测试的时候有用，compile和runtime都不需要</p>

<h3>system:</h3>

<p>有些依赖是仓库没有的，那么可以通过使用system范围来告诉maven在指定的本地路径上查找依赖。因此需要在dependency中指定systemPath元素，告诉maven依赖的具体位置。一般来说是不应该使用该范围的，很可能大家不能共享你的配置。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/12/add-source-to-repository/">如何针对缺少source包的jar添加source包</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-12T01:27:00+10:00" pubdate data-updated="true">Sep 12<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>repository中的有些jar是没有对应的source的，比如在使用hadoop-core-1.0.4.jar包，但是由于缺少sources包，因此无法在依赖中查看源文件。</p>

<p>那么可以自己准备对应的源码包：hadoop-core-1.0.4-srouces.jar并安装到本地仓库中。</p>

<pre><code>mvn install:install-file -Dfile=e:\hadoop-core-1.0.4-sources.jar -DgroupId=org.apache.hadoop -DartifactId=hadoop-core -Dversion=1.0.4 -DgeneratePom=false -Dpackaging=java-source
</code></pre>

<p>注意<code>packaging=java-source</code>，不要使用<code>packaging=jar</code></p>

<p>从中我们可以推测maven打包和依赖查找的机制：</p>

<p>我们发布一个包，指定了groupId, artifacteId, version, packaging，那么maven会自动帮我们给要发布的文件重命名：</p>

<pre><code>packaging=jar =&gt; artifacteId-version.jar
packaging=java-srouce =&gt; artifacteId-version-sources.jar
packaging=java-doc =&gt; artifacteId-version-doc.jar
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/11/jasmine/">Javascript测试框架jasmine</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-11T01:27:00+10:00" pubdate data-updated="true">Sep 11<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://pivotal.github.io/jasmine/">jasmine</a>是一个javascript的测试框架，不同于qunit等其他测试框架，它可以用于很多js环境，比如web，nodejs等。它上手简单，并且官方有很详细的实例和描述，这里将大部分实用的api和用法记录下来。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/09/11/jasmine/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/10/inspect-seajs/">SeaJS原理解析</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-10T01:27:00+10:00" pubdate data-updated="true">Sep 10<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>对于前台javascript代码的模块化组织和依赖加载目前业界比较流行的有RequireJS和玉伯写的的SeaJS。看了下玉伯本人对这两款模块加载器的对比分析，个人还是比较喜欢SeaJS的，尤其是RequireJS在加载一个模块后就立刻执行的做法表示不能理解，可能也跟具体的应用场景有关系，不能用SeaJS的风格来使用RequireJS吧。</p>

<p>今天粗略看了下SeaJS的源码，不对源码的细节进行分析，仅仅对其模块的组织和加载原理做简单的分析，知道了原理剩下的就是代码效率和浏览器兼容性的问题了。</p>

<p>主要解决一下问题：</p>

<ol>
<li>怎么用SeaJS</li>
<li>怎么解析、加载和执行模块</li>
<li>模块标识符（依赖名）的path解析</li>
</ol>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/09/10/inspect-seajs/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/05/settimeout-and-setinterval/">setTimeout和setInterval</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-05T01:27:00+10:00" pubdate data-updated="true">Sep 5<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>setTimeout和setInterval是浏览器环境中两个可用的定时器方案。在使用过程中曾经遇到了两个坑，在这里记录下：</p>

<h3>setInterval:</h3>

<p>可以定期按照一定的频率做一个事情，比如funA。但是如果funA中抛出了异常会怎样呢？  firefox和chrome不会因为抛出异常而做出什么奇怪的事情，毕竟调用setInterval只是告诉浏览器我要定期做一个事情，哪怕这个事情出错了；但是IE却在出现异常后停止继续定期做这个事情，所以千万要保证funA中的事情一定不要有异常出现。</p>

<h3>setTimeout:</h3>

<p>延时一段时间做某个事情funcB。比如：</p>

<p>setTimeout(tick, 1000)会在1秒之后将tick加入到事件队列中准备执行，并且tick方法的arguments是空的，但是在firefox13以下的tick的arguments却不一定是空的，有可能会有一个表示延时时间的数值(小于0)来表示执行该函数比预期时间推后了多少。新版本的firefox已经解决了该问题，但是还是不要试图在tick方法中根据arguments的数量来决定行为。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/04/status-of-thread/">Thread的状态</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-04T01:27:00+10:00" pubdate data-updated="true">Sep 4<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>每个Thread在创建出来之后就有一个状态信息，可以通过Thread.getState()来获得该thread的状态，虽然javadoc中对thread的状态有详细的描述，但是很多人还是不能很好的说出所有的状态，以及不同状态的含义，理解这些状态还有助于使用java的线程分析工具，比如jstack</p>

<p>Thread的状态是由Thread.State枚举表示的，有下面的6个值：</p>

<h3>NEW</h3>

<p>当线程刚被new出来，并且没有start的时候处于NEW状态</p>

<h3>BLOCKED</h3>

<p>线程被阻塞，一般是由于锁的原因等待进入临界区时候的状态</p>

<h3>RUNNABLE</h3>

<p>正在运行，就算是没有获得CPU时间片的线程也是在RUNNABLE</p>

<h3>WAITING</h3>

<p>顾名思义，线程处于等待状态。它正在等待其他的操作被触发，比如wait()后等待notify()或者notifyAll()；Thread.join()后等待目标线程被结束；LockSupport.park()后等待LockSupport.unpark()。</p>

<p>注意，在调用wait()后会首先进入WAITING状态，如果被notify()了，并且无法获得锁并进入临界区，那么就在BLOCKED；如果进入临界区了，那么就是RUNNABLE</p>

<h3>TIMED_WAITING</h3>

<p>相比WAITING状态，只是多了一个时间参数，比如Thread.sleep(10)，object.wait(10)等等。</p>

<h3>TERMINATED</h3>

<p>运行完毕</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/16/gc-stop-minor-gc-in-hotspot/">理解GC暂停 - Hotspot中的minor Gc[译]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-16T02:27:00+10:00" pubdate data-updated="true">Aug 16<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.ragozin.info/2011/06/understanding-gc-pauses-in-jvm-hotspots.html">原文链接</a></p>

<p>当JVM进行垃圾搜集的时候会Stop-The-World暂停，它们是java应用程序的天敌。Hotspot JVM多种先进的、被优化的垃圾收集器，但是要想找到一个最优的配置需要首先了解垃圾搜集算法的机制。这篇文章介绍了GC在STW时怎么使用CPU，并且还介绍了一个新生代的垃圾搜集算法。</p>

<h2>堆结构</h2>

<p>大多数现代GC算法都是分代收集的，这意味着java的堆被划分为了多个空间。不同的空间用其中保存的对象的年龄划分。对象首先被分配到新生代，然后经过多次存活后，最终被放到了老年代。这个是基于“大多数的对象在创建后很快就会消亡”的假设。所有的Hotspot垃圾收集器都将内存划分为5个部分（对于G1收集器，空间可能不是连续的）。</p>

<p><img src="/images/2013/08/java_heap_struct.png"></p>

<ol>
<li>Eden:eden区是对象被分配的地方</li>
<li>Survivor: Survivor区被用来在young gc或者minor gc中接收存活的对象</li>
<li>Tenured:Tenured区是保存长时间存活的对象</li>
<li>Permanent:Permanent是供JVM自己使用，比如classes或者被JIT编译后的代码，它的行为和tenured区类似，因此在文章的后面我们将忽略该区域。</li>
</ol>


<p>Eden和2个Survivor区在一起被称作新生代（yound space)。</p>

<h3>Hotspot GC算法</h3>

<ol>
<li>串行垃圾收集(-XX:+UseSerialGC)</li>
<li>新生代并行，老年代串行的分代收集(-XX:+UseParallelGC)</li>
<li>新生代和老年代都并行的分代收集(-XX:+UseParallelOldGC)</li>
<li>CMS收集算法和串行化的新生代收集器(-XX:+UseConcMarkSweep, -XX:-UseParNewGC)</li>
<li>CMS收集算法和并行化的新生代收集器(-XX:+UseConcMarkSweep, -XX:+UseParNewGC)</li>
<li>G1收集算法(-XX:+UseG1GC)</li>
</ol>


<p>除了G1之外，其他所有的垃圾收集算法在新生代部分都使用了类似的算法（串行或者并行）</p>

<h3>写屏障(Write barrier)</h3>

<p>分代垃圾收集器的关键点在于，是否有必要每次都对整个java堆进行垃圾收集，还是对其中的一部分进行收集（比如新生代)。但是JVM为了实现这个效果，需要实现一个特殊的机制“写屏障”。在Hotspot中实现了两种类型的写屏障：dirty cards和snaphot-at-the-beginning(SATB)。SATB被用于G1算法中（该文没有对其描述）。其他所有的垃圾收集算法都使用dirty cards。</p>

<h3>Dirty cards写屏障(卡片标记)</h3>

<p>Dirty cards写屏障的原理非常简单。每当应用程序改变内存中的引用时，都需要标记该内存页是脏(dirty)的。JVM中有一个特殊的卡片表(card table)，每512字节的页都对应其中的1个字节。</p>

<p><img src="/images/2013/08/card-table.png"></p>

<h3>新生代垃圾收集算法</h3>

<p>绝大部分的对象会被首先分配到eden区（除了在一些特殊的情况下，对象可能会直接被分配到老年代）。为了更高效的分配内存，Hotspot使用了线程本地分配块（thread local allocation block, TLAB)来分配新的对象，但是TLAB本身又被分配在eden区。一旦eden区满了就会触发minor gc。minor gc的目标是清理eden区，释放内存。在这里使用的是拷贝算法，存活的对象被拷贝到另外的一块区域，之前的区域的所有空间被标记为可用（free）。但是在开始垃圾收集之前，JVM首先需要找到根（root）引用，所有用于minor gc的根引用是来自堆栈的引用或者来自老年代的引用。</p>

<p>通常情况下，搜集来自于老年代的引用需要扫描整个老年代对象的所有引用，因此我们需要写屏障（write-barrier）。所有在新生代中的对象都是在上次写屏障被复位之后分配的，也就意味着非脏(no-dirty)页是不可能引用新生代的对象，最后意味着我们没必要扫描整个老年代，而只需要扫描dirty pages中的对象即可。</p>

<p><img src="/images/2013/08/dirty-pages.png"></p>

<p>最开始的dirty cards是空的，并且开始young gc后，JVM拷贝eden和其中一个survivor中存活的对象到另外一个survivor区。JVM只需要花费时间在存活对象上，拷贝和再分配（relocate）对象也需要更新指向它们的引用。</p>

<p><img src="/images/2013/08/dirty-pages1.png"></p>

<p>当JVM更新移动后的对象的引用时，内存也同时也被修改了，自然会打上dirty的标记。最终在我们下次开始young gc的时候，只有位于dirty pages中的页才有可能引用新生代的对象。</p>

<p><img src="/images/2013/08/dirty-pages2.png"></p>

<h3>对象升级</h3>

<p>如果对象没有在young gc中被清除，那么最终会被拷贝到老年代。对象升级会在下述情况下发生：</p>

<ol>
<li>-XX:+AlwaysTenure:让JVM直接将eden中的对象升级到老年代，而不通过survivor区（survivor区在这里不再使用）</li>
<li>其中一个survivor区已经满了，那么所有剩下的存活对象都直接升级到老年代。</li>
<li>如果对象在新生代的垃圾收集中存活了足够多的周期，就会被升级到老年代（存活周期数通过–XX:MaxTenuringThreshol选项和-XX:TargetSurvivorRatio选项调整）</li>
</ol>


<h3>对象直接被分配到老年代</h3>

<p>如果我们可以将存活时间较长的对象直接分配到老年代，那么我们会获得性能提升。但是很不幸，我们无法告诉JVM这么做。但是仍然还是有一些情况，对象可以直接被分配到老年代：</p>

<ol>
<li>-XX:PretenureSizeThreshold=<n>：告诉JVM如果对象的大小大于<n>时，就可以直接将该对象分配到老年代。</li>
<li>如果对象的大小大于了eden区，那么也会直接分配到老年代。</li>
</ol>


<p>不同于应用程序对象，系统级的对象会直接分配到永久带。</p>

<h3>并行执行</h3>

<p>在young gc中的大部分任务都可以并行执行。如果有多个CPU可用，那么JVM可以充分利用它们以减少STW的时间。可以通过选项–XX:ParallelGCTreads=<n>来告诉JVM使用多少个线程来执行GC。默认情况下，JVM会使用当前可用的CPU数量作为GC的线程数。但是串行版的收集器会忽律给选项，因为它只使用一个CPU线程。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/16/gc-stop-cms-in-hotspot/">理解GC暂停 - Hotspot中的CMS[译]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-16T01:27:00+10:00" pubdate data-updated="true">Aug 16<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.ragozin.info/2011/06/understanding-gc-pauses-in-jvm-hotspots_02.html">原文链接</a></p>

<p>Concurrent-Mark-Sweep(CMS)是Hotspot JVM中的一个短停顿垃圾回收器。CMS在回收内存时做的大部分工作都可以和应用程序并发执行（不用暂停应用程序）。但是仍然需要短暂的Stop-The-World暂停。这篇文章会介绍这个暂停的原因以及如何减少这样的暂停。</p>

<h2>CMS基础</h2>

<p>Hotspot中的CMS收集器是分代搜集的，因此整个java堆被分为了新生代和老年代，并且它们可以独立进行搜集。对于新生代Hotspot通常使用的是拷贝算法。要想开启CMS收集器，需要在命令行参数里指定-XX:+UseConcMarkSweepGC选项。</p>

<p>CMS被用来搜集老年代，一个CMS搜集周期包括以下阶段：</p>

<ol>
<li>Inital mark:CMS在这个阶段搜集所有的根(root)引用，并且是STW的。</li>
<li>Concurrent mark:这个阶段会与应用程序并发执行，在该阶段垃圾收集器会遍历老年代的所有对象(从root开始)，将存活的对象标记出来。</li>
<li>Concurrent pre clean:这是另外一个并发阶段，主要也是用于标记操作，它会找到从上次标记(mark)之后改变了的引用。这个阶段最主要的目的是减少remark阶段的STW时间。</li>
<li>Remark：一旦Concurrent mark结束了，垃圾收集器需要进入STW暂停，在暂停的时候找到所有从上次mark之后所有被改变了的引用。</li>
<li>Concurrent sweep:垃圾收集器在该阶段会扫描整个老年代，并且回收不再使用的内存。</li>
<li>Concurrent reset：在CMS周期结束后，一些数据结构需要在下次周期开始之前被重置。</li>
</ol>


<p>不同于其他大多数垃圾收集器，CMS不会对老年代的堆内存进行整理。CMS没有对内存对象进行移动以便让为使用的空间保持连续，它会维护所有空闲内存段的列表。这样CMS避免了对内存重新布局的开销（对内存重新布局需要STW），但是负面效果就是会产生内存碎片。为了减少产生内存碎片的风险，CMS会对对象尺寸进行统计，并且针对对象的不同尺寸来维护空闲列表。</p>

<h2>CMS暂停时间</h2>

<p>CMS本身只有两个暂停点，但是你的应用程序执行新生代的垃圾回收时同样会进行暂停。</p>

<h2>Inital mark</h2>

<p>在inital mark阶段，CMS会遍历老年代的所有根引用。这包括：</p>

<ol>
<li>来自于线程栈的引用</li>
<li>来自于新生代的引用</li>
</ol>


<p>来自于线程栈的引用会搜集的很快（不超过1毫秒），但是搜集来自于新生代的引用就依赖于新生代对象的多少了。通常inital mark会在新生代gc完毕后开始，所以eden区这个时候时空的，并且其中一个survivor区里面也仅仅包含了存活下来的对象。Survivor区通常很小，因此在young gc完成后执行inital mark会很快，不超过毫秒。但是，如果inital mark在eden区满的时候开启，那么将会花费很长的时间（往往比young gc本身都还要长）</p>

<p>一旦CMS收集器被触发了，JVM会等待一段时间，让young gc完成后再开始inital mark。JVM配置参数-XX:CMSWaitDuration=<t>可以用来配置CMS等待多长时间才开始inital mark。如果你不希望长时间的inital mark暂停，那么你可以配置该选项，让等待时间略微长于你的应用中执行一次young gc所需要的时间。</p>

<h2>Remark</h2>

<p>大多数的标记（marking）可以和应用程序并行执行，但是也不是绝对的，因为有可能应用会在mark阶段修改对象引用图。当concurrent mark结束后，垃圾收集器会暂停应用程序，并且进行重复的标记以保证所有可达的的对象都已经标记为存活状态。但是收集器不需要遍历整个对象图，它仅仅需要遍历哪些自从上次标记（marking）阶段之后被修改过的引用（确切的说是从上次pre clean阶段之后）。卡片表（card table)被用来标记那些老年代中被修改的内存区域，但是新生代和堆栈部分还是需要被重新扫描一遍。</p>

<p>通常情况下remark阶段大部分时间被花费在了扫描新生代部分。如果在开始remark之前对新生代进行了gc，那么这个时间会大大缩短。我们可以加上-XX:+CMSScanvengeBeforeRemark选项来让JVM在开始remark之前强制进行新生代的gc。就算新生代是空的，remark阶段还是会对老年代中已经修改的引用进行扫描，这个所花费的时间和新生代gc暂停时间差不多。</p>

<h2>什么时候会触发CMS</h2>

<p>不同于其他老年代STW收集器，CMS搜集周期在老年代满了之前就需要开始（其他老年代收集器只需要老年代满的时候出发，而CMS需要在老年代没满的时候就触发）。CMS收集器在老年代的可用空间达到一定的阈值时（这个阈值可根据JVM在运行中搜集的统计信息或者参数来决定），并且CMS可能会推迟到下一次young gc触发之后才开始。普通的对象只会在yong gc的过程中被分配到老年代，因此CMS一般是在yong gc发生之后才开始，并且这样也会让initial mark变得很小。但是在某些情况下，对象可能会直接被分配在老年代，并且CMS开始的时候eden区可能具有很多对象。这个时候inital mark会多耗费10-100倍的时间，这个情况是非常糟糕的。通常这种情况只会在分配很大对象的时候（好几M大小的数组）。为了避免这种长暂停，你可以配置-XX:CMSWaitDuration选项。</p>

<h2>配置CMS开始的固定阈值</h2>

<p>你可以配置固定的老年代充满比例阈值来触发CMS gc：</p>

<pre><code>‑XX:+UseCMSInitiatingOccupancyOnly 
‑XX:CMSInitiatingOccupancyFraction=70(这会告诉JVM只有当超过70%的老年代被使用后才触发CMS)
</code></pre>

<h2>显式触发CMS</h2>

<p>你可以配置JVM，只要代码调用System.gc()方法后就触发CMS：<code>-XX:+ExplicitGCInvokesConcurrent</code></p>

<h2>CMS和Full gc</h2>

<p>如果CMS不能释放足够的老年代内存，JVM会启用整理式的搜集算法(Compacting)。整理收集器会强迫进入STW暂停，因此它只会出现在紧急情况下。通常大家都不希望进行full gc和较长时间的STW暂停。当CMS不能足够快的释放老年代内存，或者CMS启动的太晚了，或者因为老年代的内存碎片（没有足够的连续空间存放对象）时才会发生full gc。又或者你没有配置足够的堆内存，那么在full gc之后就会抛出OutOfMemoryException。</p>

<h2>永久带gc</h2>

<p>CMS结束后会触发full gc的一个原因是因为永久带的垃圾问题。默认的，CMS不会对永久带进行搜集。如果你的应用程序使用了多个classloader，或者反射，你可能会需要开启对永久带的垃圾回收。JVM选项-XX:+CMSClassUnloadingEnabled会允许CMS对永久带进行垃圾搜集。需要注意的是，位于永久带的对象可能会具有老年代对象的引用，如果永久带并没有满，这些从永久带到老年代的引用会导致一些已经死掉(dead)的对象在CMS周期内不可达，除非开启了class unloading。</p>

<h2>有效使用多核</h2>

<p>CMS具有多个阶段，有些是可以并发执行的，另外的是需要STW暂停的，但是可以并行执行以压缩程序暂停时间。</p>

<pre><code>-XX:+CMSConcurrentMTEnabled:允许CMS在concurrent阶段使用多核。
-XX:ConcGCThreads=&lt;n&gt;:指定concurrent阶段使用的线程数量
-XX:ParallelGCThreads=&lt;n&gt;:指定在STW暂停中并行工作的线程数（默认是机器的物理核心数）
-XX:+UseParNewGC:让JVM在新生代使用并行收集器，配合老年代的CMS。
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/14/how-to-implement-lock-in-jvm/">JVM是如何实现锁[译]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-14T01:27:00+10:00" pubdate data-updated="true">Aug 14<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://slava-technical.blogspot.de/2011/04/how-does-jvm-handle-locks.html">原文链接</a></p>

<p>Hotspot JVM 1.6具有三种类型的锁，当你试图使用java.util.concurrent.locks.Lock的实现去获取一个锁，或者进入一个synchronized块时就会使用JVM提供的锁：</p>

<h2>biased锁(偏向锁)</h2>

<p>在有些时候，就算时在一个并发环境中，实际上对于某些对象来说时没有真正的竞争的，这个时候jvm就不会向操作系统申请互斥对象(mutex)来实现锁。Hotspot可以使用一些内部的数据结构来更加高效的模拟锁。比如，一段被synchronized包裹的同步代码在当前并没有并发的执行，JVM就会使用CAS来将当前拥有锁的线程ID赋给一个用来表示互斥对象的对象中，并且如果CAS成功的话还会将重入次数也存进去。这个就是偏向锁，JVM最轻量级的锁。重入次数这个变量会被锁的当前拥有线程更新，就像更新一个局部变量一样，不会使用CAS。如果CAS失败，说明该锁当前正被其他线程拥有，这个时候JVM会暂停该互斥对象的拥有线程，将线程上下文刷新的主存中，并检查重入次数。如果重入次数时0，那么JVM就会将该锁升级为thin，否则就升级为fat。Hotspot使用互斥对象中的同样的域(field)来存储锁的拥有者线程ID</p>

<h2>thin锁</h2>

<p>这个实际上是一个简单的自旋锁。如果自旋的时间很短的话，它可以班组节约线程切换的时间（不立刻阻塞并且发生切换，而是先自旋一段时间）。当一个线程试图获取一个已经被占用的锁，那么该线程会先自旋一段时间，直到这个锁被释放。自旋的次数由内部的jvm实现决定，通常会考虑以下因素：JVM对当前应用所搜集的一些统计信息；当前线程数；CPU使用情况和数量等等。当自旋失败后，JVM决定将该thin锁升级为fat锁</p>

<h2>fat锁</h2>

<p>JVM中最高级别的锁，底层会向操作系统申请系统级别的互斥对象，并且使用操作系统的调度器来对线程进行挂起和恢复。这种类型的锁的开销比前面提到的锁要大得多，因为每次锁的释放和获取都会使得JVM与底层操作系统进行互操作。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/14/garbage-collection-in-hotspot/">Hotspot JVM中的垃圾收集器[译]</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-14T01:27:00+10:00" pubdate data-updated="true">Aug 14<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://blog.ragozin.info/2011/12/garbage-collection-in-hotspot-jvm.html">原文连接</a>，该文和我的<a href="/blog/2013/07/23/gc-in-hotspot">这篇文章</a>非常非常类似，纯属巧合。另外也可以看看<a href="http://hllvm.group.iteye.com/group/topic/38223#post-248757">这篇文章</a>对不同垃圾算法的描述。</p>

<p>Hotspot拥有好几种GC模式，具体采用那种模式可以通过命令行选项来指定。默认的GC模式由JVM的版本，client/server模式，以及当前的硬件条件来决定。</p>

<h2>串行GC（Serial GC)</h2>

<p>JVM开关：-XX:+UseSerialGC</p>

<p>串行GC是一种分代垃圾搜集算法（实际上现在的Hotspot虚拟机中的所有垃圾手机算法都是分代手机算法）。在新生代采用了拷贝算法，老年代采用了标记-整理(mark-sweep-compact MSC)算法。老年代和新生代在垃圾手机的时候都会发生STW，并且就行它的名称一样，所有手机操作都是在单个线程里完成。在老年代的垃圾收集中，所有存活的对象会被移动到空间的开始处，这样就可以让JVM将不使用的内存区域交还给操作系统。</p>

<p>如果你使用<code>-XX:+PrintGCDeitals</code>开启了GC log，你就可以看到如下输出：</p>

<p>新生代：</p>

<pre><code>41.614 [GC 41.614: [DefNew: 130716K-&gt;7953K(138240K), 0.0525908 secs] 890546K-&gt;771614K(906240K), 0.0527947 secs] [Times: user=0.05 sys=0.00, real=0.05 secs]
</code></pre>

<p>Full GC（新生代 + 老年代 + 永久区）：</p>

<pre><code>41.908 [GC 41.908: [DefNew: 130833K-&gt;130833K(138240K), 0.0000257 secs]41.909: [Tenured: 763660K-&gt;648667K(768000K), 1.4323505 secs] 894494K-&gt;648667K(906240K), [Perm : 1850K-&gt;1850K(12288K)], 1.4326801 secs] [Times: user=1.42 sys=0.00, real=1.43 secs]
</code></pre>

<h2>并行清除</h2>

<p>JVM开关:<code>-XX:+UseParallelGC</code></p>

<p>垃圾搜集的某些阶段本身就可以具有并行化的特点。并行处理可以减少GC和STW暂停需要的时间，并且可以充分利用多核CPU。现代VM中采用并行GC来有效利用多核硬件已经显得非常有必要了。并行GC在新生代中采用了并行的算法，老年代仍然采用的是单线程的Mark-Sweep-Compact算法。因此，采用该模式将会减少新生代的GC暂停时间，但是对于full gc的时间还是比较长的。</p>

<p>gc log如下：
新生代：</p>

<pre><code>59.821: [GC [PSYoungGen: 147904K-&gt;4783K(148288K)] 907842K-&gt;769258K(916288K), 0.2382801 secs] [Times: user=0.31 sys=0.00, real=0.24 secs]
</code></pre>

<p>老年代：</p>

<pre><code>60.060: [Full GC [PSYoungGen: 4783K-&gt;0K(148288K)] [PSOldGen: 764475K-&gt;660316K(768000K)] 769258K-&gt;660316K(916288K) [PSPermGen: 1850K-&gt;1850K(12288K)], 1.2817061 secs] [Times: user=1.26 sys=0.00, real=1.28 secs]
</code></pre>

<h2>老年代并行GC算法</h2>

<p>JVM开关:<code>-XX:+UseParallelOldGC</code></p>

<p>该模式是在并行清除模式基础上做的增量改进。它在老年代添加了并行化的Mark-Sweep-Compact算法，新生代还是采用并行清除里的并行算法。老年代仍然会产生较长的STW暂停，但是对多核处理器的利用可以让这个时间减少一些。不像串行MSC算法，并行的版本不会在堆的末尾产生一片连续的空闲内存区域（存活的对象都被移动到了区域的开始处），因此JVM无法将未用的区域归还给操作系统。</p>

<p>gc log如下：</p>

<p>新生代：</p>

<pre><code>65.411: [GC [PSYoungGen: 147878K-&gt;5434K(144576K)] 908129K-&gt;770314K(912576K), 0.2734699 secs] [Times: user=0.41 sys=0.00, real=0.27 secs]
</code></pre>

<p>full gc:</p>

<pre><code>65.411: [GC [PSYoungGen: 147878K-&gt;5434K(144576K)] 908129K-&gt;770314K(912576K), 0.2734699 secs] [Times: user=0.41 sys=0.00, real=0.27 secs]
</code></pre>

<h2>自适应策略</h2>

<p>JVM开关：<code>-XX:+UseAdaptiveSizePolicy</code></p>

<p>这个是在并行清除模式下的一种特殊模式，它可以动态调整新生代的大小以适应当前应用程序的特点。实际上它不会带来显著的性能提升，因此不要随便使用该选项。</p>

<h2>并行标记清除算法(CMS)</h2>

<p>JVM开关：<code>-XX:+UseConcMarkSweepGC</code></p>

<p>前面介绍的gc收集器通常被称为最大吞吐量收集器。CMS收集器是一种低暂停率的收集器，它被设计来减少STW暂停，并且提高应用程序的响应性。对于新生代可以采用串行的拷贝算法或者并行算法（该并行算法和前面介绍的并行搜集中的新生代并行算法有点类似，但是它们实际上是两套不同的实现代码，并且它们可能会使用不同的配置选项，比如自适应策略在CMS中就不存在）。</p>

<p>老年代采用了并发的搜集方法。就像名字所言，CMS是一种标记-清除算法（没有整理[compact]过程）。CMS在每个搜集周期内只需要两个很短暂的暂停，但是不像标记-整理算法，CMS不会做内存整理操作（将内存对象重新布局）并且会导致产生内存碎片。虽然CMS算法采用了一些手段来尽量克服内存碎片，但是这还是一个潜在的问题。</p>

<p>如果这种并发的收集器不能很快速的为应用程序分配内存，JVM还是会退化到使用串行的STW mark-sweep-compact（标记整理算法）来对老年代进行碎片整理（使用串行化的MSC算法的停顿时间往往是CMS停顿时间的50-500倍）。</p>

<p>gc log如下：</p>

<p>新生代：</p>

<pre><code>613.154: [GC 13.154: [DefNew: 130821K-&gt;8230K(138240K), 0.0507238 secs] 507428K-&gt;388797K(906240K), 0.0509611 secs] [Times: user=0.06 sys=0.00, real=0.05 secs]
</code></pre>

<p>老年代：</p>

<pre><code>13.433: [GC [1 CMS-initial-mark: 384529K(768000K)] 395044K(906240K), 0.0045952 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]
13.438: [CMS-concurrent-mark-start]
...
14.345: [CMS-concurrent-mark: 0.412/0.907 secs] [Times: user=1.20 sys=0.00, real=0.91 secs]
14.345: [CMS-concurrent-preclean-start]
14.366: [CMS-concurrent-preclean: 0.020/0.021 secs] [Times: user=0.03 sys=0.00, real=0.02 secs]
14.366: [CMS-concurrent-abortable-preclean-start]
...
14.707: [CMS-concurrent-abortable-preclean: 0.064/0.340 secs] [Times: user=0.36 sys=0.02, real=0.34 secs]
14.707: [GC[YG occupancy: 77441 K (138240 K)]14.708: [Rescan (non-parallel) 14.708: [grey object rescan, 0.0058016 secs]14.714: [root rescan, 0.0424011 secs], 0.0485593 secs]14.756: [weak refs processing, 0.0000109 secs] [1 CMS-remark: 404346K(768000K)] 481787K(906240K), 0.0487607 secs] [Times: user=0.05 sys=0.00, real=0.05 secs]
14.756: [CMS-concurrent-sweep-start]
...
14.927: [CMS-concurrent-sweep: 0.116/0.171 secs] [Times: user=0.23 sys=0.02, real=0.17 secs]
14.927: [CMS-concurrent-reset-start]
14.953: [CMS-concurrent-reset: 0.026/0.026 secs] [Times: user=0.05 sys=0.00, real=0.03 secs]
</code></pre>

<h2>当CMS后分配失败并且退化到MSC算法时</h2>

<pre><code>557.079: [GC 557.079: [DefNew557.097: [CMS-concurrent-abortable-preclean: 0.010/0.109 secs] [Times: user=0.12 sys=0.00, real=0.11 secs]
 (promotion failed) : 130817K-&gt;130813K(138240K), 0.1401674 secs]557.219: [CMS (concurrent mode failure): 731771K-&gt;584338K(768000K), 2.4659665 secs] 858916K-&gt;584338K(906240K), [CMS Perm : 1841K-&gt;1835K(12288K)], 2.6065527 secs] [Times: user=2.48 sys=0.03, real=2.61 secs]
</code></pre>

<h2>CMS增量模式</h2>

<p>JVM开关：<code>-XX:+CMSIncrementalMode</code></p>

<p>CMS使用一个或多个后台线程并且与应用程序线程并发的执行gc操作。这些线程会和应用程序线程竞争CPU时间。增量模式下会对gc后台线程占用的cpu时间做限制，如果只有1个或2个cpu核心，那么这会进一步提高应用程序的响应性。当然，老年代的搜集可能会变得更长，并且发生full gc的风险会更高。</p>

<h2>G1收集算法</h2>

<p>JVM开关：<code>-XX:+UseG1GC</code></p>

<p>G1(garbage first)是Hotspot中新设计的垃圾搜集器。它在jdk1.6的较新版本中本引入。G1是一种低停顿的算法，并且采用了mark-sweep-compact的改进增量型算法。G1将堆划分为大小固定的多个区域，并且可以在STW暂停中对其中的部分区域进行垃圾搜集（与CMS不同，G1大部分的工作需要在STW中运行）。增量式可以用多个短暂停代替少量的长暂停（多个短暂停的总和还是会远远大于CMS）。更精确的说，G1会采用多个后台线程与应用程序并发的运行，来对堆中的内存进行标记(mark)（与CMS类似），但是还是有大量的工作是在STW中执行。</p>

<p>G1在对其中的部分区域进行搜集时还是会采用拷贝算法，这样在每次搜集完成后会产生一些空闲的区域，它们可以被JVM在适当的时候归还给操作系统。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/3/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/09/17/spring-binding-validation/">再谈Spring的Binding和Validation</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/17/inside-angular-source-1/">AngularJS源代码分析1</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/25/java8-invokedynamic/">深入分析invokeDynamic</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/25/java8-stampedlock/">StampedLock源码分析</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/04/introspector-in-java/">Java中的Introspector</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - zshen -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
