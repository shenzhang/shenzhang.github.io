<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Keep going]]></title>
  <link href="http://shenzhang.github.io/atom.xml" rel="self"/>
  <link href="http://shenzhang.github.io/"/>
  <updated>2016-12-18T22:41:14+08:00</updated>
  <id>http://shenzhang.github.io/</id>
  <author>
    <name><![CDATA[Shen Zhang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring MVC中的二三事]]></title>
    <link href="http://shenzhang.github.io/blog/2014/09/19/spring-mvc-qa/"/>
    <updated>2014-09-19T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2014/09/19/spring-mvc-qa</id>
    <content type="html"><![CDATA[<h2>HandlerMapping和HandlerAdapter</h2>

<p>这个两个组件应该算是spring mvc中最重要的几个组件之一了，当一个请求到达DispatcherSerlvet后，spring mvc就全靠这各两个组件定位并调用我们定义的Controller函数。是的，他们的功能就分别对应了“定位”和“调用”。</p>

<h3>HandlerMapping</h3>

<p>先看看该接口的申明：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">HandlerMapping</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// ...</span>
</span><span class='line'>  <span class="c1">// 其他常量定义</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/**</span>
</span><span class='line'><span class="cm">  * Return a handler and any interceptors for this request. The choice may be made</span>
</span><span class='line'><span class="cm">  * on request URL, session state, or any factor the implementing class chooses.</span>
</span><span class='line'><span class="cm">  * &lt;p&gt;The returned HandlerExecutionChain contains a handler Object, rather than</span>
</span><span class='line'><span class="cm">  * even a tag interface, so that handlers are not constrained in any way.</span>
</span><span class='line'><span class="cm">  * For example, a HandlerAdapter could be written to allow another framework&#39;s</span>
</span><span class='line'><span class="cm">  * handler objects to be used.</span>
</span><span class='line'><span class="cm">  * &lt;p&gt;Returns {@code null} if no match was found. This is not an error.</span>
</span><span class='line'><span class="cm">  * The DispatcherServlet will query all registered HandlerMapping beans to find</span>
</span><span class='line'><span class="cm">  * a match, and only decide there is an error if none can find a handler.</span>
</span><span class='line'><span class="cm">  * @param request current HTTP request</span>
</span><span class='line'><span class="cm">  * @return a HandlerExecutionChain instance containing handler object and</span>
</span><span class='line'><span class="cm">  * any interceptors, or {@code null} if no mapping found</span>
</span><span class='line'><span class="cm">  * @throws Exception if there is an internal error</span>
</span><span class='line'><span class="cm">  */</span>
</span><span class='line'>  <span class="n">HandlerExecutionChain</span> <span class="nf">getHandler</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>实际干事的就只有getHandler一个方法，根据http请求确定将要被执行的执行链HandlerExecutionChain。一个HandlerExecutionChain就是由目标handler和一组HandlerInterceptor组成。但是需要注意的是，HandlerExecutionChain并不负责真正的执行动作，它也不知道如何去执行目标handler，而仅仅是一个保存这些对象的容器罢了。</p>

<p>目标的handler是Object类型，换句话说spring没有提供任何接口来限定，可以是任何类型。因此真正的执行动作会发生在HandlerAdpater中，也就是说如果每个HandlerMapping（不管是spring提供的还是你自己写的）都需要有对应的HandlerAdpater，当然不一定是一一对应有些是可以复用的。</p>

<h3>如何定义HandlerInterceptor</h3>

<p>不像目标handler，handler执行链上的拦截器是有限定类型的，也就是上面提到的HandlerInterceptor。那么如何配置这些HandlerInterceptor呢？</p>

<p>首先需要明确的是interceptor最终都会被配置到容器中使用的HandlerMapping组件中去，因为HandlerMapping会产生HandlerExecutionChain，需要将所有的interceptor一并设置到返回的HandlerExecutionChain中。那么最直接的方式就是在定义HandlerMapping的地方将需要的interceptor直接注入到对应的HandlerMapping类中，实际上该字段是声明在<code>AbstractHandlerMapping</code>中，因此所有的HandlerMapping最好直接从<code>AbstractHandlerMapping</code>抽象类上继承，而不要直接实现HandlerMapping接口。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;beans&gt;</span>
</span><span class='line'>    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&quot;handlerMapping&quot;</span>
</span><span class='line'>          <span class="na">class=</span><span class="s">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMap</span>
</span><span class='line'><span class="s">        &lt;property name=&quot;</span><span class="err">interceptors&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>            <span class="nt">&lt;list&gt;</span>
</span><span class='line'>                <span class="nt">&lt;ref</span> <span class="na">bean=</span><span class="s">&quot;officeHoursInterceptor&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/list&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/property&gt;</span>
</span><span class='line'>      <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;interceptors&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;list&gt;</span>
</span><span class='line'>                <span class="nt">&lt;ref</span> <span class="na">bean=</span><span class="s">&quot;officeHoursInterceptor&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/list&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/property&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/bean&gt;</span>
</span><span class='line'>    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&quot;officeHoursInterceptor&quot;</span>
</span><span class='line'>          <span class="na">class=</span><span class="s">&quot;samples.TimeBasedAccessInterceptor&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;openingTime&quot;</span> <span class="na">value=</span><span class="s">&quot;9&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;closingTime&quot;</span> <span class="na">value=</span><span class="s">&quot;18&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/bean&gt;</span>
</span><span class='line'><span class="nt">&lt;beans&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>实际上在spring中HandlerInterceptor有两类，一类是名符其实的实现了HandlerInterceptor接口的类；另外一类是<code>MappedInterceptor</code>，顾名思义它除了HandlerInterceptor的功能外还有了path match的能力，实际上它就是包含了一个真正的HandlerInterceptor外加一些路径匹配表达式。它的作用除了能够让spring调用其中包含的HandlerInterceptor之外，还具有路径匹配的功能，也就是说会告诉spring只有当指定request的请求路径复合要求的时候才会调用该interceptor。</p>

<p>OK，在回到配置HandlerInterceptor的第二种方法，就是使用&lt;mvc:interceptors/>标签，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;mvc:interceptors&gt;</span>
</span><span class='line'>  <span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">&quot;my.MyInterceptor&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;ref</span> <span class="na">bean=</span><span class="s">&quot;interceptorRef&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;mvc:interceptor&gt;</span>
</span><span class='line'>      <span class="nt">&lt;mvc:mapping</span> <span class="na">path=</span><span class="s">&quot;/interceptor/*&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">&quot;my.MyInterceptor1&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/mvc:interceptor&gt;</span>
</span><span class='line'><span class="nt">&lt;/mvc:interceptors&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个例子就定义了三个interceptor，分别通过bean, ref, interceptor子元素。其中bean和ref定义的interceptor会匹配任何request（因为没有指定mapping path）；使用interceptor子元素就可以指定mapping path了，那么它所表示的HandlerInterceptor就会根据request path来决定是否要执行。这些标签都会被转变为前面提到的<code>MappedInterceptor</code>。</p>

<p>前面说了HandlerInterceptor会最终被应用到HandlerMapping中，那通过xml配置的interceptor呢？实际上他们会被同时自动配置到spring容器中定义的所有HandlerMapping中，这也是最合乎情理的，因为你并不需要同时考虑你根据path所配置的interceptor到底应该作用到那个HandlerMapping中。相反，所有的HandlerMapping在拥有了这些MappedInterceptor后，在准备HandlerExecutionChain时就会根据当前的request path来决定要把哪些MappedInterceptor放进去，当然所有直接定义的HandlerInterceptor都会被放入chain中。</p>

<p>那么spring是怎么把这些MappedInterceptor放入到HandlerMapping中的呢？实际上spring仅仅是把他们定义到容器中，在HandlerMapping初始化的时候通过调用<em>AbstractHandlerMapping.detectMappedInterceptors</em>方法来自动发现所有的MappedInterceptor，并做一些必要的初始化配置。</p>

<p>另外一点，如果你使用了<em>&lt;mvc:annotation-driven/></em>的话，默认是会添加一个MappedInterceptor到容器中，这个interceptor是<code>ConversionServiceExposingInterceptor</code>，它会把<em>&lt;mvc:annotation-driven/></em>检测或者创建的conversionService添加到HttpServletRequest的一个属性中，以便整个http request处理流程可以随时享用这个conversionService。因为并不是所有的组件都有享受spring ioc的能力，比如jsp tag，因此放在HttpServletRequest会比较方便。</p>

<h2>HandlerAdapter</h2>

<h3>如何配置</h3>

<p>HandlerAdapter是spring mvc中的独立组件，因此和其他核心组件一样可以通过一些三种方法获得：</p>

<ol>
<li>DispatcherServlet.peroperties默认提供</li>
<li>&lt;mvc:annotation-driven/>提供</li>
<li>自己配置在spring配置文件中</li>
</ol>


<p>注意，2和3会disable掉1，但是2和3又会同时起作用。</p>

<h3>应用流程</h3>

<p>还是先看接口声明吧：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">HandlerAdapter</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/**</span>
</span><span class='line'><span class="cm">  * Given a handler instance, return whether or not this {@code HandlerAdapter}</span>
</span><span class='line'><span class="cm">  * can support it. Typical HandlerAdapters will base the decision on the handler</span>
</span><span class='line'><span class="cm">  * type. HandlerAdapters will usually only support one handler type each.</span>
</span><span class='line'><span class="cm">  * &lt;p&gt;A typical implementation:</span>
</span><span class='line'><span class="cm">  * &lt;p&gt;{@code</span>
</span><span class='line'><span class="cm">  * return (handler instanceof MyHandler);</span>
</span><span class='line'><span class="cm">  * }</span>
</span><span class='line'><span class="cm">  * @param handler handler object to check</span>
</span><span class='line'><span class="cm">  * @return whether or not this object can use the given handler</span>
</span><span class='line'><span class="cm">  */</span>
</span><span class='line'>  <span class="kt">boolean</span> <span class="nf">supports</span><span class="o">(</span><span class="n">Object</span> <span class="n">handler</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/**</span>
</span><span class='line'><span class="cm">  * Use the given handler to handle this request.</span>
</span><span class='line'><span class="cm">  * The workflow that is required may vary widely.</span>
</span><span class='line'><span class="cm">  * @param request current HTTP request</span>
</span><span class='line'><span class="cm">  * @param response current HTTP response</span>
</span><span class='line'><span class="cm">  * @param handler handler to use. This object must have previously been passed</span>
</span><span class='line'><span class="cm">  * to the {@code supports} method of this interface, which must have</span>
</span><span class='line'><span class="cm">  * returned {@code true}.</span>
</span><span class='line'><span class="cm">  * @throws Exception in case of errors</span>
</span><span class='line'><span class="cm">  * @return ModelAndView object with the name of the view and the required</span>
</span><span class='line'><span class="cm">  * model data, or {@code null} if the request has been handled directly</span>
</span><span class='line'><span class="cm">  */</span>
</span><span class='line'>  <span class="n">ModelAndView</span> <span class="nf">handle</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="n">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="n">Object</span> <span class="n">handler</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/**</span>
</span><span class='line'><span class="cm">  * Same contract as for HttpServlet&#39;s {@code getLastModified} method.</span>
</span><span class='line'><span class="cm">  * Can simply return -1 if there&#39;s no support in the handler class.</span>
</span><span class='line'><span class="cm">  * @param request current HTTP request</span>
</span><span class='line'><span class="cm">  * @param handler handler to use</span>
</span><span class='line'><span class="cm">  * @return the lastModified value for the given handler</span>
</span><span class='line'><span class="cm">  * @see javax.servlet.http.HttpServlet#getLastModified</span>
</span><span class='line'><span class="cm">  * @see org.springframework.web.servlet.mvc.LastModified#getLastModified</span>
</span><span class='line'><span class="cm">  */</span>
</span><span class='line'>  <span class="kt">long</span> <span class="nf">getLastModified</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="n">Object</span> <span class="n">handler</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>DispatherServlet在通过前面的HandlerMapping获得了当前请求的HandlerExecutionChain之后，就会哪些chain里面定义的目标handler遍历所有配置好的HandlerAdapter，并调用<em>supports</em>方法询问不同的adapter是否可以处理，如果可以就进入处理流程，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="n">HandlerAdapter</span> <span class="nf">getHandlerAdapter</span><span class="o">(</span><span class="n">Object</span> <span class="n">handler</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ServletException</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">(</span><span class="n">HandlerAdapter</span> <span class="n">ha</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">handlerAdapters</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isTraceEnabled</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">&quot;Testing handler adapter [&quot;</span> <span class="o">+</span> <span class="n">ha</span> <span class="o">+</span> <span class="s">&quot;]&quot;</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">ha</span><span class="o">.</span><span class="na">supports</span><span class="o">(</span><span class="n">handler</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="n">ha</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">throw</span> <span class="k">new</span> <span class="nf">ServletException</span><span class="o">(</span><span class="s">&quot;No adapter for handler [&quot;</span> <span class="o">+</span> <span class="n">handler</span> <span class="o">+</span>
</span><span class='line'>          <span class="s">&quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>处理流程如下：</p>

<ol>
<li>如果是GET或者HEAD请求，调用<em>HandlerAdapter.getLastModified</em>方法看看目标Controller方法在对于该请求有没有可用的lastModified逻辑，如果有的话就使用<em>ServletWebRequest.checkNotModified</em>逻辑判断当前lastModfied值和http header的上次缓存值，如果还没有过期就设置304头并且返回并结束整个请求流程。否则继续。</li>
<li>应用preHandle方法，调用所有的HandlerInterceptor.preHandle方法</li>
<li>调用<em>HandlerAdapter.handle</em>方法进行目标handler的调用（调用controller)，得到ModelAndView返回值</li>
<li>应用interceptor.postHandle方法。</li>
<li>最后根据handle返回值的请求调用<em>DispatcherServlet.processDispatchResult</em>方法来根据返回值类型处理成最终的http response。</li>
</ol>


<h3>一个栗子</h3>

<p>逻辑就是这么简单，没有什么好多说的，因为就像前面说的不同的HandlerAdapter是需要配合不同的HandlerMapping产生的目标handler，没有固定的规律和模式。就拿<code>SimpleControllerHandlerAdapter</code>这个例子来说明下把。可以和它配对的HandlerMapping有<code>ControllerBeanNameHandlerMapping</code>和<code>ControllerClassNameHandlerMapping</code>，或者说从<code>AbstractControllerUrlHandlerMapping</code>继承下来的类。</p>

<p>先看看SimpleControllerHandlerAdapter:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleControllerHandlerAdapter</span> <span class="kd">implements</span> <span class="n">HandlerAdapter</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">supports</span><span class="o">(</span><span class="n">Object</span> <span class="n">handler</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">(</span><span class="n">handler</span> <span class="k">instanceof</span> <span class="n">Controller</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">ModelAndView</span> <span class="nf">handle</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="n">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="n">Object</span> <span class="n">handler</span><span class="o">)</span>
</span><span class='line'>          <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">return</span> <span class="o">((</span><span class="n">Controller</span><span class="o">)</span> <span class="n">handler</span><span class="o">).</span><span class="na">handleRequest</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getLastModified</span><span class="o">(</span><span class="n">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="n">Object</span> <span class="n">handler</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">handler</span> <span class="k">instanceof</span> <span class="n">LastModified</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="o">((</span><span class="n">LastModified</span><span class="o">)</span> <span class="n">handler</span><span class="o">).</span><span class="na">getLastModified</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">-</span><span class="mi">1L</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以得出以下简单的结论：</p>

<ol>
<li>它只能处理目标handler是Controller类型（实现了Controller接口）的调用</li>
<li>对于lastModified特性，如果目标handler（从1可知肯定是一个Controller类型）也实现了LastModifed接口，那么就调用该接口的getLastMofied函数来得到lastMofiy值，否则返回-1表示不支持。</li>
<li>调用过程非常简单，就是调用目标Controller的handleRequest方法。</li>
</ol>


<p>从中我们可以断定和它配合的HandlerMapping返回的目标handler必须是Controller类型。好吧，我们来看看<code>ControllerBeanNameHandlerMapping</code>和<code>ControllerClassNameHandlerMapping</code>是干什么的。他们两个实际上是非常相似的，共同的父类都会扫描容器中所有定义的bean，如果该bean是Controller类型，那么就交给这两个不同的子类做处理来决定如何将这个Controller加入到mapping中。</p>

<ol>
<li>对于ControllerBeanNameHandlerMapping，它会把这个bean的名字及其alias作为request path</li>
<li>对于ControllerClassNameHandlerMapping，它会把这个bean的类名作为request path，比如HelloController对应为"/hello"。</li>
</ol>


<p>那么在收到请求后，这两个HandlerMapping会根据request path匹配已经保存的mapping数据，如果找到匹配的就会将之前存好的这个bean，也就是这个Controller对象当做目标handler返回出去。在后面的调用流程中自然就可以被SimpleControllerHandlerAdapter处理了。</p>

<p>当然，一个请求来了具体被那个HandlerMapping处理要看不同HandlerMapping的处理能力，还处理顺序，自己不能处理的旧交由下一个处理，其顺序是HandlerMapping的order值确定的。</p>

<p>这仅仅是一个例子，目前Controller类已经不推荐使用了，更多的请使用annotation的方法，当然其对应的处理组件是RequestMappingHandlerMapping和RequestMappingHandlerAdapter。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[再谈Spring的Binding和Validation]]></title>
    <link href="http://shenzhang.github.io/blog/2014/09/17/spring-binding-validation/"/>
    <updated>2014-09-17T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2014/09/17/spring-binding-validation</id>
    <content type="html"><![CDATA[<p>之前小伙伴已经写过一篇关于spring mvc中validation的<a href="http://benweizhu.github.io/blog/2014/07/19/spring-validation-by-example">文章</a>，其中还提到了与JSR-303集成和MessageCodeResolver的使用，非常详细。我想已经适用于大部分的情况了，最近也遇到了一些关于数据绑定和验证(实际上他们本来就是不可分割的)的问题，解决方案虽然有很多，但是还是希望对以下问题做一个总结以便形成一种处理该类问题的模式。</p>

<h2>1.Spring是如何做数据绑定的</h2>

<p>实际上数据绑定的过程就是一个找到目标字段，再把值设置进去的过程。目标字段的确定非常容易，最常用的类就是BeanWrapperImpl，我们可以在Spring中的很多地方见到它，再看看它所实现的接口就知道具有数据访问和类型转换的功能，实际上Spring的数据绑定很多时候也是通过BeanWrapperImpl来实现的。</p>

<p>真正比较复杂的部分是数据的转换，看过Spring文档的人都知道Spring在很早以前就是用了Java中的PropertyEditor机制来实现数据转换。但是在Spring新的版本中虽然还是支持PropertyEditor，但是更加标准的做法是是用ConverionService。ConversionService是什么？如同它的名字所说，就是提供了转换服务的对象。真正提供转换功能的是Converter类，不同的Converter能够实现的转换不一样。OK，到这里就可以想象一个最简单的模式：一个ConversionService包含很多各式各样的Converter，使得这个ConversionService成为一个无所不能的转换器！如果你想要一个这样的ConversionService，你可以直接是用Spring给我们准备好的GenericConversionService，它是一个空的ConversionService，但是你可以自己定制它所包含的Convert。除此之外，Spring还给我们准备好了一套足够全的Converter，甚至还准备好了一个配置好的ConversionService - DefaultConversionService，它实际上就是继承自GenericConversionService，只不过在它的构造函数中就帮你把Spring中得默认Converter注册进去罢了，如果你对Spring提供的Converter感兴趣，可以从这里开始看。这些ConversionService不仅仅被Spring内部使用，你甚至可以自己直接拿来在产品代码中使用。</p>

<h2>2.如何给Spring配置类型转换器</h2>

<p>提到类型转换，目前大多数情况你只需要考虑ConversionService，PropertyEditor就不要再考虑了。这里分三种情况：</p>

<h3>2.1 产品代码使用</h3>

<p>这个是最简单的，直接在配置文件中定义个DefaultConversionService或者GenericConversionService，然后再注入到你的产品代码中。</p>

<h3>2.2 供Spring解析配置文件的类型转换器</h3>

<p>Spring容器的核心实际上是BeanFactory，所有的Bean可以理解成BeanFactory通过读取配置文件然后在创建出来的。那么自然类型转换的过程也发生在其中，和类型转换相关的对象也由BeanFactory，实际上是在AbstractBeanFactroy中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/** Spring 3.0 ConversionService to use instead of PropertyEditors */</span>
</span><span class='line'><span class="kd">private</span> <span class="n">ConversionService</span> <span class="n">conversionService</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/** Custom PropertyEditorRegistrars to apply to the beans of this factory */</span>
</span><span class='line'><span class="kd">private</span> <span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">PropertyEditorRegistrar</span><span class="o">&gt;</span> <span class="n">propertyEditorRegistrars</span> <span class="o">=</span>
</span><span class='line'>      <span class="k">new</span> <span class="n">LinkedHashSet</span><span class="o">&lt;</span><span class="n">PropertyEditorRegistrar</span><span class="o">&gt;(</span><span class="mi">4</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/** A custom TypeConverter to use, overriding the default PropertyEditor mechanism */</span>
</span><span class='line'><span class="kd">private</span> <span class="n">TypeConverter</span> <span class="n">typeConverter</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/** Custom PropertyEditors to apply to the beans of this factory */</span>
</span><span class='line'><span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Class</span><span class="o">&lt;?&gt;,</span> <span class="n">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">PropertyEditor</span><span class="o">&gt;&gt;</span> <span class="n">customEditors</span> <span class="o">=</span>
</span><span class='line'>      <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Class</span><span class="o">&lt;?&gt;,</span> <span class="n">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">PropertyEditor</span><span class="o">&gt;&gt;(</span><span class="mi">4</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>那当我们在使用ApplicationContext的时候，它是怎样将ConversionService初始化进去的呢？在AbstractApplicationContext中找到了答案：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">finishBeanFactoryInitialization</span><span class="o">(</span><span class="n">ConfigurableListableBeanFactory</span> <span class="n">beanFactory</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">// Initialize conversion service for this context.</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">beanFactory</span><span class="o">.</span><span class="na">containsBean</span><span class="o">(</span><span class="n">CONVERSION_SERVICE_BEAN_NAME</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>          <span class="n">beanFactory</span><span class="o">.</span><span class="na">isTypeMatch</span><span class="o">(</span><span class="n">CONVERSION_SERVICE_BEAN_NAME</span><span class="o">,</span> <span class="n">ConversionService</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">beanFactory</span><span class="o">.</span><span class="na">setConversionService</span><span class="o">(</span>
</span><span class='line'>              <span class="n">beanFactory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="n">CONVERSION_SERVICE_BEAN_NAME</span><span class="o">,</span> <span class="n">ConversionService</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>实际上它就是在容器初始化要完成的时候检查容器内是由有名字是<em>conversionService</em>的ConversionSrervice对象，如果有的话就初始化给BeanFactory，就是这么简单。因此如果你加入自定义的转换逻辑，那么自己去申明一个ConversionService对象就完了。</p>

<h3>2.3 供Spring MVC对HttpRequest参数到Model对象的转换器</h3>

<p>当发生一个http请求时，我们可以配置我们的Controller让其自动将一些http请求参数直接转换为我们的command/model对象中。如果目标字段不是String型，必然就需要类型转换，因为HttpServletRequest中拿到的参数都是String型。</p>

<p>实际上在你申明<code>&lt;mvc:annotation-driven/&gt;</code>的时候，Spring的<code>AnnotationDrivenBeanDefinitionParser</code>就会帮你自动注册一个ConversionService到容器中，并且会将这个ConversionService放到另外一个bean<code>ConfigurableWebBindingInitializer</code>中（这个WebBindingInitializer可就非常重要啦，最后再讲)。这个默认的ConversionService是<code>FormattingConversionService</code>，它提供了比普通ConversionService更多的Formatter的功能，实际上你可以将Formatter理解成另外一种形式上的Converter(object <-> String)。</p>

<p>我们当然也可以通过直接在<code>&lt;mvc:annotation-driven/&gt;</code>显示指定来改变这个默认ConversionService，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;mvc:annotation-driven</span> <span class="na">conversion-service=</span><span class="s">&quot;conversionService&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'><span class="c">&lt;!-- conversion service --&gt;</span>
</span><span class='line'><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&quot;conversionService&quot;</span> <span class="na">class=</span><span class="s">&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;formatters&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>      <span class="nt">&lt;set&gt;</span>
</span><span class='line'>          <span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">&quot;org.springframework.format.datetime.DateFormatter&quot;</span> <span class="na">p:pattern=</span><span class="s">&quot;MM/dd/yyyy&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/set&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/property&gt;</span>
</span><span class='line'><span class="nt">&lt;/bean&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码就相当于扩充了原有的默认的实现。其实<code>AnnotationDrivenBeanDefinitionParser</code>会先检测是否有conversion-service属性，如果有就用属性指定的ConversionService，没有就自己提供一个默认的，很简单吧。</p>

<h2>3.Spring中的Validation模型</h2>

<p>在IDE中输入Validator，可以看到有很多叫Validator的类或者接口，在Spring中只需要考虑<code>org.springframework.validation.Validator</code>，你不需要考虑<code>javax.validation.Validator</code>，它最多只会被Spring的Validator所使用。</p>

<p>看看Validator的接口：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Validator</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">boolean</span> <span class="nf">supports</span><span class="o">(</span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span><span class="o">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">validate</span><span class="o">(</span><span class="n">Object</span> <span class="n">target</span><span class="o">,</span> <span class="n">Errors</span> <span class="n">errors</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>估计和你想象中得出入不大，但是实际上独立起来看是有点别扭的，因为不你清楚Errors是什么。因此大多数时候Validator是DataBinder一起使用，我想这也是为什么DataBinder也在包org.springframework.validation下面。下面的代码就是基本的使用模式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>    <span class="n">DataBinder</span> <span class="n">binder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DataBinder</span><span class="o">(</span><span class="n">object</span><span class="o">);</span>
</span><span class='line'>    <span class="n">binder</span><span class="o">.</span><span class="na">addValidators</span><span class="o">(...);</span>
</span><span class='line'>    <span class="n">binder</span><span class="o">.</span><span class="na">setConversionService</span><span class="o">(...);</span>  <span class="c1">// If you want to convert and bind data</span>
</span><span class='line'>    <span class="n">binder</span><span class="o">.</span><span class="na">bind</span><span class="o">(...);</span>  <span class="c1">// If you want to convert and bind data</span>
</span><span class='line'>    <span class="n">binder</span><span class="o">.</span><span class="na">validate</span><span class="o">();</span>
</span><span class='line'>    <span class="n">BindingResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">binder</span><span class="o">.</span><span class="na">getBindingResult</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>拿到了最后的BindingResult是不是就觉得和MVC中的BindingResult很相似了，实际上他们就是一个东西。Spring MVC也是使用上面的模式来做HttpRequest的数据绑定和验证。</p>

<p>当然你可以独立使用上面的模板来在产品代码中做数据验证，但是大部分时候对它的了解还是更多的有助于理解Spring MVC的验证过程。从上面的模板来看只有Spring MVC中得Validator是如何进行配置的没有说了，那就先来讲讲它。</p>

<p>还记得Spring MVC是如何配置ConversionService的吗，Validator和它是一样的，也可以配置在<code>&lt;mvc:annotation-driven/&gt;</code>的validator属性上。<code>AnnotationDrivenBeanDefinitionParser</code>会检测该属性，如果存在该属性则使用显示配置的Validator，并且被放入到前面提到的<code>ConfigurableWebBindingInitializer</code>中，否则就会使用一个默认的<code>OptionalValidatorFactoryBean</code>实现。这个类就有点意思了，它实际上会检测是否有JSR303的实现在classpath中，如果有那么就会提供一个包装了jsr303实现的Spring Validator的适配器，用来适配jsr303的实现。从这里可以看出，如果想利用jsr303只需要两个条件：1.将一个jsr303的实现放入到classpath中；2.声明<code>&lt;mvc:annotation-driven/&gt;</code>。</p>

<p>再回到前面的DataBinder模板，我们说Spring MVC也是使用类似的模板来做数据绑定和验证的，那么其DataBinder是怎么创建和配置的呢？我们首先需要看DefaultDataBinderFactory类，顾名思义该类就是专门用来创建WebDataBinder的工厂类，其核心方法是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="n">WebDataBinder</span> <span class="nf">createBinder</span><span class="o">(</span><span class="n">NativeWebRequest</span> <span class="n">webRequest</span><span class="o">,</span> <span class="n">Object</span> <span class="n">target</span><span class="o">,</span> <span class="n">String</span> <span class="n">objectName</span><span class="o">)</span>
</span><span class='line'>      <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">WebDataBinder</span> <span class="n">dataBinder</span> <span class="o">=</span> <span class="n">createBinderInstance</span><span class="o">(</span><span class="n">target</span><span class="o">,</span> <span class="n">objectName</span><span class="o">,</span> <span class="n">webRequest</span><span class="o">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">initializer</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">initializer</span><span class="o">.</span><span class="na">initBinder</span><span class="o">(</span><span class="n">dataBinder</span><span class="o">,</span> <span class="n">webRequest</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="n">initBinder</span><span class="o">(</span><span class="n">dataBinder</span><span class="o">,</span> <span class="n">webRequest</span><span class="o">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">dataBinder</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>基本上就分为3个步骤：</p>

<p>1.创建WebDataBinder。这个没什么好说的，基本上就是直接new出来</p>

<p>2.使用initializer来初始化。这个initializer就是前面一直提到的<code>ConfigurableWebBindingInitializer</code>，它就相当于把在配置过程中解析到的关于ConversionService和Validator先存起来，然后到需要用到DataBinder的时候再设置进去。看看它还干了什么：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">initBinder</span><span class="o">(</span><span class="n">WebDataBinder</span> <span class="n">binder</span><span class="o">,</span> <span class="n">WebRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">binder</span><span class="o">.</span><span class="na">setAutoGrowNestedPaths</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">autoGrowNestedPaths</span><span class="o">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">directFieldAccess</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">binder</span><span class="o">.</span><span class="na">initDirectFieldAccess</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">messageCodesResolver</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">binder</span><span class="o">.</span><span class="na">setMessageCodesResolver</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">messageCodesResolver</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">bindingErrorProcessor</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">binder</span><span class="o">.</span><span class="na">setBindingErrorProcessor</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">bindingErrorProcessor</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">validator</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">binder</span><span class="o">.</span><span class="na">getTarget</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>          <span class="k">this</span><span class="o">.</span><span class="na">validator</span><span class="o">.</span><span class="na">supports</span><span class="o">(</span><span class="n">binder</span><span class="o">.</span><span class="na">getTarget</span><span class="o">().</span><span class="na">getClass</span><span class="o">()))</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">binder</span><span class="o">.</span><span class="na">setValidator</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">validator</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">conversionService</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">binder</span><span class="o">.</span><span class="na">setConversionService</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">conversionService</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">propertyEditorRegistrars</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="n">PropertyEditorRegistrar</span> <span class="n">propertyEditorRegistrar</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">propertyEditorRegistrars</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">propertyEditorRegistrar</span><span class="o">.</span><span class="na">registerCustomEditors</span><span class="o">(</span><span class="n">binder</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从其中就可以看到熟悉的MessageCodesResolver和另外一个东西BindingErrorProcessor。这两个东西后面再讲。</p>

<p>3.最后一步还会调用initBinder来再做一些额外的初始化。反应快得同学可能已经想到了@InitBinder注解，是的，如果该Controller中有该注解，那么DefaultDataBinderFactory就会是一个子类<code>InitBinderDataBinderFactory</code>，该子类的initBinder方法就会调用Controller中得@InitBinder注解了的方法来对DataBinder进行额外的设置，也就是说可以覆盖默认配置做一些定制化的东西。</p>

<h2>4.到底应该在前台做验证还是后台做验证？</h2>

<p>对用户的输入数据进行验证是任何web应用都需要的，因为不但非法的用户输入不能够正常进行业务流程，甚至会破坏系统的正常运行。不管是前台还是后台，市面上都充斥着五花八门的框架，很多框架都提供了验证的功能，那么验证逻辑是放在前台还是后台呢？其实优缺点也是很明显的，将验证功能放在前台不但可以避免没必要的网络开销，使用灵活的js代码直接面对用户可以做出各种复杂的验证逻辑，并且验证结果也可以随心所欲的方便控制；将验证功能放在后台可以最大程度的保护应用，因为没有人能够保证后台收到的请求一定是来自正常的前台应用。因此我觉得关键部分的验证逻辑不管前台做不做，后台是一定要有的，并且从整个应用来看验证方式一定要统一，不要给用户造成困扰。</p>

<p>前面提到了前台的验证逻辑是可以随心所欲的，那么后台呢？当然，如果你说你直接操纵HttpServletRequest，那么你也可以根据自己的需要很容易的实现各种验证逻辑。但是在Spring MVC这种框架下怎么更加灵活的控制validation呢？</p>

<p>当request到来时经过DataBinder的两个阶段，第一是convert到command对象中；第二个是对command对象的字段进行验证，不管是使用jsr303也好，还是写自己的注解或者代码逻辑也好，只要是已经转换到了command对象中，其他的验证逻辑是非常好写的，这里往往更多的关注业务逻辑的合法性。但是如何验证第一个步骤中存在的潜在问题呢，举个最基本的例子，如何验证一个日期类型的输入参数是一个合法的日期格式，如何验证一个目标字段是int类型的参数真正是一个数字类型？如果你什么都不做，那么在前台的&lt;form:errors/>标签中就会显示出一大堆java exception的信息，这显然是我们不希望看到的。</p>

<p>好吧，还是回到DataBinder吧。针对发生在第一阶段转换过程中得任何异常都会被转换为TypeMismatchException，顾名思义就是类型不匹配导致的转换出错。这种类型的异常会直接对应到message的errorCode:</p>

<ol>
<li>code + “.” + object name + “.” + field</li>
<li>code + “.” + field</li>
<li>code + “.” + field type</li>
<li>code</li>
</ol>


<p>其中code=typeMismatch。这个翻译过程实际上就是由默认的MessageCodesResolver生成的，该过程在最开头小伙伴的文章中有说明。</p>

<p>OK，拿到了Exception并且翻译成了error code，然后又怎么办呢？这个就是由DataBinder中得<code>BindingErrorProcessor</code>来决定的了，实际上该接口也是非常简单的，默认实现就是将刚才得到的error code封装成Error对象加入到BindingResult中。</p>

<p>有了MessageCodesResolver和BindingErrorProcessor，我想就应该可以非常容易的驾驭Spring MVC的验证逻辑了，难能可贵的是这些对象都可以很容易的配置到不同Controller对应的DataBinder中去。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mvc:annotation-driven到底帮我们做了什么]]></title>
    <link href="http://shenzhang.github.io/blog/2014/08/28/what-does-mvc-annotation-driven-do/"/>
    <updated>2014-08-28T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2014/08/28/what-does-mvc-annotation-driven-do</id>
    <content type="html"><![CDATA[<p>大家都知道在使用Spring MVC的时候需要在spring mvc的配置文件中加上<code>&lt;mvc:annotation-driven/&gt;</code>这句话，但是如果不加这句话一切有是可以正常work的，那到底是加还是不加呢，针对哪些功能是必须要加的呢？</p>

<p>其实如果用一句话来描述<code>&lt;mvc:annotation-driven/&gt;</code>到底干了什么，实际上它就是一个spring的自定义标签，帮助我们自动配置一些bean到spring容器中，这些bean又会被进一步的被其他bean发现，最终实现一些预定义的功能。当然它也提供了一些属性(attribute)可以供我们做细微的调整。说到这里就不得不提<em>DispatcherServlet.properties</em>文件，如果你还不知道它在哪里，你可以在spring-webmvc-x.x.x.jar中的org.springframework.web.servlet包种找到它。就像它的名字所说，该文件会被Spring MVC的入口DispatcherServlet在初始化的使用作为默认配置使用。看看它里面的内容主要包括以下类：</p>

<ol>
<li>LocaleResolver</li>
<li>ThemeResolver</li>
<li>HandlerMapping</li>
<li>HandlerAdapter</li>
<li>HandlerExceptionResolver</li>
<li>RequestToViewNameTranslator</li>
<li>ViewResolver</li>
<li>FlashMapManager</li>
</ol>


<p>这些组件都是spring mvc中的核心组件，<em>DispatcherServlet.properties</em>中就定义这些组件的默认实现类(默认策略)。那么DispatcherServlet是怎么使用这些默认策略的呢？其中有如下函数来初始化各组件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'> <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">initStrategies</span><span class="o">(</span><span class="n">ApplicationContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">initMultipartResolver</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
</span><span class='line'>      <span class="n">initLocaleResolver</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
</span><span class='line'>      <span class="n">initThemeResolver</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
</span><span class='line'>      <span class="n">initHandlerMappings</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
</span><span class='line'>      <span class="n">initHandlerAdapters</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
</span><span class='line'>      <span class="n">initHandlerExceptionResolvers</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
</span><span class='line'>      <span class="n">initRequestToViewNameTranslator</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
</span><span class='line'>      <span class="n">initViewResolvers</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
</span><span class='line'>      <span class="n">initFlashMapManager</span><span class="o">(</span><span class="n">context</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<p>各种init函数，就拿initViewResolvers举例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'> <span class="kd">private</span> <span class="kt">void</span> <span class="nf">initViewResolvers</span><span class="o">(</span><span class="n">ApplicationContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">viewResolvers</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">detectAllViewResolvers</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="c1">// Find all ViewResolvers in the ApplicationContext, including ancestor contexts.</span>
</span><span class='line'>          <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ViewResolver</span><span class="o">&gt;</span> <span class="n">matchingBeans</span> <span class="o">=</span>
</span><span class='line'>                  <span class="n">BeanFactoryUtils</span><span class="o">.</span><span class="na">beansOfTypeIncludingAncestors</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">ViewResolver</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
</span><span class='line'>          <span class="k">if</span> <span class="o">(!</span><span class="n">matchingBeans</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>              <span class="k">this</span><span class="o">.</span><span class="na">viewResolvers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">ViewResolver</span><span class="o">&gt;(</span><span class="n">matchingBeans</span><span class="o">.</span><span class="na">values</span><span class="o">());</span>
</span><span class='line'>              <span class="c1">// We keep ViewResolvers in sorted order.</span>
</span><span class='line'>              <span class="n">OrderComparator</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">viewResolvers</span><span class="o">);</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">ViewResolver</span> <span class="n">vr</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="n">VIEW_RESOLVER_BEAN_NAME</span><span class="o">,</span> <span class="n">ViewResolver</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>              <span class="k">this</span><span class="o">.</span><span class="na">viewResolvers</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">singletonList</span><span class="o">(</span><span class="n">vr</span><span class="o">);</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>          <span class="k">catch</span> <span class="o">(</span><span class="n">NoSuchBeanDefinitionException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="c1">// Ignore, we&#39;ll add a default ViewResolver later.</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// Ensure we have at least one ViewResolver, by registering</span>
</span><span class='line'>      <span class="c1">// a default ViewResolver if no other resolvers are found.</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">viewResolvers</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">this</span><span class="o">.</span><span class="na">viewResolvers</span> <span class="o">=</span> <span class="n">getDefaultStrategies</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">ViewResolver</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>          <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">logger</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&quot;No ViewResolvers found in servlet &#39;&quot;</span> <span class="o">+</span> <span class="n">getServletName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;&#39;: using default&quot;</span><span class="o">);</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<p>实际上就是首先看看容器里有没有已经定义ViewResolver类，如果有就使用容器中定义的ViewResolver作为最终的ViewResolver，如果没有就使用<em>DispatcherServlet.properties</em>中定义的。其他的init函数也是类似的模式，首先看看是否有显示的定义，如果有就用定义好的，否则就用properties中的默认配置。好了，这下知道在零配置环境下spring mvc实际上默认的已经给我们提供了一套组件配置供我们正常使用了，如果代码出了什么问题这下知道从哪里下手查看配置了吧。</p>

<p>总算可以回到主题<code>&lt;mvc:annotation-driven/&gt;</code>了。如果要查看它到底干了什么事情，只需要看该元素对应的handler即可，也就是<code>AnnotationDrivenBeanDefinitionParser</code>。从它的javadoc中可以看出主要做了下面这些配置：</p>

<ol>
<li>HandlerMapping: 将<code>RequestMappingHandlerMapping</code>和<code>BeanNameUrlHandlerMapping</code>配置到spring容器中。</li>
<li>HandlerAdapter: 将<code>RequestMappingHandlerAdapter</code>，<code>HttpRequestHandlerAdapter</code>和<code>SimpleControllerHandlerAdapter</code>配置到spring容器中</li>
<li>HandlerExceptionResolver: 这个组件是用来控制当出现异常的时候spring如何来处理。它将<code>ExceptionHandlerExceptionResolver</code>，<code>ResponseStatusExceptionResolver</code>和<code>DefaultHandlerExceptionResolver</code>配置到spring容器中作为异常处理器。</li>
<li>ContentNegotiationManager: 这个东西是用来做内容协商的，主要是用在<code>RequestMappingHandlerMapping</code>里面。&lt;mvc:annotation-driven/>会首先检查自己有没有<em>content-negotiation-manager</em>属性，如果有的话就用属性指定的ContentNegotiationManager，否则就创建一个默认的并注册到容器中。但是最关键的还是该ContentNegotiationManager最终会被自动设置到前面定义的<code>RequestMappingHandlerMapping</code>中去。</li>
<li>DefaultFormattingConversionService: 给Spring MVC配置的ConversionService，也是spring提供的默认FormattingConversionService。</li>
<li>LocalValidatorFactoryBean: 提供自动检测jsr303实现的spring validator，主要会被用来spring mvc在收到请求，并在交给Controller的时候做数据绑定使用（数据绑定之后做数据验证）。</li>
<li>HttpMessageConverters: 创建（发现）一组HttpMessageConverter，并把他们配置到RequestMappingHandlerAdapter中，供spring mvc使用。</li>
</ol>


<p>对于HttpMessageConverter，它到底是干什么的呢？用spring mvc写过REST的人可能略知一二，它是用来将特定的对象转换成字符串并最终作为http response返回的工具。实际上spring mvc中面向开发人员的业务逻辑处理主要集中在各种Controller的方法中，基本模式是接受代表着HttpRequest的各种输入参数，在方法体中进行业务逻辑处理，最后得到输出结果，并以返回值的形式交给spring mvc，spring mvc根据返回值的不同调用不同的处理逻辑并最终以http response的形式返回给客户端。大家都知道Controller中的返回值可以有很多种，比如字符串，ModelAndView，普通对象，等等，甚至void类型都是可以的。那么很容易想到spring mvc会根据返回值的类型做很多的if else，不同的类型调用不同的处理逻辑。那么当函数受<code>@ResponseBody</code>声明时，spring就会尝试用配置好的各种HttpMessageConverter来将返回值进行序列化。不同HttpMessageConverter能够处理的对象以及处理方式都是不一样的，spring会遍历各converter，如果该converter能够处理该对象则交由其处理。因此，很多基于spring的REST风格的应用常常会返回一个model对象，那么你就应该配置好正确的HttpMessageConverter，以便spring能够正确的将这些对象序列化回客户端。</p>

<p>那么<code>&lt;mvc:annotation-driven/&gt;</code>是如何配置HttpMessageConverter的呢？</p>

<ol>
<li>首先它会看<code>&lt;mvc:annotation-driven/&gt;</code>中有没有显示指定message-converters，如果指定了那么就用指定的配置。</li>
<li>如果没有显示指定，或者虽然显示指定了但是还是指定了<em>register-defaults</em>属性的话就会默认添加一些常用的converter，比如ByteArrayHttpMessageConverter，StringHttpMessageConverter，ResourceHttpMessageConverter，SourceHttpMessageConverter，AllEncompassingFormHttpMessageConverter。除此之外还会有一些自动发现的逻辑，比如自动发现jackson和jaxb的相关组件是否在classpath中，如果存在就会加入对应的converter。因此如果你想用jackson来序列化json或者使用jaxb序列化xml，你只需要将其实现类放入到classpath中，并且再声明<code>&lt;mvc:annotation-driven/&gt;</code>就自动配置好了。</li>
</ol>


<h3>意味着什么</h3>

<p>前面介绍了<em>DispatcherServlet.properties</em>和<code>&lt;mvc:annotation-driven/&gt;</code>，实际上<em>DispatcherServlet.properties</em>的逻辑是固然存在的，我们没有办法控制；但是<code>&lt;mvc:annotation-driven/&gt;</code>我们可以选择声明或者不声明，如果声明了还可以在一定程度上控制它的行为。但是很显然如果我们使用spring mvc，是推荐声明<code>&lt;mvc:annotation-driven/&gt;</code>的，并且如果声明了<code>&lt;mvc:annotation-driven/&gt;</code>那么就会自动对一些spring mvc的核心组件进行配置，也进而disable(覆盖)了很多<em>DispatcherServlet.properties</em>中的默认配置。</p>

<p>比如对于annotation风格的spring mvc，以前是可以使用DefaultAnnotationHandlerMapping作为handler mapping的，这个也是properties中的默认配置。但是现在spring已经在用RequestMappingHandlerMapping来替代它了，这也是&lt;mvc:annotation-driven/>的默认配置。所以曾经一个同事和我讨论&lt;mvc:annotation-driver/>是不是开启注解式spring mvc功能的必要条件，现在答案很清楚了，虽然不是必要条件，但是最好还是加上<code>&lt;mvc:annotation-driven/&gt;</code>，因为背后提供该服务的组件是不一样的。</p>

<p><em>还有一点是需要强调的</em>, 要想让DispatchServlet.properties中的配置生效，比如其中定义的HandlerMapping，需要保证整个Spring Context中没有显示或隐式定义其他HandlerMapping，这种约束是很不灵活的。举个例子，你的spring配置中没有定义任何HandlerMapping，觉得DispatcherServlet.properties中提供的默认配置足够了，并且也想使用RequestMapping定义的Controller，在通常情况下这个是可以满足要求的。但是如果你又想将没有匹配成功的request交给应用服务器的默认Servlet来处理，就需要在spring-servlet.xml中配置&lt;mvc:default-servlet-handler/>，这个时候你会发现RequestMapping不能工作了，为什么？原因是&lt;mvc:default-servlet-handler/>会在context中隐式加入SimpleUrlHandlerMapping，导致spring在解析的时候发现有可用的HandlerMapping，就不会再去加载DispatcherServlet.properties中定义的配置。</p>

<p>总之，当你在使用spring mvc的时候，虽然它帮我们做了很多事情，一切看起来都是work的，但是还是要清楚你的系统中有哪些组件在起作用，这样出了问题才知道如何定位问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AngularJS源代码分析1]]></title>
    <link href="http://shenzhang.github.io/blog/2014/08/17/inside-angular-source-1/"/>
    <updated>2014-08-17T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2014/08/17/inside-angular-source-1</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入分析invokeDynamic]]></title>
    <link href="http://shenzhang.github.io/blog/2014/05/25/java8-invokedynamic/"/>
    <updated>2014-05-25T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2014/05/25/java8-invokedynamic</id>
    <content type="html"><![CDATA[<p>Placeholder</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[StampedLock源码分析]]></title>
    <link href="http://shenzhang.github.io/blog/2014/05/25/java8-stampedlock/"/>
    <updated>2014-05-25T00:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2014/05/25/java8-stampedlock</id>
    <content type="html"><![CDATA[<p>Placeholder</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中的Introspector]]></title>
    <link href="http://shenzhang.github.io/blog/2014/05/04/introspector-in-java/"/>
    <updated>2014-05-04T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2014/05/04/introspector-in-java</id>
    <content type="html"><![CDATA[<p>This is the placeholder for Introspector in Java.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中的Reference对象[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2014/04/27/java-reference-objects/"/>
    <updated>2014-04-27T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2014/04/27/java-reference-objects</id>
    <content type="html"><![CDATA[<p><a href="http://www.kdgregory.com/index.php?page=java.refobj#ObjectLifeCycle">原文链接</a></p>

<h2>介绍</h2>

<p>我从2000年开始用Java编程，在这之前使用了C和C++长达15年。我觉得我有能力在C类的语言中管理好内存，比如使用指针偏移，或者使用工具比如Purify。不记不清我遇到的最后一次内存泄露问题了。因此我确实对Java的自动内存管理有点不削，但是我很快爱上它了。我从来没有意识到在内存管理中需要花费多大的经历，因为它不需要我做任何事情。</p>

<p>随后我遇到了我的第一次OOM。它仅仅显示在控制台中，并且没有任何堆栈信息，因为堆栈跟踪信息需要内存开销。调试这个错误是非常痛苦的，因为没有任何工具可以使用，甚至是<code>malloc</code>日志。在2000年的Java调试的状况就是如此，非常原始。</p>

<p>我记不清造成这次OOM的原因是什么了，当然我并没有使用<code>reference</code>对象来解决这个问题。它们没有在我的常用工具箱中，直到1年以后，当我在写一个数据库缓存，并且打算尝试使用它们以减少缓存的内存开销。但是发现它们并不是那么有效，原因我会在后面分析。但是当它们进入到我的工具箱之后，我发现了很多关于这些reference对象的用法，并且可以让我更好的理解JVM。</p>

<!-- more -->


<h2>Java堆和对象生命周期</h2>

<p>对于一个刚刚接触Java的C++程序员来说，堆和栈的关系是很难被理解的。在C++中对象可以使用<code>new</code>关键字将其分配在堆中，或者使用自动的分配方法将其分配在栈中。将一个<code>Integer</code>对象分配在栈中在C++里是完全合法的。但是对于Java编译器，却会出现语法错误：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Integer</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>不同于C++，在Java中所有的对象都被分配到堆上，并且需要<code>new</code>关键字来创建。局部变量被存放在栈中，但是它们仅仅是保存了指向这个对象的指针，不是这个对象本身。看下面这个Java方法，它分配了一个<code>Integer</code>对象，并且解析一个<code>String</code>对象来获得其值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">foo</span><span class="o">(</span><span class="n">String</span> <span class="n">bar</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">Integer</span> <span class="n">baz</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="n">bar</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面的这幅图显示了在这个方法中堆和栈之间的关系。栈被分为了很多“帧”，它包含了调用树中的每个方法的参数和局部变量。这些变量指向了很多其他对象：在这个例子中，参数<code>bar</code>和局部变量<code>baz</code>指向了位于堆中的变量：</p>

<p><img src="http://shenzhang.github.io/images/2014/05/stack_and_heap.gif"></p>

<p>现在我们来更近一点看下foo函数中得第一行代码，它分配了一个Integer对象。首先JVM会尝试找到一个足够的堆空间来存放这个对象，大约需要12个字节。如果找到了可以分配的空间，那么它就会调用对应的构造函数来初始化这个对象，并且将这个对象的指针存到变量baz中。如果JVM没有找到足够的可分配空间，那么它就会调用垃圾回收器来尝试腾出一般分空间。</p>

<h3>垃圾回收</h3>

<p>虽然Java提供了new操作符来让你在堆中分配对象，但是它缺没有提供delete操作符来让你释放这个对象。当foo()函数返回时，变量baz就会退出它的作用域，但是它所指向的对象任然存在于堆中。如果故事就这样结束了，那么所有的应用程序都会很快的用完虽有内存。但是，Java提供了自动的垃圾回收机制来清理这些已经没有任何引用的对象。</p>

<p>当程序尝试分配一个新的对象，但是又没有足够的堆空间时就会触发垃圾回收。当前请求的线程会被挂起，并且垃圾回收器会在堆空间中进行查找，尝试找到那些不会再被程序使用的对象，并且回收它们的堆空间。如果垃圾搜集器不能释放足够的空间，并且JVM不能再扩展(expand)堆空间，那么new操作符就会失败，并且抛出<code>OutOfMemoryError</code>。这通常会导致你的应用程序挂掉。</p>

<p>这有很多非常优秀的参考文献来说明Java的垃圾回收器是如何工作的，有些我列在了文章的最后。它们不但适合阅读，而且还会教你如何对你的应用程序进行调优，而现在你仅仅需要知道的是Java使用了一种'标记-清除-整理'的垃圾回收器，并且对强引用进行垃圾搜集。</p>

<h3>标记-清除-整理</h3>

<p>mark-sweep-compact垃圾搜集器的思想非常简单：所有不能在被程序使用到的对象将会被搜集和清理。这存在三个过程：</p>

<ol>
<li>垃圾搜集器会从“根”对象开始，遍历所有的对象图，并且将访问过的对象都打上标记。</li>
<li>然后会重新遍历堆中的所有对象，将没有打上标记的对象清理掉。</li>
<li>最后，它会对堆空间进行整理，将现存的对象移动到一起，让清理出来的空闲空间合并成更大的连续空间。</li>
</ol>


<p>那什么又是“根”对象呢？在简单的Java应用程序中，它们是方法参数和存放在栈中的局部变量，以及当前执行表达式的操作数（也存放在栈中），还有类的静态static成员变量。</p>

<p>在使用了自定义的ClassLoader的程序中，比如应用服务器，事情就会变得复杂些：只有被system classloader(JVM启动的时候使用的加载器)加载的类才能包含根对象。应用程序自己创建的classloader也服从垃圾回收规则，如果没有被其他对象引用了，就会被回收。这种特性就允许应用服务器进行热部署(hot-deploy)：它们可以为不同的要部署的应用创建不同的classloader，然后当这个引用需要卸载或者重新部署的时候将这个classloader的引用给去掉。</p>

<p>理解什么是根引用非常重要，因为它们也定义了什么是强引用：如果你能顺着一个从根对象开始的引用链访问到一个指定的对象，那么这个对象就是被强引用的。并且它是不会被垃圾回收的。</p>

<p>因此，回到foo()方法，参数bar和局部变量baz在该方法被执行的时候都是强引用。当方法返回的时候，它们都会离开作用域，它们所引用的对象都会被垃圾回收。在真实场景中，foo()方法可能会返回由baz引用的对象，这也就意味着它任然会由foo()的调用着保持着强引用。</p>

<p>现在来看看接下来的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">LinkedList</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">();</span>
</span><span class='line'><span class="n">foo</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="mi">123</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>变量foo是一个根对象，它指向了一个LinkedList对象。在这个链接表中有零个或者多个列表元素，并且它们都有一个指针指向后面的元素。当维我们调用call()方法时，其中一个元素会指向这个值为123的Integer对象。这就形成了一个强引用链，从根对象开始，同时也意味着这个Integer对象不会被垃圾回收。当foo对象离开作用域后，LinkedList对象以及它的列表元素都会被垃圾回收，当然没有其他的引用指向这个LinkedList及其元素。</p>

<p>你可能会想，如果出现了循环引用该怎么办：对象A包含了一个指向对象B的引用，对象B也包含了一个指向对象A的引用。答案是标记清除算法是很聪明的，如果A或者B不能由从根对象开始的强引用所引用到，那么它们将会被垃圾回收。</p>

<h3>Finalizers</h3>

<p>C++允许定义一个类的析构函数：当一个对象离开作用域或者被显示delete时，它的析构函数会被调用以便对它使用的资源做清理操作。对大多数对象来说，这意味着可以显示的释放由new或者malloc分配的内存。在Java中，垃圾回收器为你做了清理内存的工作，因此没有必要存在一个显示的析构函数。</p>

<p>但是，不仅仅只有内存才需要被清理。考虑<code>FileOutputStream</code>类：当你创建了这个对象的一个实例，它就会从操作系统中分配一个文件句柄。如果在显示关闭它之前，所有对它的引用都消失了，那么对于这个文件句柄将会发生什么事情呢？实际上这个stream对象有一个finalizer方法，这个方法会在JVM的垃圾回收器对他进行回收之前被调用。以这个<code>FileOutputStream</code>为例子，这个finalizer方法会关闭这个流，并且将这个文件句柄归还给操作系统，还会对没有保存的数据做刷新操作，确保所有的数据都会被写入硬盘中。</p>

<p>任何的Java对象都可以拥有一个finalizer方法，你仅仅需要做的是在这个类中声明一个<code>finalize()</code>方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">finalize</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Throwable</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="c1">// cleanup your object here</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>虽然finalizer方法看起来是一个清理自己的非常简便的方法，但是实际上它是有很多严重的限制的。首先，你不应该依赖它去清理一些非常重要且珍贵的资源，因为这个方法可能永远不会被调用（应用程序可能在它被回收之前就已经结束了）。还有一些其他更加微妙的问题，但是我现在不讲，直到我们讲到幽灵引用(phantom reference)的时候。</p>

<h3>对象的生命周期</h3>

<p>总结一些，下面的这幅图可以总结所有对象的生命周期：创建，使用，待清理，被回收。阴影的部分说明了当前该对象是强引用可达的。这个和接下来的引用对象(reference objects)对比起来至关重要。</p>

<p><img src="http://shenzhang.github.io/images/2014/05/object_life_cycle.gif"></p>

<h2>引用对象</h2>

<p>JDK1.2引入了<code>java.lang.ref</code>包，并且引入了三个新的对象生命周期状态：软可达(softly-reachable)，弱可达(weakly-reachable)，幻象可达(phantom-reachable)。这三种状态仅仅对处于待回收状态的对象有效，换句话说，它们都已经没有强引用了，并且它们都是被引用对象所引用的。</p>

<p><em>软可达</em>：这种类型的对象由<code>SoftReference</code>所引用。垃圾回收器会尽可能长时间的保留该对象，直到要抛出<code>OutOfMemeoryError</code>以前才会进行回收。</p>

<p><em>若可达</em>：这种类型的对象由<code>WeakReference</code>所引用，并且没有其他任何强引用。垃圾回收器可以在任意时间根据需要回收这些对象。在实践中，这种对象往往在major gc中被回收，而不会被minor gc所回收。</p>

<p><em>幻象可达</em>：这种类型的对象由<code>PhantomReference</code>所引用，并且没有任何强引用，软引用，弱引用。这种类型的对象与上述两种类型非常不一样，往往我们不会再去访问这个对象，仅仅是当做一个该对象被回收的信号使用，垃圾回收器可以随时回收它。</p>

<p>你也许会感觉到，添加这三个不一定每个对象都具有的状态到对象声明周期序列中会很奇怪。虽然在文档中说明了从强引用到进过软引用、弱引用、幻象引用到最后被回收的逻辑关系，但是在实际过程中这却依赖于你的程序到底是创建的什么类型的引用。如果你创建了一个<code>WeakReference</code>而不是<code>SoftReference</code>，那么这个对象将会直接从强引用到弱引用，最后被回收。</p>

<p><img src="http://shenzhang.github.io/images/2014/05/object_life_cycle_with_refobj.gif"></p>

<p>还有一点需要注意的是，并不是所有的对象都和上面列举的引用对象有关联，实际上仅仅只有一小部分对象会用到这些引用对象。一个引用对象实际上是引入了一个间接层，你需要通过这些引用对象来获取到实际被引用的对象，并且很明显你不想在你的代码中充斥着这些间接层。在大多数应用程序中，仅仅只有一小部分对象需要这些引用对象。</p>

<h3>引用和被引用</h3>

<p>一个引用对象是你的代码和实际被引用对象中间的一个间接层。每一个引用对象在创建的时候都需要一个被引用对象作为参数，并且这个被引用对象不能再被改变。</p>

<p><img src="http://shenzhang.github.io/images/2014/05/normal_refobj_relations.gif"></p>

<p>引用对象提供了一个<code>get()</code>方法来获得被引用对象的强引用。一旦get()方法返回null，就说明了被引用对象已经被垃圾回收了。下面的代码演示了这种情况：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">SoftReference</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;&gt;</span> <span class="n">ref</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SoftReference</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;&gt;(</span><span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;());</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// create some Foos, probably in a loop</span>
</span><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">list</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">&quot;ran out of memory&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">foo</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这有几点需要注意：</p>

<ol>
<li>你始终需要检查返回值是不是为null。垃圾回收器可能在任何适合将被引用对象回收，如果你直接使用返回得到的引用，可能会产生<code>NullPointerException</code></li>
<li>如果你要继续使用这个被引用对象，那么就需要保持住这个返回的强引用。再一次强调，因为垃圾回收器可能在任何时候将被引用对象回收，哪怕是在两条代码语句的中间。如果你仅仅是见得的检查get()方法的返回值不为null，然后就又一次调用get()方法来使用这个引用，很有可能在两次get()方法中间该被引用对象已经被回收了。</li>
<li>你需要对这个引用对象保持一个强引用。如果你仅仅是创建了一个引用对象，但是又让它出了作用域，那么这个引用对象本身也会被垃圾回收。它们的存在就是为了避免这些被引用的对象很快被垃圾回收掉。期初这确实看起来很奇怪，既然没有任何引用这项这些对象了，那为什么还要使用这些引用对象来间接指向这些对象呢？</li>
</ol>


<h2>软引用</h2>

<p>我们来利用软引用来尝试解答上面的问题。如果一个对象没有任何强引用，但是却被一个<code>SoftReference</code>所引用，虽然垃圾回收器可以根据需要在任何时间对它进行回收，但是垃圾回收器会尽可能的不这么做。你可以调整垃圾回收器，让它在回收软引用时变得更加激进或者相反。</p>

<p>JDK的文档中说，它可以被用在那些内存敏感的缓存中：所有缓存的对象都通过<code>SoftReference</code>引用和使用，如果JVM想释放更多的内存，那么就可以清理掉其中的部分或者所有被引用对象。如果JVM暂时还不需要更多的内存，那么这些被缓存对象就可以一直保存在堆空间中，并且可以让程序进行访问。在这种场景中，被引用对象如果正在被使用那么就是强引用的，否则就是软引用的。如果缓存对象被清理了，那么你就需要更新这个缓存。</p>

<p>虽然这样使用软引用非常实用，但是也仅限于被缓存对象的大小非常大时，一般是好几K的大小。比如说，你实现了一个文件服务器需要经常返回一些同样的文件，或者有很多大对象需要被缓存，这种使用场景就非常有用。但是如果你要缓存的对象都比较小，那么这些SoftReference引用对象本身就可能对整个应用程序造成了较大的负担。</p>

<h3>作为断路器来使用软引用</h3>

<p>软引用的一个更好的使用场景是将它用作内存分配过程中得圈断路器：将它放在你的代码和实际分配的内存中间，那么就可以很有效的避免OutOfMemoryError。因为内存分配通常都具有局部性，特别是当你从数据库中读取数据时，或者处理一批从文件来的数据时。</p>

<p>比如，你写了很多JDBC的代码，你可能会有下面的代码来处理查询结果，并且需要保证ResultSet可以被正常关闭。但是它还是有一些问题：如果你的返回结果有数百万条会发生什么？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&gt;</span> <span class="nf">processResults</span><span class="o">(</span><span class="n">ResultSet</span> <span class="n">rslt</span><span class="o">)</span>
</span><span class='line'><span class="kd">throws</span> <span class="n">SQLException</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="k">try</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&gt;();</span>
</span><span class='line'>        <span class="n">ResultSetMetaData</span> <span class="n">meta</span> <span class="o">=</span> <span class="n">rslt</span><span class="o">.</span><span class="na">getMetaData</span><span class="o">();</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">colCount</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="na">getColumnCount</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="n">rslt</span><span class="o">.</span><span class="na">next</span><span class="o">())</span>
</span><span class='line'>        <span class="o">{</span>
</span><span class='line'>            <span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">row</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;(</span><span class="n">colCount</span><span class="o">);</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">;</span> <span class="n">ii</span> <span class="o">&lt;=</span> <span class="n">colCount</span> <span class="o">;</span> <span class="n">ii</span><span class="o">++)</span>
</span><span class='line'>                <span class="n">row</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">rslt</span><span class="o">.</span><span class="na">getObject</span><span class="o">(</span><span class="n">ii</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">results</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">row</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">results</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">finally</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">closeQuietly</span><span class="o">(</span><span class="n">rslt</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>答案很明显，会发生OutOfMemeoryError，除非你有1个G的内存或者较少的查询结果。在这种场景下使用断路器是一个很不错的选择：如果在处理查询结果的时候JVM要用尽所有的内存，那么它就会释放已经使用过的对象，并且抛出一个应用程序级别的异常。</p>

<p>这个时候你可能会想，谁又会关心呢？反正查询操作都是要失败，为什么不直接让JVM抛出OOM呢？实际上如果发生了OOM，那么不一定只有你的应用程序会受影响。如果你运行在一个应用服务器中，你使用内存的方式可能会影响到其他的应用。就算在一个非共享的环境中，断路器也可以让你的应用程序更加健壮，它很好的处理的问题本身，并且让你有机会从其中恢复过来。</p>

<p>创建一个断路器，你需要将查询结果封装到一个<code>SoftReference</code>对象中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">SoftReference</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&gt;&gt;</span> <span class="n">ref</span>
</span><span class='line'>    <span class="o">=</span> <span class="k">new</span> <span class="n">SoftReference</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&gt;&gt;(</span><span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&gt;());</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在对这些查询结果进行迭代过程中，如果你需要对它进行更新，那么创建一个指向查询结果的强引用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">while</span> <span class="o">(</span><span class="n">rslt</span><span class="o">.</span><span class="na">next</span><span class="o">())</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">rowCount</span><span class="o">++;</span>
</span><span class='line'>    <span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">row</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;(</span><span class="n">colCount</span><span class="o">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">;</span> <span class="n">ii</span> <span class="o">&lt;=</span> <span class="n">colCount</span> <span class="o">;</span> <span class="n">ii</span><span class="o">++)</span>
</span><span class='line'>        <span class="n">row</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">rslt</span><span class="o">.</span><span class="na">getObject</span><span class="o">(</span><span class="n">ii</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">results</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>        <span class="k">throw</span> <span class="k">new</span> <span class="nf">TooManyResultsException</span><span class="o">(</span><span class="n">rowCount</span><span class="o">);</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>        <span class="n">results</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">row</span><span class="o">);</span>
</span><span class='line'>    <span class="n">results</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个代码之所以可以工作是因为所有对内存的分配都集中在两个地方：next()方法和循环中得getObject()方法。在第一中场景中，当你调用next()方法，实际上背后发生了很多事情：通常<code>ResultSet</code>会获取一大块的二进制数据，其中包含了多条记录。然后当你调用getObject()方法，它会从中提取出一部分数据，并且将它包装成一个Java对象。</p>

<p>但是当这个非常昂贵的方法被调用的时候，对所有查询结果的引用仅仅只有<code>SoftReference</code>一个。如果你用尽了所有内存，那么这个查询结果集就会被垃圾搜集。这也就意味着会紧跟着抛出异常，但是这个异常是受控的。也许调用端的代码会捕获这个异常，然后再次做查询操作，并且会带上一些limit参数来限制结果集的大小。</p>

<p>一旦这个昂贵的操作完成了，你可以很安全的使用一个强引用来引用之前的结果集对象。注意，我们这里使用了<code>LinkedList</code>，它在增长的过程中仅仅只需要十几个字节，不太会在这里发生OOM。相比之下，当<code>ArrayList</code>需要增加其容量的时候，它就会重新创建一个新的数组，如果对于一个较大的list，这可能会需要消耗数M的内存。</p>

<p>同时需要注意的是，一旦我将新的结果加入到结果集后，我就立刻将结果集的引用设置成null。虽然在循环结束的时候，其引用已经离开其作用域了，但是垃圾搜集器并不会立刻知道（因为JVM不会立刻清理掉调用栈中得变量槽）。因此，如果我不显示清理掉这个变量，它就会无形中保留一个强引用到这个结果集，这会对后面的循环造成影响。</p>

<h3>软引用不是银弹</h3>

<p>虽然软引用可以避免很多OOM的情况，但是他们不能避免所有的问题。为了使用一个软引用，我们需要首先创建一个具有强引用的被引用对象，但是当我们在创建这个强引用对象时，我们就有可能发生OOM。在上面说到的那个例子中，我们将返回列表的指针首先存到了一个局部变量中，就算我们仅仅是在表达式中使用到了，那么实际上在表达式运行的时候也会有一个强引用。</p>

<p>使用软引用作为断路器的主要目的是为了减少对象无用之后的时间窗口，也就是你拥有这个强引用的时间以及在该时间内内存分配的次数。在我们这个例子中，我们将这个强引用的时间边界限定在了将它添加到结果集中，并且我们使用了<code>LinkedList</code>而不是<code>ArrayList</code>，因为<code>LinkedList</code>在增长的时候的代价更小。</p>

<p>除此之外，我们将这个强引用存放在了一个变量中，并且让这个变量很快就离开其作用域。但是由于Java虚拟机规范中没有说明JVM实现必须要在局部变量超过作用域的时候立刻将它清除掉，事实上Sun的JVM就没有立刻清除。如果我们不显示的清除<code>results</code>变量，那么这个强引用就会在接下来的循环中一直保持。</p>

<h2>弱引用</h2>

<p>弱引用就像它的名字所描述的一样，它不会尽最大的努力去保持被引用的对象不被垃圾回收掉。也就是说，如果没有其他的强引用或者软引用指向这个被引用对象，那么它就非常有可能很快就不回收掉。</p>

<h3><code>ObjectOutputStream</code>的问题</h3>

<p>当你将一些对象写入到ObjectOutputStream中，它就会维护一个强引用到这个对象，并且会关联一个唯一的ID到这个对象，然后将这个ID连同对象本身一起写入到流中。这有两个好处，特别是你之后又写入了一个完全相同的对象：首先你可以节约带宽，因为输出流仅仅需要再次写入ID就可以了；另外在反序列化的时候你可以通过这个ID来验证对象是否是完整的。</p>

<p>但是不幸的是，这任然有内存泄露的风险，因为流会永远保持住这个原始对象的引用，直到你关闭这个流或者调用reset方法。如果你使用对象流仅仅是为了移动对象，而不关心对象的完整性和带宽，你可以试试调用<code>reset()</code>方法。</p>

<p>如果<code>ObjectOutputStream</code>使用<code>WeakReference</code>来保存原始对象，那么这个问题就不会发生：当这个对象超过作用域时，垃圾回收器就可以回收这些对象。因为如果这个对象已经没有任何强引用了，那么也不可能会被再次写入，同样那么就没有必要将这些对象一直保持住。最好的方式是，ObjectOutputStream可以通知ObjectInputStream，在某些时候也能够让接收方也不要再保存这个对象的引用。</p>

<p>但是不幸的是，虽然对象流协议已经在JDK1.2之后被更新了，并且1.2之后也引入了弱引用，但是JDK的开发人员并有将他们结合到一起。</p>

<h3>使用<code>WeakHashMap</code>来关联对象</h3>

<p>说实话，我相信大部分的对象之间都有或多或少的联系。不是组合关系，就是聚合关系。</p>

<p>JDK提供了<code>WeakHashMap</code>来提供这种关联关系，并且其中的key是弱引用的。当key在应用程序中不再拥有引用了，那么这个map的entry就不再是可访问的了。但是实际上，这个entry还是在map中存在，直到下一次访问这个map的时候。因此，你可能会发现你的对象在堆中得存活时间比你预期的要长的多。</p>

<p>在这里我们不会用一个例子来解释，我们会在一个使用canonicalizing map的场景中看看怎么使用<code>WeakHashMap</code>。</p>

<h3>排除重复的数据</h3>

<p>一个更好的使用<code>WeakHashMap</code>的用例是canonicalizing map，它实际上和java本地方法<code>String.intern()</code>的功能差不多。当你要intern一个字符串时，会返回给你一个唯一的标准化了的字符串对象给你。当你从一个输入源读取数据时，并且有很多重复的字符串，比如说XML或者HTML文档，被intern的字符串就可以节约很多的内存空间。</p>

<p>一个简单的canonicalizing map实现可以使用相同的字符串作为key和value，每次都检查是否存在一个value，如果存在就直接返回这个value。如果不存在，那么就将这个参数作为一个新的entry的key和value保存起来。当然，这种模式仅仅适用于对象可以作为map的key的情况。下面是一个简单的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">_map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">String</span><span class="o">&gt;();</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">synchronized</span> <span class="n">String</span> <span class="nf">intern</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">_map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">str</span><span class="o">))</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">_map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
</span><span class='line'>    <span class="n">_map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="n">str</span><span class="o">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">str</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你的字符串数量不是很多，那么这种实现还将就。但是如果你的应用程序需要运行很长的时间，并且需要处理的字符串有很多很多，那么就还是有可能会重复。比如，一个会标准化请求头的HTTP服务器，大约有10多个不同的"User-Agent"头，并且其中的某些头的出现频率比其他头高很多，Google机器人可能一周仅仅会访问一次。</p>

<p>那么你就可以在你需要代码中使用的时候，才保持这些标准化之后的对象，这样可以大幅减少堆内存的长时间占用。这个时候弱引用就可以派上用场了：使用弱引用来引用这些map的entry，当不在存在强引用的时候，垃圾回收器就可以对他们进行搜集。一旦Google机器人访问了你的站点，那么它的User-Agent就可以被记录下来了。</p>

<p>我们来使用WeakHashMap来优化刚才的标准化器：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">_map</span>
</span><span class='line'>    <span class="o">=</span> <span class="k">new</span> <span class="n">WeakHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;();</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">synchronized</span> <span class="n">String</span> <span class="nf">intern</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">_map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="o">(</span><span class="n">ref</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">ref</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">:</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">s2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">s2</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// as-of 1.5, still possible for a string to reference a much larger</span>
</span><span class='line'>    <span class="c1">// shared buffer; creating a new string will trim the buffer</span>
</span><span class='line'>    <span class="n">str</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
</span><span class='line'>    <span class="n">_map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="k">new</span> <span class="n">WeakReference</span><span class="o">(</span><span class="n">str</span><span class="o">));</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">str</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>首先需要注意的是，这个map的key是一个字符串，它的value是一个WeakRefernce<String>。这是因为WeakHashMap仅仅会使用WeakRefence来引用对应的key，Map.Entry会保持一个强引用到它的value。如果我们不用WeakReference来将这个value包装起来，那么这个字符串讲永远不会被回收。</p>

<p>其次，我们是使用引用对象来引用这些字符串，因此我们需要一个强引用来接收返回值。我们虽然可以直接使用<code>ref.get()</code>，但是很有可能这个引用会在下次调用的时候就被回收了。因此我们创建了一个强引用<code>s2</code>，然后再验证这个强引用是否为null，如果不是就直接返回。</p>

<p>再次，我们注意到<code>intern()</code>方法被标记为synchronized。因为这个标准化器经常被用在多线程环境，比如http服务器，并且WeakHashMap并不是线程安全的。这种同步方式实际上是很简单的，因此<code>intern()</code>方法很有可能会成为一个竞争点。在现实情况下你可以使用<code>Collections.synchronizedMap()</code>来包装这个map，你需要明白两个并发的调用虽然字符串是一样的，但是如果不考虑到线程安全的问题话，就有可能返回不同的值。像我们这样做了同步化处理后，在同一时间里只会有一个字符串会进入到map中，并且我们的目标仅仅是去除重复的字符串，因此这个是可以接受的。</p>

<p>最后一点需要强调的是，<code>WeakHashMap</code>的文档可能会给人造成误解。前面，我们说到了它在内部并不是线程安全的，但是文档上却说“WeakHashMap可能会有其他的线程会悄悄的将里面的值给删掉”。实际上也是这样的，但是只是没有其他的线程来做这个事情，其实是map自己在它被访问的时候做了清理操作。如果要跟踪哪些项目不在有效了，可以使用引用队列来进行跟踪。</p>

<h2>引用队列</h2>

<p>我们可以通过检查被引用对象的值是不是null来确定这个被饮用对象是否已经被回收了，但是这需要你不断的检查这个引用对象。但是如果你有很多这样的引用对象，那么你就需要花费大量的时间来进行遍历和检查。另外一种方法是使用引用队列：如果你将一个引用对象和一个引用队列关联起来，那么当这个被引用对象回收的时候，这个引用对象就会被加入到这个引用队列中。</p>

<p>你需要在创建这个引用对象的时候就讲这个引用对象和引用队列关联起来。然后你就可以堆这个队列执行poll操作来检查这个被引用对象是否被清理掉，并且采取一些其他的行动。根据你的实际需求，你可以创建一个后台线程来周期性的检查这个队列，或者是以阻塞的方式等待。</p>

<p>引用队列被经常使用在幻象引用对象上，但是其他的引用对象都可以使用。下面的代码演示了一个软引用的情况：它创建了大量的缓存对象，并且通过软引用来访问，并且在每次创建的时候都检查一下那些对象已经被清理了。如果你运行这段代码，你就会看到大量的创建消息，并且夹杂着一些零星的清理消息（每次垃圾回收被触发的时候都会清理掉很多引用对象）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">argv</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">List</span><span class="o">&lt;</span><span class="n">SoftReference</span><span class="o">&lt;</span><span class="kt">byte</span><span class="o">[]&gt;&gt;</span> <span class="n">refs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">SoftReference</span><span class="o">&lt;</span><span class="kt">byte</span><span class="o">[]&gt;&gt;();</span>
</span><span class='line'>    <span class="n">ReferenceQueue</span><span class="o">&lt;</span><span class="kt">byte</span><span class="o">[]&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReferenceQueue</span><span class="o">&lt;</span><span class="kt">byte</span><span class="o">[]&gt;();</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="mi">10000</span> <span class="o">;</span> <span class="n">ii</span><span class="o">++)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">SoftReference</span><span class="o">&lt;</span><span class="kt">byte</span><span class="o">[]&gt;</span> <span class="n">ref</span>
</span><span class='line'>            <span class="o">=</span> <span class="k">new</span> <span class="n">SoftReference</span><span class="o">&lt;</span><span class="kt">byte</span><span class="o">[]&gt;(</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">10000</span><span class="o">],</span> <span class="n">queue</span><span class="o">);</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ii</span> <span class="o">+</span> <span class="s">&quot;: created &quot;</span> <span class="o">+</span> <span class="n">ref</span><span class="o">);</span>
</span><span class='line'>        <span class="n">refs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">ref</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">Reference</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="kt">byte</span><span class="o">[]&gt;</span> <span class="n">r2</span><span class="o">;</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">((</span><span class="n">r2</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>        <span class="o">{</span>
</span><span class='line'>            <span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;cleared &quot;</span> <span class="o">+</span> <span class="n">r2</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于这个代码有几点需要注意。首先，虽然我们创建的是SoftReference对象，但是我们从ReferenceQueue里返回的是Reference对象。就是要你知道，一旦这个引用对象进入到引用队里里，那么就不再关心这个引用对象到底是什么类型的了。实际上，它的被引用对象已经被清理掉了。</p>

<p>另外，我们需要使用强引用来保存这个引用对象。引用对象知道引用队列，但是引用队列并不知道引用对象，直到这个引用对象进入到这个队列中。如果我们不保持一个强引用来保持住一个引用对象，那么这个引用对象自己也会被回收。我们在这个例子中使用的是List，但是在实际开发中，Set或许是一个更好的选择。</p>

<h2>幻象引用</h2>

<p>幻象引用与软引用和弱引用最大的区别是，我们并不是要通过幻象引用来使用它所保持的对象。它仅仅被用来告诉你，它所维护的被引用对象什么时候被清理了。虽然这看上去很令人沮丧，但是实际上我们可以利用它来做资源的清理操作，并且比finalizer更加灵活。</p>

<h3>使用Finalizer的问题</h3>

<p>回到前面提到的对象生命周期，我提到了Finalizer是有一些潜在的问题的。问题的根源在于，当这个对象被标记为可被回收的时候Finalizer方法就被调用了，而不是等到真正的内存被回收之后。通过使用一些巧妙的代码，你甚至可以利用Finalizer产生OOM，就算在程序中已经没有任何强引用指向这个对象。</p>

<p>首先，Finalizer方法可能并不一定会被调用。如果你的程序没有用尽内存，那么垃圾搜集器就不会对任何对象标记为可回收的，因此这些对象的Finalizer方法就不会被调用。如果存在一些Finalizer方法需要对JNI的资源做清理，如果你的Java端的对象很小，那么你就会在他们被回收之前很容易的用完所有的C堆空间。解决这种问题的唯一方法就是手动来清理你的对象。</p>

<p>Finalizer方法的另外一个问题是你可以在该方法中创建一个强引用来指向这个对象本身，这就让这个对象又复活了，但是最关键的问题是，Finalizer在被调用过一次之后就不会再被调用了。虽然这个问题看起来很恐怖，但是没什么人会在Finalizer方法中让这个对象又复活过来。就算他们这样做了，这种行为也不会对整个程序造成什么影响，因为一旦这个强引用消失了，这个对象最后还是会被回收掉。</p>

<p>Finalizer方法最大得问题是，它被调用的时间和真正内存被回收的时间是不连续的。JVM保证在发生OOM之前会触发full gc，如果有些会被回收的对象拥有Finalizer方法，那么对于垃圾回收器来说的影响是很小的。但是实际上JVM可能只有一个线程来负责对象的销毁，你将会看到会产生什么问题。</p>

<p>下面的程序演示了这种问题：每一个对象都有一个Finalizer方法，并且在该方法中都会睡眠半秒钟。看上去没有多长的时间，但是如果你有上千个这样的对象情况就不一样了。所有的对象在被创建出来之后就会离开作用域，当然你会很快用完整个内存。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SlowFinalizer</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">argv</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span>
</span><span class='line'>        <span class="o">{</span>
</span><span class='line'>            <span class="n">Object</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SlowFinalizer</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// some member variables to take up space -- approx 200 bytes</span>
</span><span class='line'>    <span class="kt">double</span> <span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">,</span><span class="n">d</span><span class="o">,</span><span class="n">e</span><span class="o">,</span><span class="n">f</span><span class="o">,</span><span class="n">g</span><span class="o">,</span><span class="n">h</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">,</span><span class="n">k</span><span class="o">,</span><span class="n">l</span><span class="o">,</span><span class="n">m</span><span class="o">,</span><span class="n">n</span><span class="o">,</span><span class="n">o</span><span class="o">,</span><span class="n">p</span><span class="o">,</span><span class="n">q</span><span class="o">,</span><span class="n">r</span><span class="o">,</span><span class="n">s</span><span class="o">,</span><span class="n">t</span><span class="o">,</span><span class="n">u</span><span class="o">,</span><span class="n">v</span><span class="o">,</span><span class="n">w</span><span class="o">,</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">,</span><span class="n">z</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// and the finalizer, which does nothing by take time</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">finalize</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Throwable</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span> <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500L</span><span class="o">);</span> <span class="o">}</span>
</span><span class='line'>        <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">ignored</span><span class="o">)</span> <span class="o">{}</span>
</span><span class='line'>        <span class="kd">super</span><span class="o">.</span><span class="na">finalize</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>了解幻象引用</h3>

<p>幻象引用可以让应用程序知道哪些对象已经不再被使用了，因此程序可以清理掉这个对象的非内存资源。不像Finalizer，清理工作是由应用程序本身控制的。如果应用程序是通过一个工厂方法来创建对象，那么这个方法就可以被定义成在创建一个对象之前先检查那些不再被使用的对象的资源是否被清理干净了。不用担心清理需要花费多长的时间，因为它只影响到调用工厂发放的线程，而不会对其他线程造成影响。</p>

<p>幻象引用与软引用和弱引用最大的区别在于，你的应用程序不会去试图通过该应用对象来访问真正的对象。实际上，如果你调用<code>get()</code>方法，始终会返回null，就算这个被引用对象还存在其他强引用也是一样的。你可以在幻象引用中保持另外一个强引用指向这个对象所需要使用和清理的资源：</p>

<p><img src="http://shenzhang.github.io/images/2014/05/phantom_refobj_relations.gif"></p>

<p>虽然这看起来很奇怪，但是主要是让你明白幻象引用的目的就是让你知道这个对象什么时候被真正回收了。你的程序要能够访问到这些被引用对象所用到的资源以便对他们做清理操作，因此你的被引用对象不能是唯一方位这些资源的途径。应用程序需要依靠引用队列来知道这些对象什么时候被回收了。</p>

<h3>使用幻象引用来实现一个连接池</h3>

<p>在我们的程序中，数据库连接是一个很珍贵的资源。它需要花时间去创建，并且数据库服务器对同时打开的连接数也是有限制的。因此，程序员需要很小心的管理这些连接，有时候会为了一个查询创建一个连接，但是却忘记在finally块中关掉它。虽然Connector对象可以自己实现Finalizer方法来释放真正的连接，但是这依然非常依赖于垃圾回收器，并且也不能精确控制在同一时间同时打开的连接数。</p>

<p>使用幻象引用，我们可以控制同时打开的连接数，并且可以阻塞线程直到有可用的连接为止。</p>

<p>连接池的第一部分是<code>PoolConnection</code>对象。这个对象会交给应用程序来使用，同时也是幻象引用的引用对象。它实现了JDBC的<code>Connection</code>接口，并且将所有的操作都委托给由<code>DriverManager</code>产生的真正的connection对象上。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PooledConnection</span>
</span><span class='line'><span class="kd">implements</span> <span class="n">Connection</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">ConnectionPool</span> <span class="n">_pool</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Connection</span> <span class="n">_cxt</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为<code>PoolConnection</code>对象实现了<code>Connection</code>接口，它就需要实现所有Connection接口声明的方法。当我们调用它时，这些方法需要委托给内嵌的真正的连接对象。我使用了一个内部方法<code>getConnection()</code>而不是直接访问<code>_cxt</code>字段主要由两个原因：首先，我可以在方法被调用的时候做一些合法性的检查；另外，我还可以在测试用例中重写该方法。</p>

<p>现在我们来看下<code>ConnectionPool</code>，它是一个工厂类，并且提供了创建被缓存的连接的工厂方法<code>getConnection()</code>。该方法有可能会被阻塞：如果在连接池中没有可用的连接，那么该线程就会被阻塞，直到有可用的连接为止。（由引用对象被加入到引用队列来进行通知）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">synchronized</span> <span class="n">Connection</span> <span class="nf">getConnection</span><span class="o">()</span>
</span><span class='line'><span class="kd">throws</span> <span class="n">SQLException</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">_pool</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>            <span class="k">return</span> <span class="nf">wrapConnection</span><span class="o">(</span><span class="n">_pool</span><span class="o">.</span><span class="na">remove</span><span class="o">());</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>        <span class="o">{</span>
</span><span class='line'>            <span class="k">try</span>
</span><span class='line'>            <span class="o">{</span>
</span><span class='line'>                <span class="n">Reference</span><span class="o">&lt;?&gt;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">_refQueue</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">ref</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>                    <span class="n">releaseConnection</span><span class="o">(</span><span class="n">ref</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">ignored</span><span class="o">)</span>
</span><span class='line'>            <span class="o">{</span>
</span><span class='line'>                <span class="c1">// this could be used to shut down pool</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从该方法中可以看出，我们有一个队列来存放真正的连接，并且还有一个引用队列用来跟踪我们的PoolConnection什么时候被回收。让我们看下内部的数据结构：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Connection</span><span class="o">&gt;</span> <span class="n">_pool</span>
</span><span class='line'>    <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">Connection</span><span class="o">&gt;();</span>
</span><span class='line'>
</span><span class='line'><span class="kd">private</span> <span class="n">ReferenceQueue</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">_refQueue</span>
</span><span class='line'>    <span class="o">=</span> <span class="k">new</span> <span class="n">ReferenceQueue</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;();</span>
</span><span class='line'>
</span><span class='line'><span class="kd">private</span> <span class="n">IdentityHashMap</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">,</span><span class="n">Connection</span><span class="o">&gt;</span> <span class="n">_ref2Cxt</span>
</span><span class='line'>    <span class="o">=</span> <span class="k">new</span> <span class="n">IdentityHashMap</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">,</span><span class="n">Connection</span><span class="o">&gt;();</span>
</span><span class='line'>
</span><span class='line'><span class="kd">private</span> <span class="n">IdentityHashMap</span><span class="o">&lt;</span><span class="n">Connection</span><span class="o">,</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">_cxt2Ref</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">new</span> <span class="n">IdentityHashMap</span><span class="o">&lt;</span><span class="n">Connection</span><span class="o">,</span><span class="n">Object</span><span class="o">&gt;();</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个连接池实际上维护了两份查找表，其中一个是从引用对象到真正的连接对象；另外一个是从真正的连接对象到引用对象。每个映射表都使用了<code>IdentityHashMap</code>类，因为我们仅仅只是关心真正的对象是否相等，而不关心它是否重写了equals方法。</p>

<p>假设有连接池中有一些连接，<code>wrapConnection()</code>方法负责跟踪这些连接，它创建了一个<code>PooledConnection</code>对象，并且返回给调用者，然后让一个幻想引用指向这个对象。最后它把这些对象加入到查找表中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">synchronized</span> <span class="n">Connection</span> <span class="nf">wrapConnection</span><span class="o">(</span><span class="n">Connection</span> <span class="n">cxt</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">Connection</span> <span class="n">wrapped</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PooledConnection</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">cxt</span><span class="o">);</span>
</span><span class='line'>    <span class="n">PhantomReference</span><span class="o">&lt;</span><span class="n">Connection</span><span class="o">&gt;</span> <span class="n">ref</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PhantomReference</span><span class="o">&lt;</span><span class="n">Connection</span><span class="o">&gt;(</span><span class="n">wrapped</span><span class="o">,</span> <span class="n">_refQueue</span><span class="o">);</span>
</span><span class='line'>    <span class="n">_cxt2Ref</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">cxt</span><span class="o">,</span> <span class="n">ref</span><span class="o">);</span>
</span><span class='line'>    <span class="n">_ref2Cxt</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ref</span><span class="o">,</span> <span class="n">cxt</span><span class="o">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">wrapped</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>和它相对应的是<code>releaseConnection()</code>方法，它会在两种情况下被使用。首先是在连接池内部，当对应的幻象引用被加入到引用队列后被调用。它使用这个幻象引用来查找对应的真实数据库连接。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">releaseConnection</span><span class="o">(</span><span class="n">Reference</span><span class="o">&lt;?&gt;</span> <span class="n">ref</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">Connection</span> <span class="n">cxt</span> <span class="o">=</span> <span class="n">_ref2Cxt</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">ref</span><span class="o">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">cxt</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>        <span class="n">releaseConnection</span><span class="o">(</span><span class="n">cxt</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外一种情况就是由<code>PooledConnection</code>调用，特别是当应用程序需要显示关闭这个连接的时候。它会清除掉跟踪对象，并且将真实的数据库连接放回到池中。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">releaseConnection</span><span class="o">(</span><span class="n">Connection</span> <span class="n">cxt</span><span class="o">)</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">Object</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">_cxt2Ref</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">cxt</span><span class="o">);</span>
</span><span class='line'>    <span class="n">_ref2Cxt</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">ref</span><span class="o">);</span>
</span><span class='line'>    <span class="n">_pool</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">cxt</span><span class="o">);</span>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Released connection &quot;</span> <span class="o">+</span> <span class="n">cxt</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后我们来看看PooledConnection里的close方法，它不仅仅会将真正的数据库连接放回到池中，还会确保该Connectionbu会再被使用。该方法仅仅会被应用程序代码调用，用来显示关闭这个连接。如果连接池决定要关闭这个连接，那么这个<code>PooledConnection</code>将不能再被使用了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">SQLException</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">_cxt</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="n">_pool</span><span class="o">.</span><span class="na">releaseConnection</span><span class="o">(</span><span class="n">_cxt</span><span class="o">);</span>
</span><span class='line'>        <span class="n">_cxt</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>幻象引用的烦恼</h3>

<p>在前面我提到了Finalizer方法不保证会被调用，实际上幻象引用也存在同样的问题。如果垃圾回收器没有运行，那么它就不会回收掉那些不可达的对象，因此这些幻象引用也就不会被加入到引用队列中。考虑一下前面提到的数据库连接池的实现会发生什么事情？</p>

<p>实际上会很快消耗完连接池里的所有连接，并且将后续的请求全部阻塞住。如果你的程序不能做一些事情让它触发垃圾回收，那么很快所有的线程都会被阻塞住，并且会一直等待着那些永远不会回到连接池的的连接。</p>

<p>但是就算这样，幻象引用也比Finalizer方法要好一些，毕竟它可以让应用程序自己来控制清理操作。当然，如果你要使用Finalizer方法，你可以显示的调用<code>System.gc()</code>方法来试图触发垃圾回收器，但是这是不能得到保证的：按照文档所说到的，JVM会花费一些开销来搜集未使用的对象。</p>

<p>相比之下，连接池可以遍历那些不再使用的连接，并且强制它们关闭，而不是依赖Finalizer方法。</p>

<h2>有时候你仅仅需要更多的内存</h2>

<p>对于管理你的内存，虽然引用对象是一个很有用的工具，但是有时候它们是不够的活着说是过度使用的。比如说，你要创建一个一个大对象的图，并且数据来自于数据库。虽然你可以使用软引用来作为一个断路器使用，并且使用弱引用来作为标准化器，但是最终你任然需要足够的内存来运行程序。如果你没有足够的内存来完成这些任务，那么你的程序再健壮也是没有任何意义的。</p>

<p>如果你遇到了OOM，那么你首先需要确定是什么导致的。然后你可以试图简单的通过<code>-Xmx</code>参数来增加你的堆内存。从我个人而讲，我觉得JVM需要让你现实来指定内存的大小是一件很奇怪的事情：除了JVM之外，完全都可以依赖虚拟内存管理来把所有的事情搞定。JVM却很不一样，并且默认情况下它不会设置一个足够大的默认的堆空间：在SUN的HotspotJVM中是64M。</p>

<p>在开发过程中，你需要指定一个足够大的堆空间，1G或者更多，如果你有住够多得物理内存，并且应该留意实际使用了多少堆空间。大多数应用程序在模拟了一定的负载后都会达到一个稳定的水平，它可以用来指导你如何设置的你应用程序参数。如果你的内存使用量一直在增加，那么很有可能你一直保存着不再使用的对象，也就是说内存泄露了。这个时候引用对象就很有用了，但是更可以说明你的程序存在一些BUG需要被修复。</p>

<p>你应该足够的了解你的应用程序，这个是一个底线。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入解析OutOfMemoryError[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2014/04/24/understanding-out-of-memory-error/"/>
    <updated>2014-04-24T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2014/04/24/understanding-out-of-memory-error</id>
    <content type="html"><![CDATA[<p><a href="http://www.kdgregory.com/index.php?page=java.outOfMemory">原文链接</a></p>

<p>在Java中，所有对象都存储在堆中。他们通过<code>new</code>关键字来进行分配，JVM会检查是否所有线程都无法在访问他们了，并且会将他们进行回收。在大多数时候程序员都不会有一丝一毫的察觉，这些工作都被静悄悄的执行。但是，有时候在发布前的最后一天，程序挂了。</p>

<pre><code>Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
</code></pre>

<p><code>OutOfMemoryError</code>是一个让人很郁闷的异常。它通常说明你干了写错误的事情：没必要的长时间保存一些没必要的数据，或者同一时间处理了过多的数据。有些时候，这些问题并不一定受你的控制，比如说一些第三方的库对一些字符串做了缓存，或者一些应用服务器在部署的时候并没有进行清理。并且，对于堆中已经存在的对象，我们往往拿他们没办法。</p>

<p>这篇文章分析了导致<code>OutOfMemoryError</code>的不同原因，以及你该怎样应对这种原因的方法。以下分析仅限于Sun Hotspot虚拟机，但是大多数结论都适用于其他任何的JVM实现。它们大多数基于网上的文章以及我自己的经验。我没有直接做JVM开发的工作，因此结论并不代表JVM的作者。但是我确实曾经遇到过并解决了很多内存相关的问题。</p>

<!-- more -->


<h2>垃圾回收介绍</h2>

<p>我在<a href="http://www.kdgregory.com/index.php?page=java.refobj#ObjectLifeCycle">这篇文章</a>中已经详细介绍了垃圾回收的过程。简单的说，标记-清除算法(mark-sweep collect)以<code>garbage collection roots</code>作为扫描的起点，并对整个对象图进行扫描，对所有可达的对象进行标记。那些没有被标记的对象会被清除并回收。</p>

<p>Java的垃圾回收算法过程意味着如果出现了OOM，那么说明你在不停的往对象图中添加对象并且没有移除它们。这通常是因为你在往一个集合类中添加了很多对象，比如Map，并且这个集合对象是static的。或者，这个集合类被保存在了<code>ThreadLocal</code>对象中，而这个对应的Thread却又长时间的运行，一直不退出。</p>

<p>这与C和C++的内存泄露完全不一样。在这些语言中，如果一些方法调用了malloc()或者new，并且在方法退出的时候没有调用相应的free()或者delete，那么内存就会产生泄露。这些是真正意义上得泄露，你在这个进程范围内不可能再恢复这些内存，除非使用一些特定的工具来保证每一个内存分配方法都有其对应的内存释放操作相对应。</p>

<p>在java中，“泄露”这个词往往被误用了。因为从JVM的角度来说，所有的内存都是被良好管理的。问题仅仅是作为程序员的你不知道这些内存是被哪些对象占用了。但是幸运的是，你还是有办法去找到和定位它们。</p>

<p>在深入探讨之前，你还有最后一件关于垃圾收集的知识需要了解：JVM会尽最大的能力去释放内存，直到发生OOM。这就意味着OOM不能通过简单的调用<code>System.gc()</code>来解决，你需要找到这些“泄露”点，并自己处理它们。</p>

<h2>设置堆大小</h2>

<p>学院派的人非常喜欢说<a href="http://java.sun.com/docs/books/jls/third_edition/html/j3TOC.html">Java语言规范</a>并没有对垃圾收集器进行任何约定，你甚至可以实现一个从来不释放内存的JVM(实际是毫无意义的)。<a href="http://java.sun.com/docs/books/jvms/second_edition/html/Overview.doc.html#15730">Java虚拟机规范</a>中提到堆是由垃圾回收器进行管理，但是却没有说明任何相关细节。仅仅说了我刚才提到的那句话：垃圾回收会发生在OOM之前。</p>

<p>实际上，Sun Hotspot虚拟机使用了一个固定大小的堆空间，并且允许在最小空间和最大空间之间进行自动增长。<strong>如果你没有指定最小值和最大值，那么对于'client'模式将会默认使用2Mb最为最小值，64Mb最为最大值；对于'server'模式，JVM会根据当前可用内存来决定默认值</strong>。2000年后，默认的最大堆大小改为了64M，并且在当时已经认为足够大了(2000年前的时候默认值是16M)，但是对于现在的应用程序来说很容易就用完了。</p>

<p>这意味着你需要显示的通过JVM参数来指定堆的最小值和最大值：</p>

<pre><code>java -Xms256m -Xmx512m MyClass
</code></pre>

<p>这里有很多经验上得法则来设定最大值和最小值。显然，堆的最大值应该设定为足以容下整个应用程序所需要的全部对象。但是，将它设定为“刚刚好足够大”也不是一个很好的注意，因为这样会增加垃圾回收器的负载。因此，对于一个长时间运行的应用程序，你一般需要保持有20%-25%的空闲堆空间。（你得应用程序可能需要不同的参数设置，GC调优是一门艺术，并且不在该文章讨论范围内）</p>

<p>让你奇怪的时，设置合适的堆的最小值往往比设置合适的最大值更加重要。垃圾回收器会尽可能的保证<strong>当前的</strong>的堆大小，而不是不停的增长堆空间。这会导致应用程序不停的创建和回收大量的对象，而不是获取新的堆空间，相对于初始(最小)堆空间。Java堆会尽量保持这样的堆大小，并且会不停的运行GC以保持这样的容量。因此，我认为在生产环境中，我们最好是将堆的最小值和最大值设置成一样的。</p>

<p>你可能会困惑于为什么Java堆会有一个最大值上限：操作系统并不会分配真正的物理内存，除非他们真的被使用了。并且，实际使用的虚拟内存空间实际上会比Java堆空间要大。如果你运行在一个32位系统上，一个过大的堆空间可能会限制classpath中能够使用的jar的数量，或者你可以创建的线程数。</p>

<p>另外一个原因是，一个受限的最大堆空间可以让你及时发现潜在的内存泄露问题。在开发环境中，对应用程序的压力往往是不够的，如果你在开发环境中就拥有一个非常大得堆空间，那么你很有可能永远不会发现可能的内存泄露问题，直到进入产品环境。</p>

<h2>在运行时跟踪垃圾回收</h2>

<p>所有的JVM实现都提供了<code>-verbos:gc</code>选项，它可以让垃圾回收器在工作的时候打印出日志信息：</p>

<pre><code>java -verbose:gc com.kdgregory.example.memory.SimpleAllocator
[GC 1201K-&gt;1127K(1984K), 0.0020460 secs]
[Full GC 1127K-&gt;103K(1984K), 0.0196060 secs]
[GC 1127K-&gt;1127K(1984K), 0.0006680 secs]
[Full GC 1127K-&gt;103K(1984K), 0.0180800 secs]
[GC 1127K-&gt;1127K(1984K), 0.0001970 secs]
...
</code></pre>

<p>Sun的JVM提供了额外的两个参数来以内存带分类输出，并且会显示垃圾收集的开始时间：</p>

<pre><code>java -XX:+PrintGCDetails -XX:+PrintGCTimeStamps com.kdgregory.example.memory.SimpleAllocator
0.095: [GC 0.095: [DefNew: 177K-&gt;64K(576K), 0.0020030 secs]0.097: [Tenured: 1063K-&gt;103K(1408K), 0.0178500 secs] 1201K-&gt;103K(1984K), 0.0201140 secs]
0.117: [GC 0.118: [DefNew: 0K-&gt;0K(576K), 0.0007670 secs]0.119: [Tenured: 1127K-&gt;103K(1408K), 0.0392040 secs] 1127K-&gt;103K(1984K), 0.0405130 secs]
0.164: [GC 0.164: [DefNew: 0K-&gt;0K(576K), 0.0001990 secs]0.164: [Tenured: 1127K-&gt;103K(1408K), 0.0173230 secs] 1127K-&gt;103K(1984K), 0.0177670 secs]
0.183: [GC 0.184: [DefNew: 0K-&gt;0K(576K), 0.0003400 secs]0.184: [Tenured: 1127K-&gt;103K(1408K), 0.0332370 secs] 1127K-&gt;103K(1984K), 0.0342840 secs]
...
</code></pre>

<p>从上面的输出我们可以看出什么？首先，前面的几次垃圾回收发生的非常频繁。每行的第一个字段显示了JVM启动后的时间，我们可以看到在一秒钟内有上百次的GC。并且，还加入了每次GC执行时间的开始时间（在每行的最后一个字段），可以看出垃圾搜集器是在不停的运行的。</p>

<p>但是在实时系统中，这会造成很大的问题，因为垃圾搜集器的执行会夺走很多的CPU周期。就像我之前提到的，这很可能是由于初始堆大小设置的太小了，并且GC日志显示了：每次堆的大小达到了1.1Mb，它就开始执行GC。如果你得系统也有类似的现象，请在改变自己的应用程序之前使用<code>-Xms</code>来增大初始堆大小。</p>

<p>对于GC日志还有一些很有趣的地方：除了第一次垃圾回收，没有任何对象是存放在了新生代(&ldquo;DefNew&rdquo;)。这说明了这个应用程序分配了包含大量数据的数组，在显示世界里这是很少出现的。如果在一个实时系统中出现这样的状况，我想到的第一个问题是“这些数组拿来干什么用？”。</p>

<h2>堆转储(Heap Dumps)</h2>

<p>一个堆转储可以显示你在应用程序说使用的所有对象。从基础上讲，它仅仅反映了对象实例的数量和类文件所占用的字节数。当然你也可以将分配这些内存的代码一起dump出来，并且对比历史存货对象。但是，如果你要dump的数据信息越多，JVM的负载就会越大，因此这些技术仅仅应该使用在开发环境中。</p>

<h3>怎样获得一个内存转储</h3>

<p>命令行参数<code>-XX:+HeapDumpOnOutOfMemoryError</code>是最简单的方式生成内存转储。就像它的名字所说的，它会在内存被用完的时候(发生OOM)进行转储，这在产品环境非常好用。但是由于这个是一种事后转储（已经发生了OOM），它只能提供一种历史性的数据。它会产生一个二进制文件，你可以使用<a href="http://java.sun.com/javase/6/docs/technotes/tools/share/jhat.html">jhat</a>来操作该文件（这个工具在JDK1.6中已经提供，但是可以读取JDK1.5产生的文件）。</p>

<p>你可以使用<a href="http://java.sun.com/javase/6/docs/technotes/tools/share/jmap.html">jmap</a>(JDK1.5之后就自带了)来为一个运行中得java程序产生堆转储，可以产生一个在<em>jhat</em>中使用的dump文件，或者是一个存文本的统计文件。统计图可以在进行分析时优先使用，特别是你要在一段时间内多次转储堆并进行分析和对比历史数据。</p>

<p>从转储内容和JVM的负荷的扩展性上考虑的话，可以使用profilers。Profiles使用JVM的调试接口(debuging interface)来搜集对象的内存分配信息，包括具体的代码行和方法调用栈。这个是非常有用的：不仅仅可以知道你分配了一个数GB的数组，你还可以知道你在一个特定的地方分配了950MB的对象，并且直接忽略其他的对象。当然，这些结果肯定会对JVM有开销，包括CPU的开销和内存的开销(保存一些原始数据)。你不应该在产品环境中使用profiles。</p>

<h3>堆转储分析：live objects</h3>

<p>Java中的内存泄露是这样定义的：你在内存中分配了一些对象，但是并没有清除掉所有对它们的引用，也就是说垃圾搜集器不能回收它们。使用堆转储直方图可以很容易的查找这些泄露对象：它不仅仅可以告诉你在内存中分配了哪些对象，并且显示了这些对象在内存中所占用的大小。但是这种直方图最大的问题是：对于同一个类的所有对象都被聚合(group)在一起了，所以你还需要进一步做一些检测来确定这些内存在哪里被分配了。</p>

<p>使用<em>jmap</em>并且加上<code>-histo</code>参数可以为你产生一个直方图，它显示了从程序运行到现在所有对象的数量和内存消耗，并且包含了已经被回收的对象和内存。如果使用<code>-histo:live</code>参数会显示当前还在堆中得对象数量及其内存消耗，不论这些对象是否要被垃圾搜集器进行回收。</p>

<p>也就是说，如果你要得到一个当前时间下得准确信息，你需要在使用<em>jmap</em>之前强制执行一次垃圾回收。如果你的应用程序是运行在本地，最简单的方式是直接使用<a href="http://download.oracle.com/javase/6/docs/technotes/tools/share/jconsole.html">jconsole</a>：在'Memory'标签下，有一个'Perform GC'的按钮。如果应用程序是运行在服务端环境，并且JMX beans被暴露了，<code>MemoryMXBean</code>有一个<code>gc()</code>操作。如果上述的两种方案都没办法满足你得要求，你就只有等待JVM自己触发一次垃圾搜集过程了。如果你有一个很严重的内存泄露问题，那么第一次major collection很可能预示着不久后就会OOM。</p>

<p>有两种方法使用<code>jmap</code>产生的直方图。其中最有效的方法，适用于长时间运行的程序，可以使用带<code>live</code>的命令行参数，并且在一段时间内多次使用该命令，检查哪些对象的数量在不断增长。但是，根据当前程序的负载，该过程可能会花费1个小时或者更多的时间。</p>

<p>另外一个更加快速的方式是直接比较当前存活的对象数量和总的对象数量。如果有些对象占据了总对象数量的大部分，那么这些对象很有可能发生内存泄露。这里有一个例子，这个应用程序已经连续几周为100多个用户提供了服务，结果列举了前12个数量最多的对象。据我所知，这个程序没有内存泄露的问题，但是像其他应用程序一样做了常规性的内存转储分析操作。</p>

<pre><code>~, 510&gt; jmap -histo 7626 | more

 num     #instances         #bytes  class name
----------------------------------------------
   1:        339186       63440816  [C
   2:         84847       18748496  [I
   3:         69678       15370640  [Ljava.util.HashMap$Entry;
   4:        381901       15276040  java.lang.String
   5:         30508       13137904  [B
   6:        182713       10231928  java.lang.ThreadLocal$ThreadLocalMap$Entry
   7:         63450        8789976  &lt;constMethodKlass&gt;
   8:        181133        8694384  java.lang.ref.WeakReference
   9:         43675        7651848  [Ljava.lang.Object;
  10:         63450        7621520  &lt;methodKlass&gt;
  11:          6729        7040104  &lt;constantPoolKlass&gt;
  12:        134146        6439008  java.util.HashMap$Entry

~, 511&gt; jmap -histo:live 7626 | more

 num     #instances         #bytes  class name
----------------------------------------------
   1:        200381       35692400  [C
   2:         22804       12168040  [I
   3:         15673       10506504  [Ljava.util.HashMap$Entry;
   4:         17959        9848496  [B
   5:         63208        8766744  &lt;constMethodKlass&gt;
   6:        199878        7995120  java.lang.String
   7:         63208        7592480  &lt;methodKlass&gt;
   8:          6608        6920072  &lt;constantPoolKlass&gt;
   9:         93830        5254480  java.lang.ThreadLocal$ThreadLocalMap$Entry
  10:        107128        5142144  java.lang.ref.WeakReference
  11:         93462        5135952  &lt;symbolKlass&gt;
  12:          6608        4880592  &lt;instanceKlassKlass&gt;
</code></pre>

<p>当我们要尝试寻找内存泄露问题，可以从消耗内存最多的对象着手。这听上去很明显，但是往往它们并不是内存泄露的根源。但是，它们任然是应该最先下手的地方，在这个例子中，最占用内存的是一些<code>char[]</code>的数组对象（总大小是60MB，基本上没有任何问题）。但是很奇怪的是当前存货(live)的对象竟然占了历史分配的总对象大小的三分之二。</p>

<p>一般来说，一个应用程序会分配对象，并且在不久之后就会释放它们。如果保存一些对象的应用过长的时间，就很有可能会导致内存泄露。但是虽然是这么说的，实际上还是要具体情况具体分析，主要还是要看这个程序到底在做什么事情。字符数组对象(char[])往往和字符串对象(String)同时存在，大部分的应用程序都会在整个运行过程中一直保持着一些字符串对象的引用。例如，基于JSP的web应用程序在JSP页面中定义了很多HTML字符串表达式。这种特殊的应用程序提供HTML服务，但是它们需要保持字符串引用的需求却不一定那么清晰：它们提供的是目录服务，并不是静态文本。如果我遇到了OOM，我就会尝试找到这些字符串在哪里被分配，为什么没有被释放。</p>

<p>另一个需要关注的是字节数组([B)。在JDK中有很多类都会使用它们（比如BufferedInputStream），但是却很少在应用程序代码中直接看到它们。通常它们会被用作缓存(buffer)，但是缓存的生命周期不会很长。在这个例子中我们看到，有一半的字节数组任然保持存活。这个是令人担忧的，并且它凸显了直方图的一个问题：所有的对象都按照它的类型被分组聚合了。对于应用程序对象(非JDK类型或者原始类型，在应用程序代码中定义的类)，这不是一个问题，因为它们会在程序的一个部分被集中分配。但是字节数组有可能会在任何地方被定义，并且在大多数应用程序中都被隐藏在一些库中。我们是否应当搜索调用了<code>new byte[]</code>或者<code>new ByteArrayOutputStream()</code>的代码？</p>

<h3>堆转储分析：相关的原因和影响分析</h3>

<p>为了找到导致内存泄露的最终原因，仅仅考虑按照类别(class)的分组的内存占用字节数是不够的。你还需要将应用程序分配的对象和内存泄露的对象关联起来考虑。一个方法是更加深入查看对象的数量，以便将具有关联性的对象找出来。下面是一个具有严重内存问题的程序的转储信息：</p>

<pre><code> num     #instances         #bytes  class name
----------------------------------------------
   1:       1362278      140032936  [Ljava.lang.Object;
   2:         12624      135469922  [B
  ...
   5:        352166       45077248  com.example.ItemDetails
  ...
   9:       1360742       21771872  java.util.ArrayList
  ...
  41:          6254         200128  java.net.DatagramPacket
</code></pre>

<p>如果你仅仅去看信息的前几行，你可能会去定位<code>Object[]</code>或者<code>byte[]</code>，这些都是徒劳的。真正的问题出在ItemDetails和DatagramPacket上：前者分配了大量的ArrayList，进而又分配了大量的Object[]；后者使用了大量的byte[]来保存从网络上接收到的数据。</p>

<p>第一个问题，分配了大量的数组，实际上不是内存泄露。ArrayList的默认构造函数会分配容量是10的数组，但是程序本身一般只使用1个或者2个槽位，这对于64位JVM来说会浪费62个字节的内存空间。一个更好的涉及方案是仅仅在有需要的时候才使用List，这样对每个实例来说可以节约额外的48个字节。但是，对于这种问题也可以很轻易的通过加内存来解决，因为现在的内存非常便宜。</p>

<p>但是对于datagram的泄露就比较麻烦（如同定位这个问题一样困难）：这表明接收到的数据没有被尽快的处理掉。</p>

<p>为了跟踪问题的原因和影响，你需要知道你的程序是怎样在使用这些对象。不多的程序才会直接使用Object[]：如果确实要使用数组，程序员一般都会使用带类型的数组。但是，ArrayList会在内部使用。但是仅仅知道ArrayList的内存分配是不够的，你还需要顺着调用链往上走，看看谁分配了这些ArrayList。</p>

<p>其中一个方法是对比相关的对象数量。在上面的例子中，byte[]和DatagramPackage的关系是很明显的：其中一个基本上是另外一个的两倍。但是ArrayList和ItemDetails的关系就不那么明显了。（实际上一个ItemDetails中会包含多个ArrayList）</p>

<p>这往往是个陷阱，让你去关注那么数量最多的一些对象。我们有数百万的ArrayList对象，并且它们分布在不同的class中，也有可能集中在一小部分class中。尽管如此，数百万的对象引用是很容易被定位的。就算有10来个class可能会包含ArrayList，那么每个class的实体对象也会有十万个，这个是很容易被定位的。</p>

<p>从直方图中跟踪这种引用关系链是需要花费大量精力的，幸运的是，<em>jmap</em>不仅仅可以提供直方图，它还可以提供可以浏览的堆转储信息。</p>

<h3>堆转储分析：跟踪引用链</h3>

<p>浏览堆转储引用链具有两个步骤：首先需要使用<code>-dump</code>参数来使用<em>jmap</em>，然后需要用<em>jhat</em>来使用转储文件。如果你确定要使用这种方法，请一定要保证有足够多的内存：一个转储文件通常都有数百M，<em>jhat</em>需要好几个G的内存来处理这些转储文件。</p>

<pre><code>tmp, 517&gt; jmap -dump:live,file=heapdump.06180803 7626
Dumping heap to /home/kgregory/tmp/heapdump.06180803 ...
Heap dump file created

tmp, 518&gt; jhat -J-Xmx8192m heapdump.06180803
Reading from heapdump.06180803...
Dump file created Sat Jun 18 08:04:22 EDT 2011
Snapshot read, resolving...
Resolving 335643 objects...
Chasing references, expect 67 dots...................................................................
Eliminating duplicate references...................................................................
Snapshot resolved.
Started HTTP server on port 7000
Server is ready.
</code></pre>

<p>提供给你的默认URL显示了所有加载进系统的class，但是我觉得并不是很有用。相反，我直接使用<code>http://localhost:7000/histo/</code>，这个地址是一个直方图的视角来进行显示，并且是按照对象数量和占用的内存空间进行排序了的。</p>

<p><img src="http://shenzhang.github.io/images/2014/04/jhat-histogram-large.gif"></p>

<p>这个直方图里的每个class的名称都是一个链接，点击这个链接可以查看关于这个类型的详细信息。你可以在其中看到这个类的继承关系，它的成员变量，以及很多指向这个类的实体变量信息的链接。我不认为这个详细信息页面非常有用，而且实体变量的链接列表很占用很多的浏览器内存。</p>

<p>为了能够跟踪你的内存问题，最有用的页面是'Reference by Type'。这个页面含有两个表格：入引用和出引用，他们都被引用的数量进行排序了。点击一个类的名字可以看到这个引用的信息。</p>

<p>你可以在类的详细信息(class details)页面中找到这个页面的链接。</p>

<h3>堆转储分析：内存分配情况</h3>

<p>在大多数情况下，知道了是哪些对象消耗了大量的内存往往就可以知道它们为什么会发生内存泄露。你可以使用<em>jhat</em>来找到所有引用了他们的对象，并且你还可以看到使用了这些对象的引用的代码。但是在有些时候，这样还是不够的。</p>

<p>比如说你有关于字符串对象的内存泄露问题，那么就很有可能会花费你好几天的时间去检查所有和字符串相关的代码。要解决这种问题，你就需要能够显示内存在哪里被分配的堆转储。但是需要注意的是，这种类型的堆转储会对你的应用程序产生更多的负载，因为负责转储的代理需要记录每一个<code>new</code>操作符。</p>

<p>有许多交互式的程序可以做到这种级别的数据记录，但是我找到了一个更简单的方法，那就是使用内置的<em>hprof</em>代理来启动JVM。</p>

<pre><code>java -Xrunhprof:heap=sites,depth=2 com.kdgregory.example.memory.Gobbler
</code></pre>

<p><em>hprof</em>有许多选项：不仅仅可以用多种方式输出内存使用情况，它还可以跟踪CPU的使用情况。当它运行的时候，我指定了一个事后的内存转储，它记录了哪些对象被分配，以及分配的位置。它的输出被记录在了<code>java.hprof.txt</code>文件中，其中关于堆转储的部分如下：</p>

<pre><code>SITES BEGIN (ordered by live bytes) Tue Sep 29 10:43:34 2009
          percent          live          alloc'ed  stack class
 rank   self  accum     bytes objs     bytes  objs trace name
    1 99.77% 99.77%  66497808 2059  66497808  2059 300157 byte[]
    2  0.01% 99.78%      9192    1     27512    13 300158 java.lang.Object[]
    3  0.01% 99.80%      8520    1      8520     1 300085 byte[]
SITES END
</code></pre>

<p>这个应用程序没有分配多种不同类型的对象，也没有将它们分配到很多不同的地方。一般的转储有成百上千行的信息，显示了每一种类型的对象被分配到了哪里。幸运的是，大多数问题都会出现在开头的几行。在这个例子中，最突出的是64M的存活着的字节数组，并且每一个平均32K。</p>

<p>大多数程序中都不会一直持有这么大得数据，这就表明这个程序没有很好的抽取和处理这些数据。你会发现这常常发生在读取一些大的字符串，并且保存了substring之后的字符串：很少有人知道<code>String.substring()</code>后会共享原始字符串对象的字节数组。如果你按照一行一行地读取了一个文件，但是却使用了每行的前五个字符，实际上你任然保存的是整个文件在内存中。</p>

<p>转储文件也显示出这些数组被分配的数量和现在存活的数量完全相等。这是一种典型的泄露，并且我们可以通过搜索'trace'号来找到真正的代码：</p>

<pre><code>TRACE 300157:
    com.kdgregory.example.memory.Gobbler.main(Gobbler.java:22)
</code></pre>

<p>好了，这下就足够简单了：当我在代码中找到指定的代码行时，我发现这些数组被存放在了ArrayList中，并且它也一直没有出作用域。但是有时候，堆栈的跟踪并没有直接关联到你写的代码上：</p>

<pre><code>TRACE 300085:
    java.util.zip.InflaterInputStream.&lt;init&gt;(InflaterInputStream.java:71)
    java.util.zip.ZipFile$2.&lt;init&gt;(ZipFile.java:348)
</code></pre>

<p>在这个例子中，你需要增加堆栈跟踪的深度，并且重新运行你的程序。但是这里有一个需要平衡的地方：当你获取到了更多的堆栈信息，你也同时增加了profile的负载。默认地，如果你没有指定<code>depth</code>参数，那么默认值就会是4。我发现当堆栈深度为2的时候就可以发现和定位我程序中得大部分问题了，当然我也使用过深度为12的参数来运行程序。</p>

<p>另外一个增大堆栈深度的好处是，最后的报告结果会更加细粒度：你可能会发现你泄露的对象来自两到三个地方，并且它们都使用了相同的方法。</p>

<h3>堆转储分析：位置、地点</h3>

<p>当很多对象在分配的不久后就被丢弃时，分代垃圾搜集器就会开始运行。你可以使用同样的原则来找发现内存泄露：使用调试器，在对象被分配的地方打上断点，并且运行这段代码。在大多数时候，当它们被分配不久后就会加入到长时间存活(long-live)的集合中。</p>

<h2>永久代</h2>

<p>除了JVM中的新生代和老年代外，JVM还管理着一片叫‘永久代’的区域，它存储了class信息和字符串表达式等对象。通常，你不会观察到永久代中的垃圾回收；大多数的垃圾回收发生在应用程序堆中。但是不像它的名字，在永久代中的对象不会是永久不变的。举个例子，被应用程序classloader加载的class，当不再被classloader引用时就会被清理掉。当应用程序服务被频繁的热部署时就可能会发生：</p>

<pre><code>Exception in thread "main" java.lang.OutOfMemoryError: PermGen space
</code></pre>

<p>这一这个信息：这个不管应用程序堆的事。当应用程序堆中还有很多空间时，也有可能用完永久代的空间。通常，这发生在重新部署EAR和WAR文件时，并且永久代还不够大到可以同时容纳新的class信息和老的class信息（老的class会一直被保存着直到所有的请求在使用完它们）。当在运行处于开发状态的应用时更容易发生。</p>

<p>解决永久代错误的第一个方法就是增大永久大的空间，你可以使用<code>-XX:MaxPermSize</code>命令行参数。默认是64M，但是web应用程序或者IDE一般都需要256M。</p>

<pre><code>java -XX:MaxPermSize=256m
</code></pre>

<p>但是在通常情况下并不是这么简单的。永久代的内存泄露一般都和在应用堆中的内存泄露原因一样：在一些地方的对象引用了并不该再引用的对象。以我的经验，很有可能有些对象直接引用了一些Class对象，或者在<code>java.lang.reflect</code>包下面的对象，而不是某些类的实例对象。正式因为web引用的classloader的组织方式，通常罪魁祸首都出现在服务的配置当中。</p>

<p>例如，你使用了Tomcat，并且有一个目录里面有很多共享的jars：shared/lib。如果你在一个容器里同时运行好几个web应用，将一些公用的jar放在这个目录是很有道理的，因为这样的话这些class仅仅被加载一次，可以减少内存的使用量。但是，如果其中的一些库具有对象缓存的话，会发生什么事情呢？</p>

<p>答案是这些被缓存了的对象的类永远不会被卸载，直到缓存释放了这些对象。解决方案就是将这些库移动到WAR或者EAR中。但是在某些时候情况也不会像这么简单：<a href="http://java.sun.com/javase/7/docs/api/java/beans/Introspector.html">JDKs bean introspector</a>会缓存住由root classloader加载的<code>BeanInfo</code>对象。并且任何使用了反射的库也会缓存这些对象，这样就导致你不能直到真正的问题所在。</p>

<p>解决永久代的问题通常都是比较痛苦的。一般可以先考虑加上<code>-XX:+TraceClassLoading</code>和<code>-XX:+TraceClassUnloading</code>命令行选项以便找出那些被加载了但是没有被卸载的类。如果你加上了<code>-XX:+TraceClassResolution</code>命令行选项，你还可以看到哪些类访问了其他类，但是没有被正常卸载。</p>

<p>这里有针对这三个选项的一个实例。第一行显示了<code>MyClassLoader</code>类从classpath中被加载了。因为它又从<code>URLClassLoader</code>继承，因此我们看到了接下来的'RESOLVE'消息，紧跟着又是一条'RESOLVE'消息，说明<code>Class</code>类也被解析了。</p>

<pre><code>[Loaded com.kdgregory.example.memory.PermgenExhaustion$MyClassLoader from file:/home/kgregory/Workspace/Website/programming/examples/bin/]
RESOLVE com.kdgregory.example.memory.PermgenExhaustion$MyClassLoader java.net.URLClassLoader
RESOLVE java.net.URLClassLoader java.lang.Class URLClassLoader.java:188
</code></pre>

<p>所有的信息都在这里的，但是通常情况下将一些共享库移动到WAR/EAR中往往可以很快速的解决问题。</p>

<h2>当堆内存还有空间时发生的OutOfMemoryError</h2>

<p>就像你刚才看到的关于永久代的消息，也许应用程序堆中还有空闲空间，但是也任然可能会发生OOM。这里有几个例子：</p>

<h3>连续的内存分配</h3>

<p>当我描述分代的堆空间时，我一般会说对象会首先被分配在新生代，然后最终会被移动到老年代。但这不是绝对正确的：如果你的对象足够大，那么它就会直接被分配在老年代。一般用户自己定义的对象是不会（也不应该）达到这个临界值，但是数组却却有可能：在JDK1.5中，当数组的对象超过0.5M的时候就会被直接分配到老年代。</p>

<p>在32位机器上，0.5M换算成<code>Object[]</code>数组的话就可以包含131,072个元素。这已经是很大的了，但是在企业级的应用中这是很有可能的。特别是当使用了<code>HashMap</code>时，它经常需要重新resize自己(里面的数组数据结构)。一些应用程序可能还需要更大的数组。</p>

<p>当没有连续的堆空间来存放这些数组对象时（就算在垃圾回收并且对内存进行了紧凑之后），问题就产生了。这很少见，但是如果当前的程序已经很接近堆空间的上限时，这就变得很有可能了。增大堆空间上限是最好的解决方案，但是你也许可以试试事先分配好你的容器的大小。（后面的小对象可以不需要连续的内存空间）</p>

<h3>线程</h3>

<p>JavaDoc中对OOM的描述是，当垃圾搜集器不能在释放更多的内存空间时，JVM会抛出OOM。这里只对了一半：当JVM的内部代码收到来自操作系统的<code>ENOMEM</code>错误时，JVM也会抛出OOM。Unix程序员一般都知道，这里有很多地方可以收到<code>ENOMEN</code>错误，创建线程的过程是其中之一：</p>

<pre><code>Exception in thread "main" java.lang.OutOfMemoryError: unable to create new native thread
</code></pre>

<p>在我的32位Linux系统中，使用JDK1.5，我可以最多开启5,550个线程直到抛出异常。但是实际上在堆中任然有很多空闲空间，这是怎么回事呢？</p>

<p>在这个场景的背后，线程实际上是被操作系统所管理，而不是JVM，创建线程失败的可能原因有很多很多。在我的例子中，每一个线程都需要占用大概0.5M的虚拟内存作为它的栈空间，在5000个线程被创建之后，大约就有2G的内存空间被占用。有些操作系统就强制制定了一个进程所能创建的线程数的上限。</p>

<p>最后，针对这个问题没有一个解决方案，除非更换你的应用程序。大多数程序是不需要创建这么多得线程的，它们会将大部分的时间都浪费在等待操作系统调度上。但是有些服务程序需要创建数千个线程去处理请求，但是它们中得大多数都是在等待数据。针对这种场景，NIO和selector就是一个不错的解决方案。</p>

<h3>Direct ByteBuffers</h3>

<p>从JDK1.4之后Java允许程序程序使用<a href="http://www.kdgregory.com/index.php?page=java.byteBuffer">bytebuffers</a>来访问堆外的内存空间（受限）。虽然<code>ByteBuffer</code>对象本身很小，但是堆外的内存可不一定很小：</p>

<pre><code>Exception in thread "main" java.lang.OutOfMemoryError: Direct buffer memory
</code></pre>

<p>这里有多个原因会导致bytebuffer分配失败。通常情况下，你可能超过了最多的虚拟内存上限（仅限于32位系统），或者超过了所有物理内存和交换区内存的上限。除非你是在以很简单的方式处理超过你的机器内存上限的数据，否则你在使用direct buffer产生OOM的原因和你使用堆的原因基本上是一样的：你保持着一些你不该引用的数据。前面介绍的堆分析技术可以帮助你找到泄露点。</p>

<h3>申请的内存超过物理内存</h3>

<p>就像我前面提到的，你在启动一个JVM时，你需要指定堆的最小值和最大值。这就意味着，JVM会在运行期动态改变它对虚拟内存的需求。在一个内存受限的机器上，你可以同时运行多个JVM，甚至它们所有指定的最大值之和大于了物理内存和交换区的大小。当然，这就有可能会导致OOM，就算你的程序中存活的对象大小小于你指定的堆空间也是一样的。</p>

<p>这种情况和跑多个C++程序使用完所有的物理内存的原因是一样的。使用JVM可能会让你产生一种假象，以为不会出现这种问题。唯一的解决方案是购买更多的内存，或者不要同时跑那么多程序。没有办法让JVM可以'快速失败'；但是在Linux上你可以申请比总内存更多的内存。</p>

<h2>堆外内存的使用</h2>

<p>最后一个需要注意的问题是：Java中得堆仅仅是所占用内存的一部分。JVM还会为它所创建的线程、内部代码、工作空间、共享库、direct buffer、内存映射文件分配内存。在32位的JVM中，这所有的内存都需要被映射到2G的虚拟内存空间中，这是非常有限的（特别是对于服务端或者后端应用程序）。在64位的JVM中，虚拟内存基本没存在什么限制，但是实际的物理内存（含交换区）可能会很稀缺。</p>

<p>一般来说，虚拟内存不会造成什么大问题；操作系统和JVM可以很好的管理它们。通常情况下，你需要查看虚拟内存的映射情况主要是为了direct buffer所使用的大块的内存或者是内存映射文件。但是你还是很有必要知道什么是虚拟内存的映射。</p>

<p>要查看在Linux上的虚拟内存映射情况可以使用<a href="http://linux.die.net/man/1/pmap">pmap</a>；在Windows中可以使用<a href="http://technet.microsoft.com/en-us/sysinternals/dd535533">VMMap</a>。下面是使用pmap来dump的一个Tomcat应用。实际的dump文件有好几百行，所展示的部分仅仅是比较有意思的部分：</p>

<pre><code>08048000     60K r-x--  /usr/local/java/jdk-1.5/bin/java
08057000      8K rwx--  /usr/local/java/jdk-1.5/bin/java
081e5000   6268K rwx--    [ anon ]
889b0000    896K rwx--    [ anon ]
88a90000   4096K rwx--    [ anon ]
88e90000  10056K rwx--    [ anon ]
89862000  50488K rwx--    [ anon ]
8c9b0000   9216K rwx--    [ anon ]
8d2b0000  56320K rwx--    [ anon ]
...
afd70000    504K rwx--    [ anon ]
afdee000     12K -----    [ anon ]
afdf1000    504K rwx--    [ anon ]
afe6f000     12K -----    [ anon ]
afe72000    504K rwx--    [ anon ]
...
b0cba000     24K r-xs-  /usr/local/java/netbeans-5.5/enterprise3/apache-tomcat-5.5.17/server/lib/catalina-ant-jmx.jar
b0cc0000     64K r-xs-  /usr/local/java/netbeans-5.5/enterprise3/apache-tomcat-5.5.17/server/lib/catalina-storeconfig.jar
b0cd0000    632K r-xs-  /usr/local/java/netbeans-5.5/enterprise3/apache-tomcat-5.5.17/server/lib/catalina.jar
b0d6e000    164K r-xs-  /usr/local/java/netbeans-5.5/enterprise3/apache-tomcat-5.5.17/server/lib/tomcat-ajp.jar
b0d97000     88K r-xs-  /usr/local/java/netbeans-5.5/enterprise3/apache-tomcat-5.5.17/server/lib/tomcat-http.jar
...
b6ee3000   3520K r-x--  /usr/local/java/jdk-1.5/jre/lib/i386/client/libjvm.so
b7253000    120K rwx--  /usr/local/java/jdk-1.5/jre/lib/i386/client/libjvm.so
b7271000   4192K rwx--    [ anon ]
b7689000   1356K r-x--  /lib/tls/i686/cmov/libc-2.11.1.so
...
</code></pre>

<p>dump文件展示给你了关于虚拟内存映射的4个部分：虚拟内存地址，大小，权限，源（从文件加载的部分）。最有意思的部分是它的权限部分，它表示了该内存段是否是只读的(r-)还是读写的(rw)。</p>

<p>我会从读写段开始分析。所有的段都具有名字"[ anon ]&ldquo;，它在Linux中说明了该段不是由文件加载而来。这里还有很多被命名的读写段，它们和共享库关联。我相信这些库都具有每个进程的地址表。</p>

<p>因为所有的读写段都具有相同的名字，一次要找出出问题的部分需要花费一点时间。对于Java堆，有4个相关的大块内存被分配（新生代有2个，老年代1个，永久代1个），他们的大小由GC和堆配置来决定。</p>

<h2>其他问题</h2>

<p>这部分的内容并不是对所有地方都适用。大部分都是我解决问题的过程中总结的实际经验。</p>

<h3>不要被虚拟内存的统计信息所误导</h3>

<p>有很多抱怨说Java是'memory hog'，经常被<em>top</em>命令的'VIRT'部分和Windows任务管理器的'Mem Usage'列所证实。需要澄清的是，有太多的东西都不会算进这个统计信息中，有些还是与其他程序共享的（比如说C的库）。实际上也有很多‘空’的区域在虚拟内存映射空间中：如果你适用<code>-Xms1000m</code>来启动JVM，就算你还没有开始分配对象，虚拟内存的大小也会超过1000m。</p>

<p>一个更好的测量方法是使用驻留集的大小：你的应用程序真正使用的物理内存的页数，不包含共享页。这就是<em>top</em>命令中得'RES'列。但是，驻留集并不是对你的程序所需使用的总内存最好的测量方法。操作系统只有在你的程序真正需要使用它们的时候才会将它们放进进程的内存空间中，一般来说是在你的系统处于高负载的情况下才会出现，这会花费一段较长的时间。</p>

<p>最后：始终使用工具来提供所需的详细信息来分析Java中的内存问题。并且只有当出现OOM的时候才考虑下结论。</p>

<h3>OOM的罪魁祸首经常离它的抛出点很近</h3>

<p>内存泄露一般在内存被分配之后不久发生。一个相似的结论是，OOM的根源一般都离它的抛出点很近，可以使用堆跟踪技术来首先进行分析。其基本原理是，内存泄露一般和产生大量的内存相关联。这说明了，导致泄露的代码具有更高的失败风险率，不管是因为其内存分配代码被调用的过于频繁，还是因为每次调用都分配的过大的内存。因此，可以优先考虑使用栈跟踪来定位问题。</p>

<h3>和缓存相关的部分最值得怀疑</h3>

<p>我在这篇文章中提到缓存了很多次：在我数十年的Java工作经历中发现，和内存泄露相关的类进场都是和缓存相关的。实际上缓存是很难编写的。</p>

<p>使用缓存有很多很多很好的理由，并且使用自己写的缓存也有很多好的理由。如果你确定要使用缓存，请先回答下面的问题：</p>

<ul>
<li>哪些对象会被放进缓存？如果你所要缓存的对象都是同一种类型（或者具有继承关系），那么相比一个可以容纳各种类型的缓存来说更好跟踪问题。</li>
<li>有多少对象会被同时放进缓存？如果你像让<code>ProductCache</code>缓存1000个对象，但是在内存分析结果中发现了10000个对象，那么这之间的关系就比较好定位。如果你指定了这个缓存最多的容量上限，那么你就可以很容易的计算出这个缓存最多需要多少内存。</li>
<li>过期和清除策略是什么？每一个缓存为了控制存在于其中的对象的存货周期，都需要一个明确的驱逐策略。如果你没有指定一个明确的驱逐策略，那么有些对象就很有可能比它真正需要的存活周期要长，占用更多的内存，加重垃圾搜集器的负载（记住：在标记阶段需要的时间和存活对象的数量成正比）。</li>
<li>是否会在缓存之外同时持有这些存活对象的引用？缓存最好的应用场景是，调用频繁，并且调用时间很短，并且所缓存的对象的获取代价很大。如果你需要创建一个对象，并且在整个应用程序的生命周期中都需要引用这个对象，那么就没有必要将这个对象放入缓存（也许使用池技术可以显示总得对象数量）。</li>
</ul>


<h3>注意对象的生命周期</h3>

<p>一般来说对象可以被划分为两类：一类是伴随着整个程序的生命周期而存活；另外一来是仅仅存活并服务于一个单一的请求。搞清楚这个非常重要，你仅仅需要关心你认为是长时间存活的对象。</p>

<p>一种方法是在程序启动的时候全部初始化好所有长时间(long-lived)存活的对象，不管他们是否要立刻被用到。另外一个方法是使用依赖注入框架，比如<code>Spring</code>。这不仅仅可以很方便的bean配置文件中找到所有long-lived的对象（不需要扫描整个classpath），还可以很清楚的知道这些对象在哪里被使用。</p>

<h3>查找在方法参数中被错误使用的对象</h3>

<p>在大部分场景中，在一个方法中被分配的对象都会在方法退出的时候被清理掉（除开被返回的对象）。当你都是用局部变量来保存这些对象的时候，这个规则很容易被遵守。但是，有时候任然会使用实体变量来保存这些对象，特别是在方法中会调用大量其他方法的时候，主要是为了避免过多和麻烦的方法参数传递。</p>

<p>这样做不是一定会产生泄漏。后续的方法调用会重新对这些变量进行赋值，这样就可以让之前被创建的对象被回收。但是这样导致不必要的内存开销，并且让调试更加困难。但是从设计的角度出发，当我看到这样的代码时，我就会考虑将这个方法单独提出来形成一个独立的类。</p>

<h3>J2EE：不要滥用session</h3>

<p>session对象是用来在多个请求之间保存和共享用户相关的数据，主要是因为HTTP协议是无状态的。有时候它便成了一个用于缓存的临时性解决方案。</p>

<p>这也不是说一定就会产生泄漏，因为web容器会在一段时间后让用户的session失效。但是它却显著提高了整个程序的内存占用量，这是很糟糕的。并且它非常难调试：就像我之前提到的，很难看出对象被哪些其他的对象所持有。</p>

<h3>小心过量的垃圾搜集</h3>

<p>虽然OOM很糟糕，但是如果不停的执行垃圾搜集将会更加糟糕：它会抢走本该属于你的程序的CPU时间。</p>

<h3>有些时候你仅仅是需要更多的内存</h3>

<p>就像我在开头的地方所说的，JVM是唯一的一个让你指定你的数据最大值（内存上限）的现代编程环境。因此，会有很多时候让你以为发生了内存泄露，但是实际上你仅仅需要增加你的堆大小。解决内存问题的第一步最好还是先增加你的内存上限。如果你真的遇到了内存泄露问题，那么无论你增加了多少内存，你最后都还是会得到OOM的错误。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jcl-over-slf4j]]></title>
    <link href="http://shenzhang.github.io/blog/2014/04/13/commons-logging-over-slf4j/"/>
    <updated>2014-04-13T02:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2014/04/13/commons-logging-over-slf4j</id>
    <content type="html"><![CDATA[<p>`jcl-over-slf4j'如同名字一样就是用来将java commons logging桥接到slf4j上。现在J2EE的一个项目通常会引用五花八门的类库，不同的类库又会使用不同的日志门面系统，有的是slf4j，有的是jcl。现在随着slf4j的越来越流行，那么将系统里的所有日志系统都统一到slf4j上也成了一个很平常的需求，jcl-over-slf4j也成了项目依赖中的常客。这周和同事也讨论了该桥接类的应用，尤其是spring本身也是直接以来jcl的，其官方文档也给出了如何替换成slf4j的说明。今天看了下代码，这里做下记录。</p>

<h2>jcl的绑定流程</h2>

<p>使用jcl的标准方法如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Log</span> <span class="n">log</span> <span class="o">=</span> <span class="n">LogFactory</span><span class="o">.</span><span class="na">getLog</span><span class="o">(</span><span class="n">XXX</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>LogFactory中给出了如下绑定流程：</p>

<ol>
<li>检查系统属性<code>org.apache.commons.logging.LogFactory</code>，其中记录了具体的LogFactory的实现类。</li>
<li>通过java的service loading机制加载<code>META-INF/services/org.apache.commons.logging.LogFactory</code>配置文件，其中记录了LogFactory的实现类。</li>
<li>检查classpath中的<code>commons-logging.properties</code>配置文件，里面记录了具体的LogFactory的实现类。</li>
<li>使用jcl提供的默认实现类：<code>org.apache.commons.logging.impl.LogFactoryImpl</code>来创建Log。</li>
</ol>


<p>如果不幸进入了最后一个步骤使用<code>org.apache.commons.logging.impl.LogFactoryImpl</code>来创建Log，那么它又会使用一套发现机制类查找合适的日志实现：</p>

<ol>
<li>检查<code>org.apache.commons.logging.impl.LogFactoryImpl</code>是否已经配置了<code>org.apache.commons.logging.Log</code>属性，如果配置了该属性，则使用该属性指定的Log。</li>
<li>使用系统属性<code>org.apache.commons.logging.Log</code>中所定义的Log实现</li>
<li>检查是否存在log4j的实现类:<code>org.apache.commons.logging.impl.Log4JLogger</code>。</li>
<li>检查<code>org.apache.commons.logging.impl.Jdk14Logger</code></li>
<li>检查<code>org.apache.commons.logging.impl.Jdk13LumberjackLogger</code></li>
<li>检查<code>org.apache.commons.logging.impl.SimpleLog</code></li>
</ol>


<h2>jcl-over-slf4j桥接模式</h2>

<p>其实仔细看看jcl-over-slf4j的实现，可以发现它提供了两种桥接方法。</p>

<h3>1.引入jcl-over-slf4j并排除jcl</h3>

<p>该方法也是spring官方推荐的方法，它的实现也是很巧妙也很直接。因为我们使用jcl都是通过<code>LogFactory.getLog(XXX.class)</code>来获得Log，jcl-over-slf4j中也就提供了名称完全一样的LogFactory，只不过它的getLog方法直接通过Slf4jLogFactory返回Slf4jLog。如果在dependencies中排除掉jcl，那么所有引用jcl的地方就偷天换日的直接使用了slf4j的日志。</p>

<h3>2.引入jcl-over-slf4j并且没有排除jcl</h3>

<p>有些人可能发现如果没有在dependencies中排除掉jcl也是可以工作的，这又是为什么呢？实际上jcl-over-slf4j提供了方法1外，还参考了jcl的绑定机制，并且参考上面提到的步骤2提供了<code>META-INF/services/org.apache.commons.logging.LogFactory</code>，其中说明了jcl需要绑定的LogFactory实现是<code>org.apache.commons.logging.impl.SLF4JLogFactory</code>。这不，也委托回slf4j上让其提供Log。</p>

<p>实际上，上面的两种方法都是可以的。但是推荐使用第一种方法，因为更加直接和清晰。第二种方法会让classpath中存在两个完全同名的jcl的LogFactory，但是不论jvm加载哪一个都是OK的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[哪个更快：Java堆还是本地内存[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2014/04/13/which-one-is-faster-java-heap-or-native-memory/"/>
    <updated>2014-04-13T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2014/04/13/which-one-is-faster-java-heap-or-native-memory</id>
    <content type="html"><![CDATA[<p><a href="http://mentablog.soliveirajr.com/2012/11/which-one-is-faster-java-heap-or-native-memory/">原文链接</a></p>

<p>使用Java的一个好处就是你可以不用亲自来管理内存的分配和释放。当你用<code>new</code>关键字来实例化一个对象时，它所需的内存会自动的在Java堆中分配。堆会被垃圾回收器进行管理，并且它会在对象超出作用域时进行内存回收。但是在JVM中有一个‘后门’可以让你访问不在堆中的本地内存(native memory)。在这篇文章中，我会给你演示一个对象是怎样以连续的字节码的方式在内存中进行存储，并且告诉你是应该怎样存储这些字节，是在Java堆中还是在本地内存中。最后我会就怎样从JVM中访问内存更快给一些结论：是用Java堆还是本地内存。</p>

<h1>使用<code>Unsafe</code>来分配和回收内存</h1>

<p><code>sun.misc.Unsafe</code>可以让你在Java中分配和回收本地内存，就像C语言中的<code>malloc</code>和<code>free</code>。通过它分配的内存不在Java堆中，并且不受垃圾回收器的管理，因此在它被使用完的时候你需要自己来负责释放和回收。下面是我写的一个使用<code>Unsafe</code>来管理本地内存的一个工具类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Direct</span> <span class="kd">implements</span> <span class="n">Memory</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Unsafe</span> <span class="n">unsafe</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="n">AVAILABLE</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">static</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">Field</span> <span class="n">field</span> <span class="o">=</span> <span class="n">Unsafe</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&quot;theUnsafe&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="n">field</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span><span class='line'>            <span class="n">unsafe</span> <span class="o">=</span> <span class="o">(</span><span class="n">Unsafe</span><span class="o">)</span><span class="n">field</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
</span><span class='line'>            <span class="n">AVAILABLE</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">// NOOP: throw exception later when allocating memory</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isAvailable</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">AVAILABLE</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Direct</span> <span class="n">INSTANCE</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Memory</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">INSTANCE</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Direct</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">INSTANCE</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="nf">Direct</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">alloc</span><span class="o">(</span><span class="kt">long</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">AVAILABLE</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">&quot;sun.misc.Unsafe is not accessible!&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">allocateMemory</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">free</span><span class="o">(</span><span class="kt">long</span> <span class="n">address</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">unsafe</span><span class="o">.</span><span class="na">freeMemory</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">long</span> <span class="nf">getLong</span><span class="o">(</span><span class="kt">long</span> <span class="n">address</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">putLong</span><span class="o">(</span><span class="kt">long</span> <span class="n">address</span><span class="o">,</span> <span class="kt">long</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">unsafe</span><span class="o">.</span><span class="na">putLong</span><span class="o">(</span><span class="n">address</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getInt</span><span class="o">(</span><span class="kt">long</span> <span class="n">address</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">putInt</span><span class="o">(</span><span class="kt">long</span> <span class="n">address</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">unsafe</span><span class="o">.</span><span class="na">putInt</span><span class="o">(</span><span class="n">address</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>在本地内存中分配一个对象</h2>

<p>让我们来将下面的Java对象放到本地内存中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SomeObject</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">long</span> <span class="n">someLong</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">someInt</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getSomeLong</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">someLong</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setSomeLong</span><span class="o">(</span><span class="kt">long</span> <span class="n">someLong</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">someLong</span> <span class="o">=</span> <span class="n">someLong</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getSomeInt</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">someInt</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setSomeInt</span><span class="o">(</span><span class="kt">int</span> <span class="n">someInt</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">someInt</span> <span class="o">=</span> <span class="n">someInt</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们所做的仅仅是把对象的属性放入到<code>Memory</code>中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SomeMemoryObject</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">someLong_OFFSET</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">someInt_OFFSET</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">SIZE</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">4</span><span class="o">;</span> <span class="c1">// one long + one int</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">long</span> <span class="n">address</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Memory</span> <span class="n">memory</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">SomeMemoryObject</span><span class="o">(</span><span class="n">Memory</span> <span class="n">memory</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">memory</span> <span class="o">=</span> <span class="n">memory</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">address</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="na">alloc</span><span class="o">(</span><span class="n">SIZE</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">finalize</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">memory</span><span class="o">.</span><span class="na">free</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">setSomeLong</span><span class="o">(</span><span class="kt">long</span> <span class="n">someLong</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">memory</span><span class="o">.</span><span class="na">putLong</span><span class="o">(</span><span class="n">address</span> <span class="o">+</span> <span class="n">someLong_OFFSET</span><span class="o">,</span> <span class="n">someLong</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">long</span> <span class="nf">getSomeLong</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">memory</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="n">address</span> <span class="o">+</span> <span class="n">someLong_OFFSET</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">setSomeInt</span><span class="o">(</span><span class="kt">int</span> <span class="n">someInt</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">memory</span><span class="o">.</span><span class="na">putInt</span><span class="o">(</span><span class="n">address</span> <span class="o">+</span> <span class="n">someInt_OFFSET</span><span class="o">,</span> <span class="n">someInt</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getSomeInt</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">memory</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="n">address</span> <span class="o">+</span> <span class="n">someInt_OFFSET</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在我们来看看对两个数组的读写性能：其中一个含有数百万的<code>SomeObject</code>对象，另外一个含有数百万的<code>SomeMemoryObject</code>对象。</p>

<pre><code>// with JIT:
Number of Objects:  1,000     1,000,000     10,000,000    60,000,000
Heap Avg Write:      107         2.30          2.51         2.58       
Native Avg Write:    305         6.65          5.94         5.26
Heap Avg Read:       61          0.31          0.28         0.28
Native Avg Read:     309         3.50          2.96         2.16


// without JIT: (-Xint)
Number of Objects:  1,000     1,000,000     10,000,000    60,000,000
Heap Avg Write:      104         107           105         102       
Native Avg Write:    292         293           300         297
Heap Avg Read:       59          63            60          58
Native Avg Read:     297         298           302         299
</code></pre>

<p><strong>结论：</strong>跨越JVM的屏障来读本地内存大约会比直接读Java堆中的内存慢10倍，而对于写操作会慢大约2倍。<em>但是需要注意的是，由于每一个SomeMemoryObject对象所管理的本地内存空间都是独立的，因此读写操作都不是连续的。</em>那么我们接下来就来对比下读写连续的内存空间的性能。</p>

<h2>访问一大块的连续内存空间</h2>

<p>这个测试分别在堆中和一大块连续本地内存中包含了相同的测试数据。然后我们来做多次的读写操作看看哪个更快。并且我们会做一些随机地址的访问来对比结果。</p>

<pre><code>// with JIT and sequential access:
Number of Objects:  1,000     1,000,000     1,000,000,000
Heap Avg Write:      12          0.34           0.35 
Native Avg Write:    102         0.71           0.69 
Heap Avg Read:       12          0.29           0.28 
Native Avg Read:     110         0.32           0.32

// without JIT and sequential access: (-Xint)
Number of Objects:  1,000     1,000,000      10,000,000
Heap Avg Write:      8           8              8
Native Avg Write:    91          92             94
Heap Avg Read:       10          10             10
Native Avg Read:     91          90             94

// with JIT and random access:
Number of Objects:  1,000     1,000,000     1,000,000,000
Heap Avg Write:      61          1.01           1.12
Native Avg Write:    151         0.89           0.90 
Heap Avg Read:       59          0.89           0.92 
Native Avg Read:     156         0.78           0.84

// without JIT and random access: (-Xint)
Number of Objects:  1,000     1,000,000      10,000,000
Heap Avg Write:      55          55              55
Native Avg Write:    141         142             140
Heap Avg Read:       55          55              55 
Native Avg Read:     138         140             138
</code></pre>

<p><strong>结论:</strong>在做连续访问的时候，Java堆内存通常都比本地内存要快。对于随机地址访问，堆内存仅仅比本地内存慢一点点，并且是针对大块连续数据的时候，而且没有慢很多。</p>

<h2>最后的结论</h2>

<p>在Java中使用本地内存有它的意义，比如当你要操作大块的数据时(>2G)并且不想使用垃圾回收器(GC)的时候。从延迟的角度来说，直接访问本地内存不会比访问Java堆快。这个结论其实是有道理的，因为跨越JVM屏障肯定是有开销的。这样的结论对使用本地还是堆的<code>ByteBuffer</code>同样适用。使用本地ByteBuffer的速度提升不在于访问这些内存，而是它可以直接与操作系统提供的本地IO进行操作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[maven杂谈(生命周期,插件绑定,effective-xx)]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/15/something-about-maven/"/>
    <updated>2013-09-15T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/15/something-about-maven</id>
    <content type="html"><![CDATA[<h2>1.生命周期</h2>

<h3>Clean</h3>

<pre><code>pre-clean
clean
post-clean
</code></pre>

<h3>Default</h3>

<pre><code>validate
initialize
generate-sources
process-sources
generate-resources
process-resources
compile
process-classes
generate-test-sources
process-test-sources
generate-test-resources
process-test-resources
test-compile
process-test-classes
test
prepare-package
package
pre-integration-test
integration-test
post-integration-test
verify
install
deploy
</code></pre>

<h3>Site</h3>

<pre><code>pre-site
site
post-site
site-deploy
</code></pre>

<h2>2.插件绑定</h2>

<p>maven在不同的生命周期中会按顺序进入不同的阶段，每个阶段又会执行与该阶段绑定的plugins。如何将plugins绑定到生命周期中呢，maven-compile-plugin又是怎么知道在每次的compile阶段执行的呢？</p>

<p>plugin绑定到生命周期中需要在pom.xml中的<build>=><plugins>中进行声明，有些是在pom.xml中，有些可能是在super pom中，有些甚至是maven默认的绑定，但是最终都会出现在effective pom中（mvn help:effective-pom查看)。</p>

<p>那么具体是在哪个阶段执行呢？看effective pom中对maven-compile-plugin的描述：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>  <span class="nt">&lt;plugin&gt;</span>
</span><span class='line'>    <span class="nt">&lt;artifactId&gt;</span>maven-compiler-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;version&gt;</span>2.3.2<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>    <span class="nt">&lt;executions&gt;</span>
</span><span class='line'>      <span class="nt">&lt;execution&gt;</span>
</span><span class='line'>        <span class="nt">&lt;id&gt;</span>default-testCompile<span class="nt">&lt;/id&gt;</span>
</span><span class='line'>        <span class="nt">&lt;phase&gt;</span>test-compile<span class="nt">&lt;/phase&gt;</span>
</span><span class='line'>        <span class="nt">&lt;goals&gt;</span>
</span><span class='line'>          <span class="nt">&lt;goal&gt;</span>testCompile<span class="nt">&lt;/goal&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/goals&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/execution&gt;</span>
</span><span class='line'>      <span class="nt">&lt;execution&gt;</span>
</span><span class='line'>        <span class="nt">&lt;id&gt;</span>default-compile<span class="nt">&lt;/id&gt;</span>
</span><span class='line'>        <span class="nt">&lt;phase&gt;</span>compile<span class="nt">&lt;/phase&gt;</span>
</span><span class='line'>        <span class="nt">&lt;goals&gt;</span>
</span><span class='line'>          <span class="nt">&lt;goal&gt;</span>compile<span class="nt">&lt;/goal&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/goals&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/execution&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/executions&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/plugin&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>主要是在phase节点和goals节点，上面的配置说明了maven-compile-plugin被分别绑定到了compile阶段和test-compile阶段，并且分别执行该插件的compile goal和testCompile goal。</p>

<p>另外有些plugin可能并没有在pom.xml中说明具体的执行阶段，那么就要看该插件中的/META-INF/maven/plugin.xml插件描述文件了，该描述文件说明了该plugin的前缀(goalPrefix)，所有的mojos或者说是goal，并且这些goal的名字以及默认的执行阶段，比如compile:testCompile节点就说明了&lt;phase&gt;test-compile&lt;/phase&gt;。因此如果没有在pom.xml中说明执行阶段的话，就按照该plugin的goal的自描述中的phase进行绑定。</p>

<h2>3.effective-xx</h2>

<p>maven有关于自己运行的配置文件settings.xml，该文件可以是$MAVEN_HOME/conf/settings.xml或者$USER/.m2/setttings.xml，并且后者会覆盖前者，可以通过mvn help:effective-settings查看相对于默认的settings.xml所改变的部分。</p>

<p>同样，前面提到的effective-pom也是由多个部分合并而来，首先是项目下的pom.xml，然后是maven的super pom($MAVEN_HOME/lib/maven-model-builder-x.x.x.jar#org/apache/maven/model/pom-x.x.x.xml)，还有一些是maven针对不同的生命周期默认绑定的插件信息($MAVEN_HOME/lib/maven-core-x.x.x.jar#/META-INF/plexus/components.xml)。最终的pom可以通过help:effective-pom查看)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[maven依赖的scope]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/13/scope-in-maven/"/>
    <updated>2013-09-13T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/13/scope-in-maven</id>
    <content type="html"><![CDATA[<p>maven中一些常用的scope及其介绍。</p>

<h3>compile:</h3>

<p>maven的默认依赖scope，并且会应用于所有的classpath，也就是说不论在compile, test compile, 还是直接用mvn来运行(runtime)都会起作用.</p>

<h3>runtime:</h3>

<p>在compile相关的阶段都不会起作用，仅仅是在运行(runtime)或者测试(test)的时候有效。</p>

<h3>provided:</h3>

<p>和compile类似，但是往往这些依赖不需要随应用一起发布，一般是由外部环境或者容器来提供，不需要自己准备，比如说servlet-api, jsp-api这些都可以由container提供。</p>

<h3>test:</h3>

<p>这个最好理解，仅仅是在测试的时候有用，compile和runtime都不需要</p>

<h3>system:</h3>

<p>有些依赖是仓库没有的，那么可以通过使用system范围来告诉maven在指定的本地路径上查找依赖。因此需要在dependency中指定systemPath元素，告诉maven依赖的具体位置。一般来说是不应该使用该范围的，很可能大家不能共享你的配置。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何针对缺少source包的jar添加source包]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/12/add-source-to-repository/"/>
    <updated>2013-09-12T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/12/add-source-to-repository</id>
    <content type="html"><![CDATA[<p>repository中的有些jar是没有对应的source的，比如在使用hadoop-core-1.0.4.jar包，但是由于缺少sources包，因此无法在依赖中查看源文件。</p>

<p>那么可以自己准备对应的源码包：hadoop-core-1.0.4-srouces.jar并安装到本地仓库中。</p>

<pre><code>mvn install:install-file -Dfile=e:\hadoop-core-1.0.4-sources.jar -DgroupId=org.apache.hadoop -DartifactId=hadoop-core -Dversion=1.0.4 -DgeneratePom=false -Dpackaging=java-source
</code></pre>

<p>注意<code>packaging=java-source</code>，不要使用<code>packaging=jar</code></p>

<p>从中我们可以推测maven打包和依赖查找的机制：</p>

<p>我们发布一个包，指定了groupId, artifacteId, version, packaging，那么maven会自动帮我们给要发布的文件重命名：</p>

<pre><code>packaging=jar =&gt; artifacteId-version.jar
packaging=java-srouce =&gt; artifacteId-version-sources.jar
packaging=java-doc =&gt; artifacteId-version-doc.jar
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[javascript测试框架jasmine]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/11/jasmine/"/>
    <updated>2013-09-11T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/11/jasmine</id>
    <content type="html"><![CDATA[<p><a href="http://pivotal.github.io/jasmine/">jasmine</a>是一个javascript的测试框架，不同于qunit等其他测试框架，它可以用于很多js环境，比如web，nodejs等。它上手简单，并且官方有很详细的实例和描述，这里将大部分实用的api和用法记录下来。</p>

<!-- more -->


<h2>一个DEMO</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">describe</span><span class="p">(</span><span class="s2">&quot;this is a test suite&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">foo</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// setup function run before every spec</span>
</span><span class='line'>  <span class="nx">beforeEach</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">foo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">foo</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="c1">// teardown function run before ever spec</span>
</span><span class='line'>  <span class="nx">afterEach</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">foo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">it</span><span class="p">(</span><span class="s2">&quot;this is a test spec 1&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">it</span><span class="p">(</span><span class="s2">&quot;this is a test spec 2&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">expect</span><span class="p">(</span><span class="kc">true</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<h2>jasmine提供的全局方法</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">describe</span><span class="p">(</span><span class="nx">testSuiteName</span><span class="p">,</span> <span class="nx">func</span><span class="p">)</span> <span class="c1">//定义一个test suite，其中可以包含it定义的spec，并且describe可以嵌套</span>
</span><span class='line'><span class="nx">xdescribe</span><span class="p">(</span><span class="nx">testSuiteName</span><span class="p">,</span> <span class="nx">func</span><span class="p">)</span> <span class="c1">//类似于JUnit的@Ignore，忽略这个test suite</span>
</span><span class='line'><span class="nx">it</span><span class="p">(</span><span class="nx">specName</span><span class="p">,</span> <span class="nx">func</span><span class="p">)</span> <span class="c1">//定义一个test unit(spec)</span>
</span><span class='line'><span class="nx">xit</span><span class="p">(</span><span class="nx">specName</span><span class="p">,</span> <span class="nx">func</span><span class="p">)</span> <span class="c1">//类似于@Ignore，忽略这个unit</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">actualValue</span><span class="p">)</span> <span class="c1">//assert</span>
</span><span class='line'><span class="nx">beforeEach</span><span class="p">(</span><span class="nx">func</span><span class="p">)</span> <span class="c1">//定义一个start function，在每个unit之前运行</span>
</span><span class='line'><span class="nx">afterEach</span><span class="p">(</span><span class="nx">func</span><span class="p">)</span> <span class="c1">//定义一个deardown function, 在每个unit之后运行</span>
</span><span class='line'><span class="nx">spyOn</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">funcName</span><span class="p">)</span> <span class="c1">//监视obj.funcName函数的调用情况</span>
</span><span class='line'>
</span><span class='line'><span class="nx">runs</span><span class="p">(</span><span class="nx">fun</span><span class="p">)</span>
</span><span class='line'><span class="nx">waitsFor</span><span class="p">(</span><span class="nx">fun</span><span class="p">,</span> <span class="nx">msg</span><span class="p">,</span> <span class="nx">timeout</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nx">jasmine</span><span class="p">.</span><span class="nx">createSpy</span><span class="p">(</span><span class="nx">spyName</span><span class="p">)</span> <span class="c1">//定义一个spy函数，该函数可以被任意调用，主要用于mock</span>
</span><span class='line'><span class="nx">jasmine</span><span class="p">.</span><span class="nx">createSpyObj</span><span class="p">(</span><span class="nx">objName</span><span class="p">,</span> <span class="nx">spyFuncNames</span><span class="p">)</span> <span class="c1">//定义一个spy对象，并且该对象具有spyFuncNames数组包含的方法。主要用于mock</span>
</span><span class='line'><span class="nx">jasmine</span><span class="p">.</span><span class="nx">any</span><span class="p">(</span><span class="nx">construct</span><span class="o">|</span><span class="nx">className</span><span class="p">)</span> <span class="c1">//配合expect使用，检测该对象是否是指定类型，如：expect(12).toEqual(jasmine.any(Number));</span>
</span><span class='line'><span class="nx">jasmine</span><span class="p">.</span><span class="nx">Clock</span><span class="p">.</span><span class="nx">useMock</span> <span class="c1">//启用模拟timer</span>
</span><span class='line'><span class="nx">jasmine</span><span class="p">.</span><span class="nx">Clock</span><span class="p">.</span><span class="nx">tick</span> <span class="c1">//手动触发一个timer事件</span>
</span></code></pre></td></tr></table></div></figure>


<h2>expectation api</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">//a === b</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">not</span><span class="p">.</span><span class="nx">toBe</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">//!(a===b)</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">//a是否和b相等，可以比较普通类型或者对象</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toMatch</span><span class="p">(</span><span class="nx">reg</span><span class="p">)</span> <span class="c1">//a是否符合reg的正则表达式</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeDefined</span><span class="p">()</span> <span class="c1">//o.a是否被定义</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeUnDefined</span><span class="p">()</span> <span class="c1">//o.a是否没有被定义</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeNull</span><span class="p">()</span> <span class="c1">//a === null ?</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeTruthy</span><span class="p">()</span> <span class="c1">//if (a) 是否成立</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeFalsy</span><span class="p">()</span> <span class="c1">//if (!a) 是否成立</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">array</span><span class="p">).</span><span class="nx">toContain</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">//数组array里是否有b</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeLessThan</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">//a &lt; b ?</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeGreaterThan</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">//a &gt; b?</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">func</span><span class="p">).</span><span class="nx">toThrow</span><span class="p">()</span> <span class="c1">//func被调用的时候是否抛出异常</span>
</span></code></pre></td></tr></table></div></figure>


<h2>spy</h2>

<p>jasmine可以对指定的函数进行调用监视，相关的函数有spyOn, jasmine.createSpy(), jasmine.createSpyObj()，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">hello</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello world&#39;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">spyOn</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么对obj.hello的调用都会被jasmine截获，但是实际上是不会真正调用obj.hello的，除非：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">sypOn</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">).</span><span class="nx">andCallThough</span><span class="p">()</span> <span class="c1">// 调用obj.hello()时，最终会真正调用console.log</span>
</span><span class='line'>
</span><span class='line'><span class="nx">spyOn</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">).</span><span class="nx">andReturn</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span> <span class="err">让</span><span class="nx">obj</span><span class="p">.</span><span class="nx">hello</span><span class="p">()</span><span class="err">永远返回</span><span class="mi">123</span>
</span><span class='line'>
</span><span class='line'><span class="nx">spyOn</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">).</span><span class="nx">andCallFake</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>             <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;welcome&#39;</span><span class="p">);</span>
</span><span class='line'>          <span class="p">});</span>  <span class="c1">// 该方法会让obj.hello()委派到console.log(&#39;welcome&#39;)上，也就是执行提供的函数内容。</span>
</span></code></pre></td></tr></table></div></figure>


<p>从此可以看出Jasmine确实考虑的非常周到</p>

<h2>expectation for spy</h2>

<p>以下expect要配合spyOn, jasmine.createSpy(), jasmine.createSpyObj()来使用</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">spyOn</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="s1">&#39;setBar&#39;</span><span class="p">);</span> <span class="c1">// 监视foo.setBar方法</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">setBar</span><span class="p">).</span><span class="nx">toHaveBeenCalled</span><span class="p">()</span><span class="o">:</span> <span class="err">该方法是否被调用过</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">setBar</span><span class="p">.</span><span class="nx">calls</span><span class="p">.</span><span class="nx">length</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">:</span> <span class="err">该方法是否被调用了两次</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">setBar</span><span class="p">).</span><span class="nx">toHaveBeenCalledWith</span><span class="p">(</span><span class="mi">456</span><span class="p">,</span> <span class="s1">&#39;another param&#39;</span><span class="p">)</span><span class="o">:</span> <span class="err">该方法是否被调用过，并且调用的参数是</span><span class="o">:</span><span class="mi">456</span><span class="err">和</span><span class="s1">&#39;another param&#39;</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">setBar</span><span class="p">.</span><span class="nx">mostRecentCall</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]).</span><span class="nx">toEqual</span><span class="p">(</span><span class="mi">456</span><span class="p">)</span><span class="o">:</span> <span class="err">最近一次调用的第一个参数是否是</span><span class="mi">456</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">setBar</span><span class="p">.</span><span class="nx">calls</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]).</span><span class="nx">toEqual</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span><span class="o">:</span> <span class="err">第一次调用的第一个参数是否是</span><span class="mi">123</span>
</span></code></pre></td></tr></table></div></figure>


<h2>HTML Reporter</h2>

<p>jasmine还可以控制执行以及测试结果的输出，比如下面的代码就是将测试报告输出到html页面上：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">jasmineEnv</span> <span class="o">=</span> <span class="nx">jasmine</span><span class="p">.</span><span class="nx">getEnv</span><span class="p">();</span>
</span><span class='line'>  <span class="nx">jasmineEnv</span><span class="p">.</span><span class="nx">updateInterval</span> <span class="o">=</span> <span class="mi">250</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">htmlReporter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">jasmine</span><span class="p">.</span><span class="nx">HtmlReporter</span><span class="p">();</span>
</span><span class='line'>  <span class="nx">jasmineEnv</span><span class="p">.</span><span class="nx">addReporter</span><span class="p">(</span><span class="nx">htmlReporter</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">jasmineEnv</span><span class="p">.</span><span class="nx">specFilter</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">htmlReporter</span><span class="p">.</span><span class="nx">specFilter</span><span class="p">(</span><span class="nx">spec</span><span class="p">);</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">currentWindowOnload</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span><span class="p">;</span>
</span><span class='line'>  <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">currentWindowOnload</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">currentWindowOnload</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;.version&#39;</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">jasmineEnv</span><span class="p">.</span><span class="nx">versionString</span><span class="p">();</span>
</span><span class='line'>    <span class="nx">execJasmine</span><span class="p">();</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">function</span> <span class="nx">execJasmine</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">jasmineEnv</span><span class="p">.</span><span class="nx">execute</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">})();</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SeaJS原理解析]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/10/inspect-seajs/"/>
    <updated>2013-09-10T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/10/inspect-seajs</id>
    <content type="html"><![CDATA[<p>对于前台javascript代码的模块化组织和依赖加载目前业界比较流行的有RequireJS和玉伯写的的SeaJS。看了下玉伯本人对这两款模块加载器的对比分析，个人还是比较喜欢SeaJS的，尤其是RequireJS在加载一个模块后就立刻执行的做法表示不能理解，可能也跟具体的应用场景有关系，不能用SeaJS的风格来使用RequireJS吧。</p>

<p>今天粗略看了下SeaJS的源码，不对源码的细节进行分析，仅仅对其模块的组织和加载原理做简单的分析，知道了原理剩下的就是代码效率和浏览器兼容性的问题了。</p>

<p>主要解决一下问题：</p>

<ol>
<li>怎么用SeaJS</li>
<li>怎么解析、加载和执行模块</li>
<li>模块标识符（依赖名）的path解析</li>
</ol>


<!--more-->


<h2>怎么用SeaJS</h2>

<p>模块A:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">define</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">require</span><span class="p">,</span> <span class="nx">exports</span><span class="p">,</span> <span class="nx">module</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">addModule</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;add&#39;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">exports</span><span class="p">.</span><span class="nx">hello</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello &#39;</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="s1">&#39;, 1 + 3 = &#39;</span> <span class="o">+</span> <span class="nx">addModule</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>模块add：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">define</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">require</span><span class="p">,</span> <span class="nx">exports</span><span class="p">,</span> <span class="nx">module</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">exports</span><span class="p">.</span><span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>页面入口:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>[html]
</span><span class='line'><span class="cp">&lt;!doctype html&gt;</span>
</span><span class='line'><span class="nt">&lt;html&gt;</span>
</span><span class='line'><span class="nt">&lt;head&gt;</span>
</span><span class='line'>  <span class="nt">&lt;title&gt;</span>seajs demo<span class="nt">&lt;/title&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span> <span class="na">src=</span><span class="s">&quot;lib/sea-debug.js&quot;</span> <span class="na">id=</span><span class="s">&quot;seajsnode&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</span><span class='line'>  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nx">seajs</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">A</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">A</span><span class="p">.</span><span class="nx">hello</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="nt">&lt;/script&gt;</span>
</span><span class='line'><span class="nt">&lt;/head&gt;</span>
</span><span class='line'><span class="nt">&lt;body&gt;</span>
</span><span class='line'><span class="nt">&lt;/body&gt;</span>
</span><span class='line'><span class="nt">&lt;/html&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>是不是很简单，这就是一个典型的模块依赖问题: A是页面入口模块，A->add模块。</p>

<h2>怎么解析、加载和执行模块</h2>

<p>不管是用seajs.use也好，还是在module中使用require也好，都是在告诉seajs去加载一个指定的模块，而且中本质上来说都是异步递归加载的，特别是:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">seajs</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="s1">&#39;module&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">entry</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="p">...</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种形式一看就知道是异步加载。但是在module中:<code>var m = require('mmm');</code>却让人感觉是同步加载，实际上不是这样的，当在模块里调用require时，对应的module文件都已经被load并执行了。</p>

<p>如果moduleA->moduleB，那么流程实际上是这样的：</p>

<p>1.通过fetch函数去加载moduleA</p>

<p>2.加载回来后肯定浏览器会自动执行define(factory)语句，在seajs流程里叫做解析(resolve)，但是factory方法不会被立刻调用(execute)。</p>

<p>3.seajs拿到factory方法，并调用factory.toString()来拿到方法体，通过一个很长的正则表达式提取出其中的require语句(因此seajs对require的写法要求很严格，并且require的模块名参数只能是字符串直接量)，进而拿到moduleA所依赖的所有module(moduleB)。保存moduleA的信息，比如说factory，准备加载moduleB。</p>

<p>4.开始加载moduleB，加载过程同moduleA，但是最后当拿到moduleB的factory方法，并进行依赖的进一步解析时，发现moduleB没有进一步的依赖了，就开始进入执行(execute)过程。</p>

<p>5.经过一系列的递归加载，可以说形成了一个加载栈，execute的过程实际上是从找execute入口函数的过程。回退栈（模块有依赖关系，栈的回退就是依赖的反向关系），直到发现有一个module对象有callback属性，然后就开始执行这个callback。实际上这个有callback属性的module就是seajs的启动方法，或者说use方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// Use function is equal to load a anonymous module</span>
</span><span class='line'><span class="nx">Module</span><span class="p">.</span><span class="nx">use</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">ids</span><span class="p">,</span> <span class="nx">callback</span><span class="p">,</span> <span class="nx">uri</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">mod</span> <span class="o">=</span> <span class="nx">Module</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">uri</span><span class="p">,</span> <span class="nx">isArray</span><span class="p">(</span><span class="nx">ids</span><span class="p">)</span> <span class="o">?</span> <span class="nx">ids</span> <span class="o">:</span> <span class="p">[</span><span class="nx">ids</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">mod</span><span class="p">.</span><span class="nx">callback</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">exports</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">uris</span> <span class="o">=</span> <span class="nx">mod</span><span class="p">.</span><span class="nx">resolve</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">uris</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">exports</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">cachedMods</span><span class="p">[</span><span class="nx">uris</span><span class="p">[</span><span class="nx">i</span><span class="p">]].</span><span class="nx">exec</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">callback</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">global</span><span class="p">,</span> <span class="nx">exports</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">delete</span> <span class="nx">mod</span><span class="p">.</span><span class="nx">callback</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">mod</span><span class="p">.</span><span class="nx">load</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，只有使用use方法加载的module才有callback属性，并且一旦callback被调用之后就会delete mod.callback来删除该属性(比如A同时依赖B和C，那么就会出现两个加载栈，回溯的时候这个callback就会被掉用两次，因此第一次调用之后就会被delete掉。那seajs是如何保证callback被调用的时候所有的依赖都已经加载完毕了呢？实际上seajs的每个模块不但有依赖关系，还有依赖关系的计数，也就是如果A->B,B同时依赖C和D，那么B的依赖计数就是2，每当C或者D被加载完毕后都会让B的计数减1，直到为0的时候B才会去通知A。因此，当callback被调用的时候，其下的所有依赖模块都已经是被resolve完毕的。</p>

<p>6.当进入到execute流程时，所有的模块不是集中被execute的，而是当遇到require(&lsquo;moduleX&rsquo;)的时候才会去检查moduleX是否被execute，如果已经被其他时序execute过了，那么就直接返回上次execute后的结果（模块exports对象）；如果没有，则开始第一次execute过程，execute过程实际上就是调用该模块的factory方法的过程，也是模块被真正定义和接口被exports的过程，由于仅仅是方法调用，因此是同步执行的(var x = require(&lsquo;moduleX&rsquo;)仅仅是个执行factory方法的过程，不涉及异步load）。</p>

<p><em>OK，流程就是这样了，但是需要强调几个事情：</em></p>

<p>a.seajs加载模块的方法就是往head头插入script节点的方法</p>

<p>b.创建和插入的script元素被设置了async=true属性，因此同一层次的所有依赖module可以并行下载</p>

<p>c.模块的解析和execute过程中间都有缓存机制，不会出现重复加载和执行的现象。</p>

<p>d.seajs是如何知道一个模块加载完毕了？看下面的代码就明白了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'>  <span class="nx">node</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">READY_STATE_RE</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">readyState</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// Ensure only run once and handle memory leak in IE</span>
</span><span class='line'>      <span class="nx">node</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kc">null</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// Remove the script to reduce memory leak</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isCSS</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">data</span><span class="p">.</span><span class="nx">debug</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">head</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// Dereference the node</span>
</span><span class='line'>      <span class="nx">node</span> <span class="o">=</span> <span class="kc">null</span>
</span><span class='line'>
</span><span class='line'>      <span class="nx">callback</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>模块标识符（依赖名）的path解析</h2>

<p>很多人对seajs的模块标识符解析有点迷糊，实际上该过程是被封装在了id2Uri(id, refUri)方法中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">id2Uri</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">refUri</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">id</span><span class="p">)</span> <span class="k">return</span> <span class="s2">&quot;&quot;</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">id</span> <span class="o">=</span> <span class="nx">parseAlias</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
</span><span class='line'>  <span class="nx">id</span> <span class="o">=</span> <span class="nx">parsePaths</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
</span><span class='line'>  <span class="nx">id</span> <span class="o">=</span> <span class="nx">parseVars</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
</span><span class='line'>  <span class="nx">id</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">uri</span> <span class="o">=</span> <span class="nx">addBase</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">refUri</span><span class="p">)</span>
</span><span class='line'>  <span class="nx">uri</span> <span class="o">=</span> <span class="nx">parseMap</span><span class="p">(</span><span class="nx">uri</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="nx">uri</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>大致过程如下：</p>

<p>1.检查别名,这个在config中配置</p>

<p>2.path检查</p>

<p>3.路径中的变量替换</p>

<p>4.标准化路径，可以理解成将/a/b/c改为/a/b/c.js</p>

<p>5.合成完整路径，addBase:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">addBase</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">refUri</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">ret</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">first</span> <span class="o">=</span> <span class="nx">id</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Absolute</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nx">ABSOLUTE_RE</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">id</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">ret</span> <span class="o">=</span> <span class="nx">id</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// Relative</span>
</span><span class='line'>  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">first</span> <span class="o">===</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">ret</span> <span class="o">=</span> <span class="nx">realpath</span><span class="p">((</span><span class="nx">refUri</span> <span class="o">?</span> <span class="nx">dirname</span><span class="p">(</span><span class="nx">refUri</span><span class="p">)</span> <span class="o">:</span> <span class="nx">data</span><span class="p">.</span><span class="nx">cwd</span><span class="p">)</span> <span class="o">+</span> <span class="nx">id</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// Root</span>
</span><span class='line'>  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">first</span> <span class="o">===</span> <span class="s2">&quot;/&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">cwd</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">ROOT_DIR_RE</span><span class="p">)</span>
</span><span class='line'>    <span class="nx">ret</span> <span class="o">=</span> <span class="nx">m</span> <span class="o">?</span> <span class="nx">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">id</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="nx">id</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// Top-level</span>
</span><span class='line'>  <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">ret</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">base</span> <span class="o">+</span> <span class="nx">id</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="nx">ret</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>6.map替换</p>

<p>最后的id就是解析的结果</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[setTimeout和setInterval]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/05/settimeout-and-setinterval/"/>
    <updated>2013-09-05T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/05/settimeout-and-setinterval</id>
    <content type="html"><![CDATA[<p>setTimeout和setInterval是浏览器环境中两个可用的定时器方案。在使用过程中曾经遇到了两个坑，在这里记录下：</p>

<h3>setInterval:</h3>

<p>可以定期按照一定的频率做一个事情，比如funA。但是如果funA中抛出了异常会怎样呢？  firefox和chrome不会因为抛出异常而做出什么奇怪的事情，毕竟调用setInterval只是告诉浏览器我要定期做一个事情，哪怕这个事情出错了；但是IE却在出现异常后停止继续定期做这个事情，所以千万要保证funA中的事情一定不要有异常出现。</p>

<h3>setTimeout:</h3>

<p>延时一段时间做某个事情funcB。比如：</p>

<p>setTimeout(tick, 1000)会在1秒之后将tick加入到事件队列中准备执行，并且tick方法的arguments是空的，但是在firefox13以下的tick的arguments却不一定是空的，有可能会有一个表示延时时间的数值(小于0)来表示执行该函数比预期时间推后了多少。新版本的firefox已经解决了该问题，但是还是不要试图在tick方法中根据arguments的数量来决定行为。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thread的状态]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/04/status-of-thread/"/>
    <updated>2013-09-04T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/04/status-of-thread</id>
    <content type="html"><![CDATA[<p>每个Thread在创建出来之后就有一个状态信息，可以通过Thread.getState()来获得该thread的状态，虽然javadoc中对thread的状态有详细的描述，但是很多人还是不能很好的说出所有的状态，以及不同状态的含义，理解这些状态还有助于使用java的线程分析工具，比如jstack</p>

<p>Thread的状态是由Thread.State枚举表示的，有下面的6个值：</p>

<h3>NEW</h3>

<p>当线程刚被new出来，并且没有start的时候处于NEW状态</p>

<h3>BLOCKED</h3>

<p>线程被阻塞，一般是由于锁的原因等待进入临界区时候的状态</p>

<h3>RUNNABLE</h3>

<p>正在运行，就算是没有获得CPU时间片的线程也是在RUNNABLE</p>

<h3>WAITING</h3>

<p>顾名思义，线程处于等待状态。它正在等待其他的操作被触发，比如wait()后等待notify()或者notifyAll()；Thread.join()后等待目标线程被结束；LockSupport.park()后等待LockSupport.unpark()。</p>

<p>注意，在调用wait()后会首先进入WAITING状态，如果被notify()了，并且无法获得锁并进入临界区，那么就在BLOCKED；如果进入临界区了，那么就是RUNNABLE</p>

<h3>TIMED_WAITING</h3>

<p>相比WAITING状态，只是多了一个时间参数，比如Thread.sleep(10)，object.wait(10)等等。</p>

<h3>TERMINATED</h3>

<p>运行完毕</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解GC暂停 - Hotspot中的minor gc[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2013/08/16/gc-stop-minor-gc-in-hotspot/"/>
    <updated>2013-08-16T02:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/08/16/gc-stop-minor-gc-in-hotspot</id>
    <content type="html"><![CDATA[<p><a href="http://blog.ragozin.info/2011/06/understanding-gc-pauses-in-jvm-hotspots.html">原文链接</a></p>

<p>当JVM进行垃圾搜集的时候会Stop-The-World暂停，它们是java应用程序的天敌。Hotspot JVM多种先进的、被优化的垃圾收集器，但是要想找到一个最优的配置需要首先了解垃圾搜集算法的机制。这篇文章介绍了GC在STW时怎么使用CPU，并且还介绍了一个新生代的垃圾搜集算法。</p>

<h2>堆结构</h2>

<p>大多数现代GC算法都是分代收集的，这意味着java的堆被划分为了多个空间。不同的空间用其中保存的对象的年龄划分。对象首先被分配到新生代，然后经过多次存活后，最终被放到了老年代。这个是基于“大多数的对象在创建后很快就会消亡”的假设。所有的Hotspot垃圾收集器都将内存划分为5个部分（对于G1收集器，空间可能不是连续的）。</p>

<p><img src="http://shenzhang.github.io/images/2013/08/java_heap_struct.png"></p>

<ol>
<li>Eden:eden区是对象被分配的地方</li>
<li>Survivor: Survivor区被用来在young gc或者minor gc中接收存活的对象</li>
<li>Tenured:Tenured区是保存长时间存活的对象</li>
<li>Permanent:Permanent是供JVM自己使用，比如classes或者被JIT编译后的代码，它的行为和tenured区类似，因此在文章的后面我们将忽略该区域。</li>
</ol>


<p>Eden和2个Survivor区在一起被称作新生代（yound space)。</p>

<h3>Hotspot GC算法</h3>

<ol>
<li>串行垃圾收集(-XX:+UseSerialGC)</li>
<li>新生代并行，老年代串行的分代收集(-XX:+UseParallelGC)</li>
<li>新生代和老年代都并行的分代收集(-XX:+UseParallelOldGC)</li>
<li>CMS收集算法和串行化的新生代收集器(-XX:+UseConcMarkSweep, -XX:-UseParNewGC)</li>
<li>CMS收集算法和并行化的新生代收集器(-XX:+UseConcMarkSweep, -XX:+UseParNewGC)</li>
<li>G1收集算法(-XX:+UseG1GC)</li>
</ol>


<p>除了G1之外，其他所有的垃圾收集算法在新生代部分都使用了类似的算法（串行或者并行）</p>

<h3>写屏障(Write barrier)</h3>

<p>分代垃圾收集器的关键点在于，是否有必要每次都对整个java堆进行垃圾收集，还是对其中的一部分进行收集（比如新生代)。但是JVM为了实现这个效果，需要实现一个特殊的机制“写屏障”。在Hotspot中实现了两种类型的写屏障：dirty cards和snaphot-at-the-beginning(SATB)。SATB被用于G1算法中（该文没有对其描述）。其他所有的垃圾收集算法都使用dirty cards。</p>

<h3>Dirty cards写屏障(卡片标记)</h3>

<p>Dirty cards写屏障的原理非常简单。每当应用程序改变内存中的引用时，都需要标记该内存页是脏(dirty)的。JVM中有一个特殊的卡片表(card table)，每512字节的页都对应其中的1个字节。</p>

<p><img src="http://shenzhang.github.io/images/2013/08/card-table.png"></p>

<h3>新生代垃圾收集算法</h3>

<p>绝大部分的对象会被首先分配到eden区（除了在一些特殊的情况下，对象可能会直接被分配到老年代）。为了更高效的分配内存，Hotspot使用了线程本地分配块（thread local allocation block, TLAB)来分配新的对象，但是TLAB本身又被分配在eden区。一旦eden区满了就会触发minor gc。minor gc的目标是清理eden区，释放内存。在这里使用的是拷贝算法，存活的对象被拷贝到另外的一块区域，之前的区域的所有空间被标记为可用（free）。但是在开始垃圾收集之前，JVM首先需要找到根（root）引用，所有用于minor gc的根引用是来自堆栈的引用或者来自老年代的引用。</p>

<p>通常情况下，搜集来自于老年代的引用需要扫描整个老年代对象的所有引用，因此我们需要写屏障（write-barrier）。所有在新生代中的对象都是在上次写屏障被复位之后分配的，也就意味着非脏(no-dirty)页是不可能引用新生代的对象，最后意味着我们没必要扫描整个老年代，而只需要扫描dirty pages中的对象即可。</p>

<p><img src="http://shenzhang.github.io/images/2013/08/dirty-pages.png"></p>

<p>最开始的dirty cards是空的，并且开始young gc后，JVM拷贝eden和其中一个survivor中存活的对象到另外一个survivor区。JVM只需要花费时间在存活对象上，拷贝和再分配（relocate）对象也需要更新指向它们的引用。</p>

<p><img src="http://shenzhang.github.io/images/2013/08/dirty-pages1.png"></p>

<p>当JVM更新移动后的对象的引用时，内存也同时也被修改了，自然会打上dirty的标记。最终在我们下次开始young gc的时候，只有位于dirty pages中的页才有可能引用新生代的对象。</p>

<p><img src="http://shenzhang.github.io/images/2013/08/dirty-pages2.png"></p>

<h3>对象升级</h3>

<p>如果对象没有在young gc中被清除，那么最终会被拷贝到老年代。对象升级会在下述情况下发生：</p>

<ol>
<li>-XX:+AlwaysTenure:让JVM直接将eden中的对象升级到老年代，而不通过survivor区（survivor区在这里不再使用）</li>
<li>其中一个survivor区已经满了，那么所有剩下的存活对象都直接升级到老年代。</li>
<li>如果对象在新生代的垃圾收集中存活了足够多的周期，就会被升级到老年代（存活周期数通过–XX:MaxTenuringThreshol选项和-XX:TargetSurvivorRatio选项调整）</li>
</ol>


<h3>对象直接被分配到老年代</h3>

<p>如果我们可以将存活时间较长的对象直接分配到老年代，那么我们会获得性能提升。但是很不幸，我们无法告诉JVM这么做。但是仍然还是有一些情况，对象可以直接被分配到老年代：</p>

<ol>
<li>-XX:PretenureSizeThreshold=<n>：告诉JVM如果对象的大小大于<n>时，就可以直接将该对象分配到老年代。</li>
<li>如果对象的大小大于了eden区，那么也会直接分配到老年代。</li>
</ol>


<p>不同于应用程序对象，系统级的对象会直接分配到永久带。</p>

<h3>并行执行</h3>

<p>在young gc中的大部分任务都可以并行执行。如果有多个CPU可用，那么JVM可以充分利用它们以减少STW的时间。可以通过选项–XX:ParallelGCTreads=<n>来告诉JVM使用多少个线程来执行GC。默认情况下，JVM会使用当前可用的CPU数量作为GC的线程数。但是串行版的收集器会忽律给选项，因为它只使用一个CPU线程。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解GC暂停 - Hotspot中的CMS[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2013/08/16/gc-stop-cms-in-hotspot/"/>
    <updated>2013-08-16T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/08/16/gc-stop-cms-in-hotspot</id>
    <content type="html"><![CDATA[<p><a href="http://blog.ragozin.info/2011/06/understanding-gc-pauses-in-jvm-hotspots_02.html">原文链接</a></p>

<p>Concurrent-Mark-Sweep(CMS)是Hotspot JVM中的一个短停顿垃圾回收器。CMS在回收内存时做的大部分工作都可以和应用程序并发执行（不用暂停应用程序）。但是仍然需要短暂的Stop-The-World暂停。这篇文章会介绍这个暂停的原因以及如何减少这样的暂停。</p>

<h2>CMS基础</h2>

<p>Hotspot中的CMS收集器是分代搜集的，因此整个java堆被分为了新生代和老年代，并且它们可以独立进行搜集。对于新生代Hotspot通常使用的是拷贝算法。要想开启CMS收集器，需要在命令行参数里指定-XX:+UseConcMarkSweepGC选项。</p>

<p>CMS被用来搜集老年代，一个CMS搜集周期包括以下阶段：</p>

<ol>
<li>Inital mark:CMS在这个阶段搜集所有的根(root)引用，并且是STW的。</li>
<li>Concurrent mark:这个阶段会与应用程序并发执行，在该阶段垃圾收集器会遍历老年代的所有对象(从root开始)，将存活的对象标记出来。</li>
<li>Concurrent pre clean:这是另外一个并发阶段，主要也是用于标记操作，它会找到从上次标记(mark)之后改变了的引用。这个阶段最主要的目的是减少remark阶段的STW时间。</li>
<li>Remark：一旦Concurrent mark结束了，垃圾收集器需要进入STW暂停，在暂停的时候找到所有从上次mark之后所有被改变了的引用。</li>
<li>Concurrent sweep:垃圾收集器在该阶段会扫描整个老年代，并且回收不再使用的内存。</li>
<li>Concurrent reset：在CMS周期结束后，一些数据结构需要在下次周期开始之前被重置。</li>
</ol>


<p>不同于其他大多数垃圾收集器，CMS不会对老年代的堆内存进行整理。CMS没有对内存对象进行移动以便让为使用的空间保持连续，它会维护所有空闲内存段的列表。这样CMS避免了对内存重新布局的开销（对内存重新布局需要STW），但是负面效果就是会产生内存碎片。为了减少产生内存碎片的风险，CMS会对对象尺寸进行统计，并且针对对象的不同尺寸来维护空闲列表。</p>

<h2>CMS暂停时间</h2>

<p>CMS本身只有两个暂停点，但是你的应用程序执行新生代的垃圾回收时同样会进行暂停。</p>

<h2>Inital mark</h2>

<p>在inital mark阶段，CMS会遍历老年代的所有根引用。这包括：</p>

<ol>
<li>来自于线程栈的引用</li>
<li>来自于新生代的引用</li>
</ol>


<p>来自于线程栈的引用会搜集的很快（不超过1毫秒），但是搜集来自于新生代的引用就依赖于新生代对象的多少了。通常inital mark会在新生代gc完毕后开始，所以eden区这个时候时空的，并且其中一个survivor区里面也仅仅包含了存活下来的对象。Survivor区通常很小，因此在young gc完成后执行inital mark会很快，不超过毫秒。但是，如果inital mark在eden区满的时候开启，那么将会花费很长的时间（往往比young gc本身都还要长）</p>

<p>一旦CMS收集器被触发了，JVM会等待一段时间，让young gc完成后再开始inital mark。JVM配置参数-XX:CMSWaitDuration=<t>可以用来配置CMS等待多长时间才开始inital mark。如果你不希望长时间的inital mark暂停，那么你可以配置该选项，让等待时间略微长于你的应用中执行一次young gc所需要的时间。</p>

<h2>Remark</h2>

<p>大多数的标记（marking）可以和应用程序并行执行，但是也不是绝对的，因为有可能应用会在mark阶段修改对象引用图。当concurrent mark结束后，垃圾收集器会暂停应用程序，并且进行重复的标记以保证所有可达的的对象都已经标记为存活状态。但是收集器不需要遍历整个对象图，它仅仅需要遍历哪些自从上次标记（marking）阶段之后被修改过的引用（确切的说是从上次pre clean阶段之后）。卡片表（card table)被用来标记那些老年代中被修改的内存区域，但是新生代和堆栈部分还是需要被重新扫描一遍。</p>

<p>通常情况下remark阶段大部分时间被花费在了扫描新生代部分。如果在开始remark之前对新生代进行了gc，那么这个时间会大大缩短。我们可以加上-XX:+CMSScanvengeBeforeRemark选项来让JVM在开始remark之前强制进行新生代的gc。就算新生代是空的，remark阶段还是会对老年代中已经修改的引用进行扫描，这个所花费的时间和新生代gc暂停时间差不多。</p>

<h2>什么时候会触发CMS</h2>

<p>不同于其他老年代STW收集器，CMS搜集周期在老年代满了之前就需要开始（其他老年代收集器只需要老年代满的时候出发，而CMS需要在老年代没满的时候就触发）。CMS收集器在老年代的可用空间达到一定的阈值时（这个阈值可根据JVM在运行中搜集的统计信息或者参数来决定），并且CMS可能会推迟到下一次young gc触发之后才开始。普通的对象只会在yong gc的过程中被分配到老年代，因此CMS一般是在yong gc发生之后才开始，并且这样也会让initial mark变得很小。但是在某些情况下，对象可能会直接被分配在老年代，并且CMS开始的时候eden区可能具有很多对象。这个时候inital mark会多耗费10-100倍的时间，这个情况是非常糟糕的。通常这种情况只会在分配很大对象的时候（好几M大小的数组）。为了避免这种长暂停，你可以配置-XX:CMSWaitDuration选项。</p>

<h2>配置CMS开始的固定阈值</h2>

<p>你可以配置固定的老年代充满比例阈值来触发CMS gc：</p>

<pre><code>‑XX:+UseCMSInitiatingOccupancyOnly 
‑XX:CMSInitiatingOccupancyFraction=70(这会告诉JVM只有当超过70%的老年代被使用后才触发CMS)
</code></pre>

<h2>显式触发CMS</h2>

<p>你可以配置JVM，只要代码调用System.gc()方法后就触发CMS：<code>-XX:+ExplicitGCInvokesConcurrent</code></p>

<h2>CMS和Full gc</h2>

<p>如果CMS不能释放足够的老年代内存，JVM会启用整理式的搜集算法(Compacting)。整理收集器会强迫进入STW暂停，因此它只会出现在紧急情况下。通常大家都不希望进行full gc和较长时间的STW暂停。当CMS不能足够快的释放老年代内存，或者CMS启动的太晚了，或者因为老年代的内存碎片（没有足够的连续空间存放对象）时才会发生full gc。又或者你没有配置足够的堆内存，那么在full gc之后就会抛出OutOfMemoryException。</p>

<h2>永久带gc</h2>

<p>CMS结束后会触发full gc的一个原因是因为永久带的垃圾问题。默认的，CMS不会对永久带进行搜集。如果你的应用程序使用了多个classloader，或者反射，你可能会需要开启对永久带的垃圾回收。JVM选项-XX:+CMSClassUnloadingEnabled会允许CMS对永久带进行垃圾搜集。需要注意的是，位于永久带的对象可能会具有老年代对象的引用，如果永久带并没有满，这些从永久带到老年代的引用会导致一些已经死掉(dead)的对象在CMS周期内不可达，除非开启了class unloading。</p>

<h2>有效使用多核</h2>

<p>CMS具有多个阶段，有些是可以并发执行的，另外的是需要STW暂停的，但是可以并行执行以压缩程序暂停时间。</p>

<pre><code>-XX:+CMSConcurrentMTEnabled:允许CMS在concurrent阶段使用多核。
-XX:ConcGCThreads=&lt;n&gt;:指定concurrent阶段使用的线程数量
-XX:ParallelGCThreads=&lt;n&gt;:指定在STW暂停中并行工作的线程数（默认是机器的物理核心数）
-XX:+UseParNewGC:让JVM在新生代使用并行收集器，配合老年代的CMS。
</code></pre>
]]></content>
  </entry>
  
</feed>
