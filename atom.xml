<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Keep going]]></title>
  <link href="http://shenzhang.github.io/atom.xml" rel="self"/>
  <link href="http://shenzhang.github.io/"/>
  <updated>2014-05-03T00:44:57+08:00</updated>
  <id>http://shenzhang.github.io/</id>
  <author>
    <name><![CDATA[zshen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java中的Reference对象[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2014/04/27/java-reference-objects/"/>
    <updated>2014-04-27T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2014/04/27/java-reference-objects</id>
    <content type="html"><![CDATA[<p><a href="http://www.kdgregory.com/index.php?page=java.refobj#ObjectLifeCycle">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入解析OutOfMemoryError[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2014/04/24/understanding-out-of-memory-error/"/>
    <updated>2014-04-24T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2014/04/24/understanding-out-of-memory-error</id>
    <content type="html"><![CDATA[<p><a href="http://www.kdgregory.com/index.php?page=java.outOfMemory">原文链接</a></p>

<p>在Java中，所有对象都存储在堆中。他们通过<code>new</code>关键字来进行分配，JVM会检查是否所有线程都无法在访问他们了，并且会将他们进行回收。在大多数时候程序员都不会有一丝一毫的察觉，这些工作都被静悄悄的执行。但是，有时候在发布前的最后一天，程序挂了。</p>

<pre><code>Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
</code></pre>

<p><code>OutOfMemoryError</code>是一个让人很郁闷的异常。它通常说明你干了写错误的事情：没必要的长时间保存一些没必要的数据，或者同一时间处理了过多的数据。有些时候，这些问题并不一定受你的控制，比如说一些第三方的库对一些字符串做了缓存，或者一些应用服务器在部署的时候并没有进行清理。并且，对于堆中已经存在的对象，我们往往拿他们没办法。</p>

<p>这篇文章分析了导致<code>OutOfMemoryError</code>的不同原因，以及你该怎样应对这种原因的方法。以下分析仅限于Sun Hotspot虚拟机，但是大多数结论都适用于其他任何的JVM实现。它们大多数基于网上的文章以及我自己的经验。我没有直接做JVM开发的工作，因此结论并不代表JVM的作者。但是我确实曾经遇到过并解决了很多内存相关的问题。</p>

<!-- more -->


<h2>垃圾回收介绍</h2>

<p>我在<a href="http://www.kdgregory.com/index.php?page=java.refobj#ObjectLifeCycle">这篇文章</a>中已经详细介绍了垃圾回收的过程。简单的说，标记-清除算法(mark-sweep collect)以<code>garbage collection roots</code>作为扫描的起点，并对整个对象图进行扫描，对所有可达的对象进行标记。那些没有被标记的对象会被清除并回收。</p>

<p>Java的垃圾回收算法过程意味着如果出现了OOM，那么说明你在不停的往对象图中添加对象并且没有移除它们。这通常是因为你在往一个集合类中添加了很多对象，比如Map，并且这个集合对象是static的。或者，这个集合类被保存在了<code>ThreadLocal</code>对象中，而这个对应的Thread却又长时间的运行，一直不退出。</p>

<p>这与C和C++的内存泄露完全不一样。在这些语言中，如果一些方法调用了malloc()或者new，并且在方法退出的时候没有调用相应的free()或者delete，那么内存就会产生泄露。这些是真正意义上得泄露，你在这个进程范围内不可能再恢复这些内存，除非使用一些特定的工具来保证每一个内存分配方法都有其对应的内存释放操作相对应。</p>

<p>在java中，“泄露”这个词往往被误用了。因为从JVM的角度来说，所有的内存都是被良好管理的。问题仅仅是作为程序员的你不知道这些内存是被哪些对象占用了。但是幸运的是，你还是有办法去找到和定位它们。</p>

<p>在深入探讨之前，你还有最后一件关于垃圾收集的知识需要了解：JVM会尽最大的能力去释放内存，直到发生OOM。这就意味着OOM不能通过简单的调用<code>System.gc()</code>来解决，你需要找到这些“泄露”点，并自己处理它们。</p>

<h2>设置堆大小</h2>

<p>学院派的人非常喜欢说<a href="http://java.sun.com/docs/books/jls/third_edition/html/j3TOC.html">Java语言规范</a>并没有对垃圾收集器进行任何约定，你甚至可以实现一个从来不释放内存的JVM(实际是毫无意义的)。<a href="http://java.sun.com/docs/books/jvms/second_edition/html/Overview.doc.html#15730">Java虚拟机规范</a>中提到堆是由垃圾回收器进行管理，但是却没有说明任何相关细节。仅仅说了我刚才提到的那句话：垃圾回收会发生在OOM之前。</p>

<p>实际上，Sun Hotspot虚拟机使用了一个固定大小的堆空间，并且允许在最小空间和最大空间之间进行自动增长。<strong>如果你没有指定最小值和最大值，那么对于&#8217;client&#8217;模式将会默认使用2Mb最为最小值，64Mb最为最大值；对于&#8217;server&#8217;模式，JVM会根据当前可用内存来决定默认值</strong>。2000年后，默认的最大堆大小改为了64M，并且在当时已经认为足够大了(2000年前的时候默认值是16M)，但是对于现在的应用程序来说很容易就用完了。</p>

<p>这意味着你需要显示的通过JVM参数来指定堆的最小值和最大值：</p>

<pre><code>java -Xms256m -Xmx512m MyClass
</code></pre>

<p>这里有很多经验上得法则来设定最大值和最小值。显然，堆的最大值应该设定为足以容下整个应用程序所需要的全部对象。但是，将它设定为“刚刚好足够大”也不是一个很好的注意，因为这样会增加垃圾回收器的负载。因此，对于一个长时间运行的应用程序，你一般需要保持有20%-25%的空闲堆空间。（你得应用程序可能需要不同的参数设置，GC调优是一门艺术，并且不在该文章讨论范围内）</p>

<p>让你奇怪的时，设置合适的堆的最小值往往比设置合适的最大值更加重要。垃圾回收器会尽可能的保证<strong>当前的</strong>的堆大小，而不是不停的增长堆空间。这会导致应用程序不停的创建和回收大量的对象，而不是获取新的堆空间，相对于初始(最小)堆空间。Java堆会尽量保持这样的堆大小，并且会不停的运行GC以保持这样的容量。因此，我认为在生产环境中，我们最好是将堆的最小值和最大值设置成一样的。</p>

<p>你可能会困惑于为什么Java堆会有一个最大值上限：操作系统并不会分配真正的物理内存，除非他们真的被使用了。并且，实际使用的虚拟内存空间实际上会比Java堆空间要大。如果你运行在一个32位系统上，一个过大的堆空间可能会限制classpath中能够使用的jar的数量，或者你可以创建的线程数。</p>

<p>另外一个原因是，一个受限的最大堆空间可以让你及时发现潜在的内存泄露问题。在开发环境中，对应用程序的压力往往是不够的，如果你在开发环境中就拥有一个非常大得堆空间，那么你很有可能永远不会发现可能的内存泄露问题，直到进入产品环境。</p>

<h2>在运行时跟踪垃圾回收</h2>

<p>所有的JVM实现都提供了<code>-verbos:gc</code>选项，它可以让垃圾回收器在工作的时候打印出日志信息：</p>

<pre><code>java -verbose:gc com.kdgregory.example.memory.SimpleAllocator
[GC 1201K-&gt;1127K(1984K), 0.0020460 secs]
[Full GC 1127K-&gt;103K(1984K), 0.0196060 secs]
[GC 1127K-&gt;1127K(1984K), 0.0006680 secs]
[Full GC 1127K-&gt;103K(1984K), 0.0180800 secs]
[GC 1127K-&gt;1127K(1984K), 0.0001970 secs]
...
</code></pre>

<p>Sun的JVM提供了额外的两个参数来以内存带分类输出，并且会显示垃圾收集的开始时间：</p>

<pre><code>java -XX:+PrintGCDetails -XX:+PrintGCTimeStamps com.kdgregory.example.memory.SimpleAllocator
0.095: [GC 0.095: [DefNew: 177K-&gt;64K(576K), 0.0020030 secs]0.097: [Tenured: 1063K-&gt;103K(1408K), 0.0178500 secs] 1201K-&gt;103K(1984K), 0.0201140 secs]
0.117: [GC 0.118: [DefNew: 0K-&gt;0K(576K), 0.0007670 secs]0.119: [Tenured: 1127K-&gt;103K(1408K), 0.0392040 secs] 1127K-&gt;103K(1984K), 0.0405130 secs]
0.164: [GC 0.164: [DefNew: 0K-&gt;0K(576K), 0.0001990 secs]0.164: [Tenured: 1127K-&gt;103K(1408K), 0.0173230 secs] 1127K-&gt;103K(1984K), 0.0177670 secs]
0.183: [GC 0.184: [DefNew: 0K-&gt;0K(576K), 0.0003400 secs]0.184: [Tenured: 1127K-&gt;103K(1408K), 0.0332370 secs] 1127K-&gt;103K(1984K), 0.0342840 secs]
...
</code></pre>

<p>从上面的输出我们可以看出什么？首先，前面的几次垃圾回收发生的非常频繁。每行的第一个字段显示了JVM启动后的时间，我们可以看到在一秒钟内有上百次的GC。并且，还加入了每次GC执行时间的开始时间（在每行的最后一个字段），可以看出垃圾搜集器是在不停的运行的。</p>

<p>但是在实时系统中，这会造成很大的问题，因为垃圾搜集器的执行会夺走很多的CPU周期。就像我之前提到的，这很可能是由于初始堆大小设置的太小了，并且GC日志显示了：每次堆的大小达到了1.1Mb，它就开始执行GC。如果你得系统也有类似的现象，请在改变自己的应用程序之前使用<code>-Xms</code>来增大初始堆大小。</p>

<p>对于GC日志还有一些很有趣的地方：除了第一次垃圾回收，没有任何对象是存放在了新生代(&ldquo;DefNew&rdquo;)。这说明了这个应用程序分配了包含大量数据的数组，在显示世界里这是很少出现的。如果在一个实时系统中出现这样的状况，我想到的第一个问题是“这些数组拿来干什么用？”。</p>

<h2>堆转储(Heap Dumps)</h2>

<p>一个堆转储可以显示你在应用程序说使用的所有对象。从基础上讲，它仅仅反映了对象实例的数量和类文件所占用的字节数。当然你也可以将分配这些内存的代码一起dump出来，并且对比历史存货对象。但是，如果你要dump的数据信息越多，JVM的负载就会越大，因此这些技术仅仅应该使用在开发环境中。</p>

<h3>怎样获得一个内存转储</h3>

<p>命令行参数<code>-XX:+HeapDumpOnOutOfMemoryError</code>是最简单的方式生成内存转储。就像它的名字所说的，它会在内存被用完的时候(发生OOM)进行转储，这在产品环境非常好用。但是由于这个是一种事后转储（已经发生了OOM），它只能提供一种历史性的数据。它会产生一个二进制文件，你可以使用<a href="http://java.sun.com/javase/6/docs/technotes/tools/share/jhat.html">jhat</a>来操作该文件（这个工具在JDK1.6中已经提供，但是可以读取JDK1.5产生的文件）。</p>

<p>你可以使用<a href="http://java.sun.com/javase/6/docs/technotes/tools/share/jmap.html">jmap</a>(JDK1.5之后就自带了)来为一个运行中得java程序产生堆转储，可以产生一个在<em>jhat</em>中使用的dump文件，或者是一个存文本的统计文件。统计图可以在进行分析时优先使用，特别是你要在一段时间内多次转储堆并进行分析和对比历史数据。</p>

<p>从转储内容和JVM的负荷的扩展性上考虑的话，可以使用profilers。Profiles使用JVM的调试接口(debuging interface)来搜集对象的内存分配信息，包括具体的代码行和方法调用栈。这个是非常有用的：不仅仅可以知道你分配了一个数GB的数组，你还可以知道你在一个特定的地方分配了950MB的对象，并且直接忽略其他的对象。当然，这些结果肯定会对JVM有开销，包括CPU的开销和内存的开销(保存一些原始数据)。你不应该在产品环境中使用profiles。</p>

<h3>堆转储分析：live objects</h3>

<p>Java中的内存泄露是这样定义的：你在内存中分配了一些对象，但是并没有清除掉所有对它们的引用，也就是说垃圾搜集器不能回收它们。使用堆转储直方图可以很容易的查找这些泄露对象：它不仅仅可以告诉你在内存中分配了哪些对象，并且显示了这些对象在内存中所占用的大小。但是这种直方图最大的问题是：对于同一个类的所有对象都被聚合(group)在一起了，所以你还需要进一步做一些检测来确定这些内存在哪里被分配了。</p>

<p>使用<em>jmap</em>并且加上<code>-histo</code>参数可以为你产生一个直方图，它显示了从程序运行到现在所有对象的数量和内存消耗，并且包含了已经被回收的对象和内存。如果使用<code>-histo:live</code>参数会显示当前还在堆中得对象数量及其内存消耗，不论这些对象是否要被垃圾搜集器进行回收。</p>

<p>也就是说，如果你要得到一个当前时间下得准确信息，你需要在使用<em>jmap</em>之前强制执行一次垃圾回收。如果你的应用程序是运行在本地，最简单的方式是直接使用<a href="http://download.oracle.com/javase/6/docs/technotes/tools/share/jconsole.html">jconsole</a>：在&#8217;Memory&#8217;标签下，有一个&#8217;Perform GC&#8217;的按钮。如果应用程序是运行在服务端环境，并且JMX beans被暴露了，<code>MemoryMXBean</code>有一个<code>gc()</code>操作。如果上述的两种方案都没办法满足你得要求，你就只有等待JVM自己触发一次垃圾搜集过程了。如果你有一个很严重的内存泄露问题，那么第一次major collection很可能预示着不久后就会OOM。</p>

<p>有两种方法使用<code>jmap</code>产生的直方图。其中最有效的方法，适用于长时间运行的程序，可以使用带<code>live</code>的命令行参数，并且在一段时间内多次使用该命令，检查哪些对象的数量在不断增长。但是，根据当前程序的负载，该过程可能会花费1个小时或者更多的时间。</p>

<p>另外一个更加快速的方式是直接比较当前存活的对象数量和总的对象数量。如果有些对象占据了总对象数量的大部分，那么这些对象很有可能发生内存泄露。这里有一个例子，这个应用程序已经连续几周为100多个用户提供了服务，结果列举了前12个数量最多的对象。据我所知，这个程序没有内存泄露的问题，但是像其他应用程序一样做了常规性的内存转储分析操作。</p>

<pre><code>~, 510&gt; jmap -histo 7626 | more

 num     #instances         #bytes  class name
----------------------------------------------
   1:        339186       63440816  [C
   2:         84847       18748496  [I
   3:         69678       15370640  [Ljava.util.HashMap$Entry;
   4:        381901       15276040  java.lang.String
   5:         30508       13137904  [B
   6:        182713       10231928  java.lang.ThreadLocal$ThreadLocalMap$Entry
   7:         63450        8789976  &lt;constMethodKlass&gt;
   8:        181133        8694384  java.lang.ref.WeakReference
   9:         43675        7651848  [Ljava.lang.Object;
  10:         63450        7621520  &lt;methodKlass&gt;
  11:          6729        7040104  &lt;constantPoolKlass&gt;
  12:        134146        6439008  java.util.HashMap$Entry

~, 511&gt; jmap -histo:live 7626 | more

 num     #instances         #bytes  class name
----------------------------------------------
   1:        200381       35692400  [C
   2:         22804       12168040  [I
   3:         15673       10506504  [Ljava.util.HashMap$Entry;
   4:         17959        9848496  [B
   5:         63208        8766744  &lt;constMethodKlass&gt;
   6:        199878        7995120  java.lang.String
   7:         63208        7592480  &lt;methodKlass&gt;
   8:          6608        6920072  &lt;constantPoolKlass&gt;
   9:         93830        5254480  java.lang.ThreadLocal$ThreadLocalMap$Entry
  10:        107128        5142144  java.lang.ref.WeakReference
  11:         93462        5135952  &lt;symbolKlass&gt;
  12:          6608        4880592  &lt;instanceKlassKlass&gt;
</code></pre>

<p>当我们要尝试寻找内存泄露问题，可以从消耗内存最多的对象着手。这听上去很明显，但是往往它们并不是内存泄露的根源。但是，它们任然是应该最先下手的地方，在这个例子中，最占用内存的是一些<code>char[]</code>的数组对象（总大小是60MB，基本上没有任何问题）。但是很奇怪的是当前存货(live)的对象竟然占了历史分配的总对象大小的三分之二。</p>

<p>一般来说，一个应用程序会分配对象，并且在不久之后就会释放它们。如果保存一些对象的应用过长的时间，就很有可能会导致内存泄露。但是虽然是这么说的，实际上还是要具体情况具体分析，主要还是要看这个程序到底在做什么事情。字符数组对象(char[])往往和字符串对象(String)同时存在，大部分的应用程序都会在整个运行过程中一直保持着一些字符串对象的引用。例如，基于JSP的web应用程序在JSP页面中定义了很多HTML字符串表达式。这种特殊的应用程序提供HTML服务，但是它们需要保持字符串引用的需求却不一定那么清晰：它们提供的是目录服务，并不是静态文本。如果我遇到了OOM，我就会尝试找到这些字符串在哪里被分配，为什么没有被释放。</p>

<p>另一个需要关注的是字节数组([B)。在JDK中有很多类都会使用它们（比如BufferedInputStream），但是却很少在应用程序代码中直接看到它们。通常它们会被用作缓存(buffer)，但是缓存的生命周期不会很长。在这个例子中我们看到，有一半的字节数组任然保持存活。这个是令人担忧的，并且它凸显了直方图的一个问题：所有的对象都按照它的类型被分组聚合了。对于应用程序对象(非JDK类型或者原始类型，在应用程序代码中定义的类)，这不是一个问题，因为它们会在程序的一个部分被集中分配。但是字节数组有可能会在任何地方被定义，并且在大多数应用程序中都被隐藏在一些库中。我们是否应当搜索调用了<code>new byte[]</code>或者<code>new ByteArrayOutputStream()</code>的代码？</p>

<h3>堆转储分析：相关的原因和影响分析</h3>

<p>为了找到导致内存泄露的最终原因，仅仅考虑按照类别(class)的分组的内存占用字节数是不够的。你还需要将应用程序分配的对象和内存泄露的对象关联起来考虑。一个方法是更加深入查看对象的数量，以便将具有关联性的对象找出来。下面是一个具有严重内存问题的程序的转储信息：</p>

<pre><code> num     #instances         #bytes  class name
----------------------------------------------
   1:       1362278      140032936  [Ljava.lang.Object;
   2:         12624      135469922  [B
  ...
   5:        352166       45077248  com.example.ItemDetails
  ...
   9:       1360742       21771872  java.util.ArrayList
  ...
  41:          6254         200128  java.net.DatagramPacket
</code></pre>

<p>如果你仅仅去看信息的前几行，你可能会去定位<code>Object[]</code>或者<code>byte[]</code>，这些都是徒劳的。真正的问题出在ItemDetails和DatagramPacket上：前者分配了大量的ArrayList，进而又分配了大量的Object[]；后者使用了大量的byte[]来保存从网络上接收到的数据。</p>

<p>第一个问题，分配了大量的数组，实际上不是内存泄露。ArrayList的默认构造函数会分配容量是10的数组，但是程序本身一般只使用1个或者2个槽位，这对于64位JVM来说会浪费62个字节的内存空间。一个更好的涉及方案是仅仅在有需要的时候才使用List，这样对每个实例来说可以节约额外的48个字节。但是，对于这种问题也可以很轻易的通过加内存来解决，因为现在的内存非常便宜。</p>

<p>但是对于datagram的泄露就比较麻烦（如同定位这个问题一样困难）：这表明接收到的数据没有被尽快的处理掉。</p>

<p>为了跟踪问题的原因和影响，你需要知道你的程序是怎样在使用这些对象。不多的程序才会直接使用Object[]：如果确实要使用数组，程序员一般都会使用带类型的数组。但是，ArrayList会在内部使用。但是仅仅知道ArrayList的内存分配是不够的，你还需要顺着调用链往上走，看看谁分配了这些ArrayList。</p>

<p>其中一个方法是对比相关的对象数量。在上面的例子中，byte[]和DatagramPackage的关系是很明显的：其中一个基本上是另外一个的两倍。但是ArrayList和ItemDetails的关系就不那么明显了。（实际上一个ItemDetails中会包含多个ArrayList）</p>

<p>这往往是个陷阱，让你去关注那么数量最多的一些对象。我们有数百万的ArrayList对象，并且它们分布在不同的class中，也有可能集中在一小部分class中。尽管如此，数百万的对象引用是很容易被定位的。就算有10来个class可能会包含ArrayList，那么每个class的实体对象也会有十万个，这个是很容易被定位的。</p>

<p>从直方图中跟踪这种引用关系链是需要花费大量精力的，幸运的是，<em>jmap</em>不仅仅可以提供直方图，它还可以提供可以浏览的堆转储信息。</p>

<h3>堆转储分析：跟踪引用链</h3>

<p>浏览堆转储引用链具有两个步骤：首先需要使用<code>-dump</code>参数来使用<em>jmap</em>，然后需要用<em>jhat</em>来使用转储文件。如果你确定要使用这种方法，请一定要保证有足够多的内存：一个转储文件通常都有数百M，<em>jhat</em>需要好几个G的内存来处理这些转储文件。</p>

<pre><code>tmp, 517&gt; jmap -dump:live,file=heapdump.06180803 7626
Dumping heap to /home/kgregory/tmp/heapdump.06180803 ...
Heap dump file created

tmp, 518&gt; jhat -J-Xmx8192m heapdump.06180803
Reading from heapdump.06180803...
Dump file created Sat Jun 18 08:04:22 EDT 2011
Snapshot read, resolving...
Resolving 335643 objects...
Chasing references, expect 67 dots...................................................................
Eliminating duplicate references...................................................................
Snapshot resolved.
Started HTTP server on port 7000
Server is ready.
</code></pre>

<p>提供给你的默认URL显示了所有加载进系统的class，但是我觉得并不是很有用。相反，我直接使用<code>http://localhost:7000/histo/</code>，这个地址是一个直方图的视角来进行显示，并且是按照对象数量和占用的内存空间进行排序了的。</p>

<p><img src="http://shenzhang.github.io/images/2014/04/jhat-histogram-large.gif"></p>

<p>这个直方图里的每个class的名称都是一个链接，点击这个链接可以查看关于这个类型的详细信息。你可以在其中看到这个类的继承关系，它的成员变量，以及很多指向这个类的实体变量信息的链接。我不认为这个详细信息页面非常有用，而且实体变量的链接列表很占用很多的浏览器内存。</p>

<p>为了能够跟踪你的内存问题，最有用的页面是&#8217;Reference by Type&#8217;。这个页面含有两个表格：入引用和出引用，他们都被引用的数量进行排序了。点击一个类的名字可以看到这个引用的信息。</p>

<p>你可以在类的详细信息(class details)页面中找到这个页面的链接。</p>

<h3>堆转储分析：内存分配情况</h3>

<p>在大多数情况下，知道了是哪些对象消耗了大量的内存往往就可以知道它们为什么会发生内存泄露。你可以使用<em>jhat</em>来找到所有引用了他们的对象，并且你还可以看到使用了这些对象的引用的代码。但是在有些时候，这样还是不够的。</p>

<p>比如说你有关于字符串对象的内存泄露问题，那么就很有可能会花费你好几天的时间去检查所有和字符串相关的代码。要解决这种问题，你就需要能够显示内存在哪里被分配的堆转储。但是需要注意的是，这种类型的堆转储会对你的应用程序产生更多的负载，因为负责转储的代理需要记录每一个<code>new</code>操作符。</p>

<p>有许多交互式的程序可以做到这种级别的数据记录，但是我找到了一个更简单的方法，那就是使用内置的<em>hprof</em>代理来启动JVM。</p>

<pre><code>java -Xrunhprof:heap=sites,depth=2 com.kdgregory.example.memory.Gobbler
</code></pre>

<p><em>hprof</em>有许多选项：不仅仅可以用多种方式输出内存使用情况，它还可以跟踪CPU的使用情况。当它运行的时候，我指定了一个事后的内存转储，它记录了哪些对象被分配，以及分配的位置。它的输出被记录在了<code>java.hprof.txt</code>文件中，其中关于堆转储的部分如下：</p>

<pre><code>SITES BEGIN (ordered by live bytes) Tue Sep 29 10:43:34 2009
          percent          live          alloc'ed  stack class
 rank   self  accum     bytes objs     bytes  objs trace name
    1 99.77% 99.77%  66497808 2059  66497808  2059 300157 byte[]
    2  0.01% 99.78%      9192    1     27512    13 300158 java.lang.Object[]
    3  0.01% 99.80%      8520    1      8520     1 300085 byte[]
SITES END
</code></pre>

<p>这个应用程序没有分配多种不同类型的对象，也没有将它们分配到很多不同的地方。一般的转储有成百上千行的信息，显示了每一种类型的对象被分配到了哪里。幸运的是，大多数问题都会出现在开头的几行。在这个例子中，最突出的是64M的存活着的字节数组，并且每一个平均32K。</p>

<p>大多数程序中都不会一直持有这么大得数据，这就表明这个程序没有很好的抽取和处理这些数据。你会发现这常常发生在读取一些大的字符串，并且保存了substring之后的字符串：很少有人知道<code>String.substring()</code>后会共享原始字符串对象的字节数组。如果你按照一行一行地读取了一个文件，但是却使用了每行的前五个字符，实际上你任然保存的是整个文件在内存中。</p>

<p>转储文件也显示出这些数组被分配的数量和现在存活的数量完全相等。这是一种典型的泄露，并且我们可以通过搜索&#8217;trace&#8217;号来找到真正的代码：</p>

<pre><code>TRACE 300157:
    com.kdgregory.example.memory.Gobbler.main(Gobbler.java:22)
</code></pre>

<p>好了，这下就足够简单了：当我在代码中找到指定的代码行时，我发现这些数组被存放在了ArrayList中，并且它也一直没有出作用域。但是有时候，堆栈的跟踪并没有直接关联到你写的代码上：</p>

<pre><code>TRACE 300085:
    java.util.zip.InflaterInputStream.&lt;init&gt;(InflaterInputStream.java:71)
    java.util.zip.ZipFile$2.&lt;init&gt;(ZipFile.java:348)
</code></pre>

<p>在这个例子中，你需要增加堆栈跟踪的深度，并且重新运行你的程序。但是这里有一个需要平衡的地方：当你获取到了更多的堆栈信息，你也同时增加了profile的负载。默认地，如果你没有指定<code>depth</code>参数，那么默认值就会是4。我发现当堆栈深度为2的时候就可以发现和定位我程序中得大部分问题了，当然我也使用过深度为12的参数来运行程序。</p>

<p>另外一个增大堆栈深度的好处是，最后的报告结果会更加细粒度：你可能会发现你泄露的对象来自两到三个地方，并且它们都使用了相同的方法。</p>

<h3>堆转储分析：位置、地点</h3>

<p>当很多对象在分配的不久后就被丢弃时，分代垃圾搜集器就会开始运行。你可以使用同样的原则来找发现内存泄露：使用调试器，在对象被分配的地方打上断点，并且运行这段代码。在大多数时候，当它们被分配不久后就会加入到长时间存活(long-live)的集合中。</p>

<h2>永久代</h2>

<p>除了JVM中的新生代和老年代外，JVM还管理着一片叫‘永久代’的区域，它存储了class信息和字符串表达式等对象。通常，你不会观察到永久代中的垃圾回收；大多数的垃圾回收发生在应用程序堆中。但是不像它的名字，在永久代中的对象不会是永久不变的。举个例子，被应用程序classloader加载的class，当不再被classloader引用时就会被清理掉。当应用程序服务被频繁的热部署时就可能会发生：</p>

<pre><code>Exception in thread "main" java.lang.OutOfMemoryError: PermGen space
</code></pre>

<p>这一这个信息：这个不管应用程序堆的事。当应用程序堆中还有很多空间时，也有可能用完永久代的空间。通常，这发生在重新部署EAR和WAR文件时，并且永久代还不够大到可以同时容纳新的class信息和老的class信息（老的class会一直被保存着直到所有的请求在使用完它们）。当在运行处于开发状态的应用时更容易发生。</p>

<p>解决永久代错误的第一个方法就是增大永久大的空间，你可以使用<code>-XX:MaxPermSize</code>命令行参数。默认是64M，但是web应用程序或者IDE一般都需要256M。</p>

<pre><code>java -XX:MaxPermSize=256m
</code></pre>

<p>但是在通常情况下并不是这么简单的。永久代的内存泄露一般都和在应用堆中的内存泄露原因一样：在一些地方的对象引用了并不该再引用的对象。以我的经验，很有可能有些对象直接引用了一些Class对象，或者在<code>java.lang.reflect</code>包下面的对象，而不是某些类的实例对象。正式因为web引用的classloader的组织方式，通常罪魁祸首都出现在服务的配置当中。</p>

<p>例如，你使用了Tomcat，并且有一个目录里面有很多共享的jars：shared/lib。如果你在一个容器里同时运行好几个web应用，将一些公用的jar放在这个目录是很有道理的，因为这样的话这些class仅仅被加载一次，可以减少内存的使用量。但是，如果其中的一些库具有对象缓存的话，会发生什么事情呢？</p>

<p>答案是这些被缓存了的对象的类永远不会被卸载，直到缓存释放了这些对象。解决方案就是将这些库移动到WAR或者EAR中。但是在某些时候情况也不会像这么简单：<a href="http://java.sun.com/javase/7/docs/api/java/beans/Introspector.html">JDKs bean introspector</a>会缓存住由root classloader加载的<code>BeanInfo</code>对象。并且任何使用了反射的库也会缓存这些对象，这样就导致你不能直到真正的问题所在。</p>

<p>解决永久代的问题通常都是比较痛苦的。一般可以先考虑加上<code>-XX:+TraceClassLoading</code>和<code>-XX:+TraceClassUnloading</code>命令行选项以便找出那些被加载了但是没有被卸载的类。如果你加上了<code>-XX:+TraceClassResolution</code>命令行选项，你还可以看到哪些类访问了其他类，但是没有被正常卸载。</p>

<p>这里有针对这三个选项的一个实例。第一行显示了<code>MyClassLoader</code>类从classpath中被加载了。因为它又从<code>URLClassLoader</code>继承，因此我们看到了接下来的&#8217;RESOLVE&#8217;消息，紧跟着又是一条&#8217;RESOLVE&#8217;消息，说明<code>Class</code>类也被解析了。</p>

<pre><code>[Loaded com.kdgregory.example.memory.PermgenExhaustion$MyClassLoader from file:/home/kgregory/Workspace/Website/programming/examples/bin/]
RESOLVE com.kdgregory.example.memory.PermgenExhaustion$MyClassLoader java.net.URLClassLoader
RESOLVE java.net.URLClassLoader java.lang.Class URLClassLoader.java:188
</code></pre>

<p>所有的信息都在这里的，但是通常情况下将一些共享库移动到WAR/EAR中往往可以很快速的解决问题。</p>

<h2>当堆内存还有空间时发生的OutOfMemoryError</h2>

<p>就像你刚才看到的关于永久代的消息，也许应用程序堆中还有空闲空间，但是也任然可能会发生OOM。这里有几个例子：</p>

<h3>连续的内存分配</h3>

<p>当我描述分代的堆空间时，我一般会说对象会首先被分配在新生代，然后最终会被移动到老年代。但这不是绝对正确的：如果你的对象足够大，那么它就会直接被分配在老年代。一般用户自己定义的对象是不会（也不应该）达到这个临界值，但是数组却却有可能：在JDK1.5中，当数组的对象超过0.5M的时候就会被直接分配到老年代。</p>

<p>在32位机器上，0.5M换算成<code>Object[]</code>数组的话就可以包含131,072个元素。这已经是很大的了，但是在企业级的应用中这是很有可能的。特别是当使用了<code>HashMap</code>时，它经常需要重新resize自己(里面的数组数据结构)。一些应用程序可能还需要更大的数组。</p>

<p>当没有连续的堆空间来存放这些数组对象时（就算在垃圾回收并且对内存进行了紧凑之后），问题就产生了。这很少见，但是如果当前的程序已经很接近堆空间的上限时，这就变得很有可能了。增大堆空间上限是最好的解决方案，但是你也许可以试试事先分配好你的容器的大小。（后面的小对象可以不需要连续的内存空间）</p>

<h3>线程</h3>

<p>JavaDoc中对OOM的描述是，当垃圾搜集器不能在释放更多的内存空间时，JVM会抛出OOM。这里只对了一半：当JVM的内部代码收到来自操作系统的<code>ENOMEM</code>错误时，JVM也会抛出OOM。Unix程序员一般都知道，这里有很多地方可以收到<code>ENOMEN</code>错误，创建线程的过程是其中之一：</p>

<pre><code>Exception in thread "main" java.lang.OutOfMemoryError: unable to create new native thread
</code></pre>

<p>在我的32位Linux系统中，使用JDK1.5，我可以最多开启5,550个线程直到抛出异常。但是实际上在堆中任然有很多空闲空间，这是怎么回事呢？</p>

<p>在这个场景的背后，线程实际上是被操作系统所管理，而不是JVM，创建线程失败的可能原因有很多很多。在我的例子中，每一个线程都需要占用大概0.5M的虚拟内存作为它的栈空间，在5000个线程被创建之后，大约就有2G的内存空间被占用。有些操作系统就强制制定了一个进程所能创建的线程数的上限。</p>

<p>最后，针对这个问题没有一个解决方案，除非更换你的应用程序。大多数程序是不需要创建这么多得线程的，它们会将大部分的时间都浪费在等待操作系统调度上。但是有些服务程序需要创建数千个线程去处理请求，但是它们中得大多数都是在等待数据。针对这种场景，NIO和selector就是一个不错的解决方案。</p>

<h3>Direct ByteBuffers</h3>

<p>从JDK1.4之后Java允许程序程序使用<a href="http://www.kdgregory.com/index.php?page=java.byteBuffer">bytebuffers</a>来访问堆外的内存空间（受限）。虽然<code>ByteBuffer</code>对象本身很小，但是堆外的内存可不一定很小：</p>

<pre><code>Exception in thread "main" java.lang.OutOfMemoryError: Direct buffer memory
</code></pre>

<p>这里有多个原因会导致bytebuffer分配失败。通常情况下，你可能超过了最多的虚拟内存上限（仅限于32位系统），或者超过了所有物理内存和交换区内存的上限。除非你是在以很简单的方式处理超过你的机器内存上限的数据，否则你在使用direct buffer产生OOM的原因和你使用堆的原因基本上是一样的：你保持着一些你不该引用的数据。前面介绍的堆分析技术可以帮助你找到泄露点。</p>

<h3>申请的内存超过物理内存</h3>

<p>就像我前面提到的，你在启动一个JVM时，你需要指定堆的最小值和最大值。这就意味着，JVM会在运行期动态改变它对虚拟内存的需求。在一个内存受限的机器上，你可以同时运行多个JVM，甚至它们所有指定的最大值之和大于了物理内存和交换区的大小。当然，这就有可能会导致OOM，就算你的程序中存活的对象大小小于你指定的堆空间也是一样的。</p>

<p>这种情况和跑多个C++程序使用完所有的物理内存的原因是一样的。使用JVM可能会让你产生一种假象，以为不会出现这种问题。唯一的解决方案是购买更多的内存，或者不要同时跑那么多程序。没有办法让JVM可以&#8217;快速失败&#8217;；但是在Linux上你可以申请比总内存更多的内存。</p>

<h2>堆外内存的使用</h2>

<p>最后一个需要注意的问题是：Java中得堆仅仅是所占用内存的一部分。JVM还会为它所创建的线程、内部代码、工作空间、共享库、direct buffer、内存映射文件分配内存。在32位的JVM中，这所有的内存都需要被映射到2G的虚拟内存空间中，这是非常有限的（特别是对于服务端或者后端应用程序）。在64位的JVM中，虚拟内存基本没存在什么限制，但是实际的物理内存（含交换区）可能会很稀缺。</p>

<p>一般来说，虚拟内存不会造成什么大问题；操作系统和JVM可以很好的管理它们。通常情况下，你需要查看虚拟内存的映射情况主要是为了direct buffer所使用的大块的内存或者是内存映射文件。但是你还是很有必要知道什么是虚拟内存的映射。</p>

<p>要查看在Linux上的虚拟内存映射情况可以使用<a href="http://linux.die.net/man/1/pmap">pmap</a>；在Windows中可以使用<a href="http://technet.microsoft.com/en-us/sysinternals/dd535533">VMMap</a>。下面是使用pmap来dump的一个Tomcat应用。实际的dump文件有好几百行，所展示的部分仅仅是比较有意思的部分：</p>

<pre><code>08048000     60K r-x--  /usr/local/java/jdk-1.5/bin/java
08057000      8K rwx--  /usr/local/java/jdk-1.5/bin/java
081e5000   6268K rwx--    [ anon ]
889b0000    896K rwx--    [ anon ]
88a90000   4096K rwx--    [ anon ]
88e90000  10056K rwx--    [ anon ]
89862000  50488K rwx--    [ anon ]
8c9b0000   9216K rwx--    [ anon ]
8d2b0000  56320K rwx--    [ anon ]
...
afd70000    504K rwx--    [ anon ]
afdee000     12K -----    [ anon ]
afdf1000    504K rwx--    [ anon ]
afe6f000     12K -----    [ anon ]
afe72000    504K rwx--    [ anon ]
...
b0cba000     24K r-xs-  /usr/local/java/netbeans-5.5/enterprise3/apache-tomcat-5.5.17/server/lib/catalina-ant-jmx.jar
b0cc0000     64K r-xs-  /usr/local/java/netbeans-5.5/enterprise3/apache-tomcat-5.5.17/server/lib/catalina-storeconfig.jar
b0cd0000    632K r-xs-  /usr/local/java/netbeans-5.5/enterprise3/apache-tomcat-5.5.17/server/lib/catalina.jar
b0d6e000    164K r-xs-  /usr/local/java/netbeans-5.5/enterprise3/apache-tomcat-5.5.17/server/lib/tomcat-ajp.jar
b0d97000     88K r-xs-  /usr/local/java/netbeans-5.5/enterprise3/apache-tomcat-5.5.17/server/lib/tomcat-http.jar
...
b6ee3000   3520K r-x--  /usr/local/java/jdk-1.5/jre/lib/i386/client/libjvm.so
b7253000    120K rwx--  /usr/local/java/jdk-1.5/jre/lib/i386/client/libjvm.so
b7271000   4192K rwx--    [ anon ]
b7689000   1356K r-x--  /lib/tls/i686/cmov/libc-2.11.1.so
...
</code></pre>

<p>dump文件展示给你了关于虚拟内存映射的4个部分：虚拟内存地址，大小，权限，源（从文件加载的部分）。最有意思的部分是它的权限部分，它表示了该内存段是否是只读的(r-)还是读写的(rw)。</p>

<p>我会从读写段开始分析。所有的段都具有名字&#8221;[ anon ]&ldquo;，它在Linux中说明了该段不是由文件加载而来。这里还有很多被命名的读写段，它们和共享库关联。我相信这些库都具有每个进程的地址表。</p>

<p>因为所有的读写段都具有相同的名字，一次要找出出问题的部分需要花费一点时间。对于Java堆，有4个相关的大块内存被分配（新生代有2个，老年代1个，永久代1个），他们的大小由GC和堆配置来决定。</p>

<h2>其他问题</h2>

<p>这部分的内容并不是对所有地方都适用。大部分都是我解决问题的过程中总结的实际经验。</p>

<h3>不要被虚拟内存的统计信息所误导</h3>

<p>有很多抱怨说Java是&#8217;memory hog&#8217;，经常被<em>top</em>命令的&#8217;VIRT&#8217;部分和Windows任务管理器的&#8217;Mem Usage&#8217;列所证实。需要澄清的是，有太多的东西都不会算进这个统计信息中，有些还是与其他程序共享的（比如说C的库）。实际上也有很多‘空’的区域在虚拟内存映射空间中：如果你适用<code>-Xms1000m</code>来启动JVM，就算你还没有开始分配对象，虚拟内存的大小也会超过1000m。</p>

<p>一个更好的测量方法是使用驻留集的大小：你的应用程序真正使用的物理内存的页数，不包含共享页。这就是<em>top</em>命令中得&#8217;RES&#8217;列。但是，驻留集并不是对你的程序所需使用的总内存最好的测量方法。操作系统只有在你的程序真正需要使用它们的时候才会将它们放进进程的内存空间中，一般来说是在你的系统处于高负载的情况下才会出现，这会花费一段较长的时间。</p>

<p>最后：始终使用工具来提供所需的详细信息来分析Java中的内存问题。并且只有当出现OOM的时候才考虑下结论。</p>

<h3>OOM的罪魁祸首经常离它的抛出点很近</h3>

<p>内存泄露一般在内存被分配之后不久发生。一个相似的结论是，OOM的根源一般都离它的抛出点很近，可以使用堆跟踪技术来首先进行分析。其基本原理是，内存泄露一般和产生大量的内存相关联。这说明了，导致泄露的代码具有更高的失败风险率，不管是因为其内存分配代码被调用的过于频繁，还是因为每次调用都分配的过大的内存。因此，可以优先考虑使用栈跟踪来定位问题。</p>

<h3>和缓存相关的部分最值得怀疑</h3>

<p>我在这篇文章中提到缓存了很多次：在我数十年的Java工作经历中发现，和内存泄露相关的类进场都是和缓存相关的。实际上缓存是很难编写的。</p>

<p>使用缓存有很多很多很好的理由，并且使用自己写的缓存也有很多好的理由。如果你确定要使用缓存，请先回答下面的问题：</p>

<ul>
<li>哪些对象会被放进缓存？如果你所要缓存的对象都是同一种类型（或者具有继承关系），那么相比一个可以容纳各种类型的缓存来说更好跟踪问题。</li>
<li>有多少对象会被同时放进缓存？如果你像让<code>ProductCache</code>缓存1000个对象，但是在内存分析结果中发现了10000个对象，那么这之间的关系就比较好定位。如果你指定了这个缓存最多的容量上限，那么你就可以很容易的计算出这个缓存最多需要多少内存。</li>
<li>过期和清除策略是什么？每一个缓存为了控制存在于其中的对象的存货周期，都需要一个明确的驱逐策略。如果你没有指定一个明确的驱逐策略，那么有些对象就很有可能比它真正需要的存活周期要长，占用更多的内存，加重垃圾搜集器的负载（记住：在标记阶段需要的时间和存活对象的数量成正比）。</li>
<li>是否会在缓存之外同时持有这些存活对象的引用？缓存最好的应用场景是，调用频繁，并且调用时间很短，并且所缓存的对象的获取代价很大。如果你需要创建一个对象，并且在整个应用程序的生命周期中都需要引用这个对象，那么就没有必要将这个对象放入缓存（也许使用池技术可以显示总得对象数量）。</li>
</ul>


<h3>注意对象的生命周期</h3>

<p>一般来说对象可以被划分为两类：一类是伴随着整个程序的生命周期而存活；另外一来是仅仅存活并服务于一个单一的请求。搞清楚这个非常重要，你仅仅需要关心你认为是长时间存活的对象。</p>

<p>一种方法是在程序启动的时候全部初始化好所有长时间(long-lived)存活的对象，不管他们是否要立刻被用到。另外一个方法是使用依赖注入框架，比如<code>Spring</code>。这不仅仅可以很方便的bean配置文件中找到所有long-lived的对象（不需要扫描整个classpath），还可以很清楚的知道这些对象在哪里被使用。</p>

<h3>查找在方法参数中被错误使用的对象</h3>

<p>在大部分场景中，在一个方法中被分配的对象都会在方法退出的时候被清理掉（除开被返回的对象）。当你都是用局部变量来保存这些对象的时候，这个规则很容易被遵守。但是，有时候任然会使用实体变量来保存这些对象，特别是在方法中会调用大量其他方法的时候，主要是为了避免过多和麻烦的方法参数传递。</p>

<p>这样做不是一定会产生泄漏。后续的方法调用会重新对这些变量进行赋值，这样就可以让之前被创建的对象被回收。但是这样导致不必要的内存开销，并且让调试更加困难。但是从设计的角度出发，当我看到这样的代码时，我就会考虑将这个方法单独提出来形成一个独立的类。</p>

<h3>J2EE：不要滥用session</h3>

<p>session对象是用来在多个请求之间保存和共享用户相关的数据，主要是因为HTTP协议是无状态的。有时候它便成了一个用于缓存的临时性解决方案。</p>

<p>这也不是说一定就会产生泄漏，因为web容器会在一段时间后让用户的session失效。但是它却显著提高了整个程序的内存占用量，这是很糟糕的。并且它非常难调试：就像我之前提到的，很难看出对象被哪些其他的对象所持有。</p>

<h3>小心过量的垃圾搜集</h3>

<p>虽然OOM很糟糕，但是如果不停的执行垃圾搜集将会更加糟糕：它会抢走本该属于你的程序的CPU时间。</p>

<h3>有些时候你仅仅是需要更多的内存</h3>

<p>就像我在开头的地方所说的，JVM是唯一的一个让你指定你的数据最大值（内存上限）的现代编程环境。因此，会有很多时候让你以为发生了内存泄露，但是实际上你仅仅需要增加你的堆大小。解决内存问题的第一步最好还是先增加你的内存上限。如果你真的遇到了内存泄露问题，那么无论你增加了多少内存，你最后都还是会得到OOM的错误。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jcl-over-slf4j]]></title>
    <link href="http://shenzhang.github.io/blog/2014/04/13/commons-logging-over-slf4j/"/>
    <updated>2014-04-13T02:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2014/04/13/commons-logging-over-slf4j</id>
    <content type="html"><![CDATA[<p>`jcl-over-slf4j&#8217;如同名字一样就是用来将java commons logging桥接到slf4j上。现在J2EE的一个项目通常会引用五花八门的类库，不同的类库又会使用不同的日志门面系统，有的是slf4j，有的是jcl。现在随着slf4j的越来越流行，那么将系统里的所有日志系统都统一到slf4j上也成了一个很平常的需求，jcl-over-slf4j也成了项目依赖中的常客。这周和同事也讨论了该桥接类的应用，尤其是spring本身也是直接以来jcl的，其官方文档也给出了如何替换成slf4j的说明。今天看了下代码，这里做下记录。</p>

<h2>jcl的绑定流程</h2>

<p>使用jcl的标准方法如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Log</span> <span class="n">log</span> <span class="o">=</span> <span class="n">LogFactory</span><span class="o">.</span><span class="na">getLog</span><span class="o">(</span><span class="n">XXX</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>LogFactory中给出了如下绑定流程：</p>

<ol>
<li>检查系统属性<code>org.apache.commons.logging.LogFactory</code>，其中记录了具体的LogFactory的实现类。</li>
<li>通过java的service loading机制加载<code>META-INF/services/org.apache.commons.logging.LogFactory</code>配置文件，其中记录了LogFactory的实现类。</li>
<li>检查classpath中的<code>commons-logging.properties</code>配置文件，里面记录了具体的LogFactory的实现类。</li>
<li>使用jcl提供的默认实现类：<code>org.apache.commons.logging.impl.LogFactoryImpl</code>来创建Log。</li>
</ol>


<p>如果不幸进入了最后一个步骤使用<code>org.apache.commons.logging.impl.LogFactoryImpl</code>来创建Log，那么它又会使用一套发现机制类查找合适的日志实现：</p>

<ol>
<li>检查<code>org.apache.commons.logging.impl.LogFactoryImpl</code>是否已经配置了<code>org.apache.commons.logging.Log</code>属性，如果配置了该属性，则使用该属性指定的Log。</li>
<li>使用系统属性<code>org.apache.commons.logging.Log</code>中所定义的Log实现</li>
<li>检查是否存在log4j的实现类:<code>org.apache.commons.logging.impl.Log4JLogger</code>。</li>
<li>检查<code>org.apache.commons.logging.impl.Jdk14Logger</code></li>
<li>检查<code>org.apache.commons.logging.impl.Jdk13LumberjackLogger</code></li>
<li>检查<code>org.apache.commons.logging.impl.SimpleLog</code></li>
</ol>


<h2>jcl-over-slf4j桥接模式</h2>

<p>其实仔细看看jcl-over-slf4j的实现，可以发现它提供了两种桥接方法。</p>

<h3>1.引入jcl-over-slf4j并排除jcl</h3>

<p>该方法也是spring官方推荐的方法，它的实现也是很巧妙也很直接。因为我们使用jcl都是通过<code>LogFactory.getLog(XXX.class)</code>来获得Log，jcl-over-slf4j中也就提供了名称完全一样的LogFactory，只不过它的getLog方法直接通过Slf4jLogFactory返回Slf4jLog。如果在dependencies中排除掉jcl，那么所有引用jcl的地方就偷天换日的直接使用了slf4j的日志。</p>

<h3>2.引入jcl-over-slf4j并且没有排除jcl</h3>

<p>有些人可能发现如果没有在dependencies中排除掉jcl也是可以工作的，这又是为什么呢？实际上jcl-over-slf4j提供了方法1外，还参考了jcl的绑定机制，并且参考上面提到的步骤2提供了<code>META-INF/services/org.apache.commons.logging.LogFactory</code>，其中说明了jcl需要绑定的LogFactory实现是<code>org.apache.commons.logging.impl.SLF4JLogFactory</code>。这不，也委托回slf4j上让其提供Log。</p>

<p>实际上，上面的两种方法都是可以的。但是推荐使用第一种方法，因为更加直接和清晰。第二种方法会让classpath中存在两个完全同名的jcl的LogFactory，但是不论jvm加载哪一个都是OK的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[哪个更快：Java堆还是本地内存[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2014/04/13/which-one-is-faster-java-heap-or-native-memory/"/>
    <updated>2014-04-13T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2014/04/13/which-one-is-faster-java-heap-or-native-memory</id>
    <content type="html"><![CDATA[<p><a href="http://mentablog.soliveirajr.com/2012/11/which-one-is-faster-java-heap-or-native-memory/">原文链接</a></p>

<p>使用Java的一个好处就是你可以不用亲自来管理内存的分配和释放。当你用<code>new</code>关键字来实例化一个对象时，它所需的内存会自动的在Java堆中分配。堆会被垃圾回收器进行管理，并且它会在对象超出作用域时进行内存回收。但是在JVM中有一个‘后门’可以让你访问不在堆中的本地内存(native memory)。在这篇文章中，我会给你演示一个对象是怎样以连续的字节码的方式在内存中进行存储，并且告诉你是应该怎样存储这些字节，是在Java堆中还是在本地内存中。最后我会就怎样从JVM中访问内存更快给一些结论：是用Java堆还是本地内存。</p>

<h1>使用<code>Unsafe</code>来分配和回收内存</h1>

<p><code>sun.misc.Unsafe</code>可以让你在Java中分配和回收本地内存，就像C语言中的<code>malloc</code>和<code>free</code>。通过它分配的内存不在Java堆中，并且不受垃圾回收器的管理，因此在它被使用完的时候你需要自己来负责释放和回收。下面是我写的一个使用<code>Unsafe</code>来管理本地内存的一个工具类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Direct</span> <span class="kd">implements</span> <span class="n">Memory</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Unsafe</span> <span class="n">unsafe</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="n">AVAILABLE</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">static</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">Field</span> <span class="n">field</span> <span class="o">=</span> <span class="n">Unsafe</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">&quot;theUnsafe&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="n">field</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span><span class='line'>            <span class="n">unsafe</span> <span class="o">=</span> <span class="o">(</span><span class="n">Unsafe</span><span class="o">)</span><span class="n">field</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
</span><span class='line'>            <span class="n">AVAILABLE</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">// NOOP: throw exception later when allocating memory</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isAvailable</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">AVAILABLE</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Direct</span> <span class="n">INSTANCE</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Memory</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">INSTANCE</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Direct</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">INSTANCE</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="nf">Direct</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">alloc</span><span class="o">(</span><span class="kt">long</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">AVAILABLE</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">&quot;sun.misc.Unsafe is not accessible!&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">allocateMemory</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">free</span><span class="o">(</span><span class="kt">long</span> <span class="n">address</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">unsafe</span><span class="o">.</span><span class="na">freeMemory</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">long</span> <span class="nf">getLong</span><span class="o">(</span><span class="kt">long</span> <span class="n">address</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">putLong</span><span class="o">(</span><span class="kt">long</span> <span class="n">address</span><span class="o">,</span> <span class="kt">long</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">unsafe</span><span class="o">.</span><span class="na">putLong</span><span class="o">(</span><span class="n">address</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getInt</span><span class="o">(</span><span class="kt">long</span> <span class="n">address</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">putInt</span><span class="o">(</span><span class="kt">long</span> <span class="n">address</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">unsafe</span><span class="o">.</span><span class="na">putInt</span><span class="o">(</span><span class="n">address</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>在本地内存中分配一个对象</h2>

<p>让我们来将下面的Java对象放到本地内存中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SomeObject</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">long</span> <span class="n">someLong</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">someInt</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getSomeLong</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">someLong</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setSomeLong</span><span class="o">(</span><span class="kt">long</span> <span class="n">someLong</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">someLong</span> <span class="o">=</span> <span class="n">someLong</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getSomeInt</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">someInt</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setSomeInt</span><span class="o">(</span><span class="kt">int</span> <span class="n">someInt</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">someInt</span> <span class="o">=</span> <span class="n">someInt</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们所做的仅仅是把对象的属性放入到<code>Memory</code>中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SomeMemoryObject</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">someLong_OFFSET</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">someInt_OFFSET</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">SIZE</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">4</span><span class="o">;</span> <span class="c1">// one long + one int</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">long</span> <span class="n">address</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Memory</span> <span class="n">memory</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">SomeMemoryObject</span><span class="o">(</span><span class="n">Memory</span> <span class="n">memory</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">memory</span> <span class="o">=</span> <span class="n">memory</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">address</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="na">alloc</span><span class="o">(</span><span class="n">SIZE</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">finalize</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">memory</span><span class="o">.</span><span class="na">free</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">setSomeLong</span><span class="o">(</span><span class="kt">long</span> <span class="n">someLong</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">memory</span><span class="o">.</span><span class="na">putLong</span><span class="o">(</span><span class="n">address</span> <span class="o">+</span> <span class="n">someLong_OFFSET</span><span class="o">,</span> <span class="n">someLong</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">long</span> <span class="nf">getSomeLong</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">memory</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="n">address</span> <span class="o">+</span> <span class="n">someLong_OFFSET</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">setSomeInt</span><span class="o">(</span><span class="kt">int</span> <span class="n">someInt</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">memory</span><span class="o">.</span><span class="na">putInt</span><span class="o">(</span><span class="n">address</span> <span class="o">+</span> <span class="n">someInt_OFFSET</span><span class="o">,</span> <span class="n">someInt</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getSomeInt</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">memory</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="n">address</span> <span class="o">+</span> <span class="n">someInt_OFFSET</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在我们来看看对两个数组的读写性能：其中一个含有数百万的<code>SomeObject</code>对象，另外一个含有数百万的<code>SomeMemoryObject</code>对象。</p>

<pre><code>// with JIT:
Number of Objects:  1,000     1,000,000     10,000,000    60,000,000
Heap Avg Write:      107         2.30          2.51         2.58       
Native Avg Write:    305         6.65          5.94         5.26
Heap Avg Read:       61          0.31          0.28         0.28
Native Avg Read:     309         3.50          2.96         2.16


// without JIT: (-Xint)
Number of Objects:  1,000     1,000,000     10,000,000    60,000,000
Heap Avg Write:      104         107           105         102       
Native Avg Write:    292         293           300         297
Heap Avg Read:       59          63            60          58
Native Avg Read:     297         298           302         299
</code></pre>

<p><strong>结论：</strong>跨越JVM的屏障来读本地内存大约会比直接读Java堆中的内存慢10倍，而对于写操作会慢大约2倍。<em>但是需要注意的是，由于每一个SomeMemoryObject对象所管理的本地内存空间都是独立的，因此读写操作都不是连续的。</em>那么我们接下来就来对比下读写连续的内存空间的性能。</p>

<h2>访问一大块的连续内存空间</h2>

<p>这个测试分别在堆中和一大块连续本地内存中包含了相同的测试数据。然后我们来做多次的读写操作看看哪个更快。并且我们会做一些随机地址的访问来对比结果。</p>

<pre><code>// with JIT and sequential access:
Number of Objects:  1,000     1,000,000     1,000,000,000
Heap Avg Write:      12          0.34           0.35 
Native Avg Write:    102         0.71           0.69 
Heap Avg Read:       12          0.29           0.28 
Native Avg Read:     110         0.32           0.32

// without JIT and sequential access: (-Xint)
Number of Objects:  1,000     1,000,000      10,000,000
Heap Avg Write:      8           8              8
Native Avg Write:    91          92             94
Heap Avg Read:       10          10             10
Native Avg Read:     91          90             94

// with JIT and random access:
Number of Objects:  1,000     1,000,000     1,000,000,000
Heap Avg Write:      61          1.01           1.12
Native Avg Write:    151         0.89           0.90 
Heap Avg Read:       59          0.89           0.92 
Native Avg Read:     156         0.78           0.84

// without JIT and random access: (-Xint)
Number of Objects:  1,000     1,000,000      10,000,000
Heap Avg Write:      55          55              55
Native Avg Write:    141         142             140
Heap Avg Read:       55          55              55 
Native Avg Read:     138         140             138
</code></pre>

<p><strong>结论:</strong>在做连续访问的时候，Java堆内存通常都比本地内存要快。对于随机地址访问，堆内存仅仅比本地内存慢一点点，并且是针对大块连续数据的时候，而且没有慢很多。</p>

<h2>最后的结论</h2>

<p>在Java中使用本地内存有它的意义，比如当你要操作大块的数据时(>2G)并且不想使用垃圾回收器(GC)的时候。从延迟的角度来说，直接访问本地内存不会比访问Java堆快。这个结论其实是有道理的，因为跨越JVM屏障肯定是有开销的。这样的结论对使用本地还是堆的<code>ByteBuffer</code>同样适用。使用本地ByteBuffer的速度提升不在于访问这些内存，而是它可以直接与操作系统提供的本地IO进行操作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[maven杂谈(生命周期,插件绑定,effective-xx)]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/15/something-about-maven/"/>
    <updated>2013-09-15T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/15/something-about-maven</id>
    <content type="html"><![CDATA[<h2>1.生命周期</h2>

<h3>Clean</h3>

<pre><code>pre-clean
clean
post-clean
</code></pre>

<h3>Default</h3>

<pre><code>validate
initialize
generate-sources
process-sources
generate-resources
process-resources
compile
process-classes
generate-test-sources
process-test-sources
generate-test-resources
process-test-resources
test-compile
process-test-classes
test
prepare-package
package
pre-integration-test
integration-test
post-integration-test
verify
install
deploy
</code></pre>

<h3>Site</h3>

<pre><code>pre-site
site
post-site
site-deploy
</code></pre>

<h2>2.插件绑定</h2>

<p>maven在不同的生命周期中会按顺序进入不同的阶段，每个阶段又会执行与该阶段绑定的plugins。如何将plugins绑定到生命周期中呢，maven-compile-plugin又是怎么知道在每次的compile阶段执行的呢？</p>

<p>plugin绑定到生命周期中需要在pom.xml中的<build>=><plugins>中进行声明，有些是在pom.xml中，有些可能是在super pom中，有些甚至是maven默认的绑定，但是最终都会出现在effective pom中（mvn help:effective-pom查看)。</p>

<p>那么具体是在哪个阶段执行呢？看effective pom中对maven-compile-plugin的描述：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>  <span class="nt">&lt;plugin&gt;</span>
</span><span class='line'>    <span class="nt">&lt;artifactId&gt;</span>maven-compiler-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;version&gt;</span>2.3.2<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>    <span class="nt">&lt;executions&gt;</span>
</span><span class='line'>      <span class="nt">&lt;execution&gt;</span>
</span><span class='line'>        <span class="nt">&lt;id&gt;</span>default-testCompile<span class="nt">&lt;/id&gt;</span>
</span><span class='line'>        <span class="nt">&lt;phase&gt;</span>test-compile<span class="nt">&lt;/phase&gt;</span>
</span><span class='line'>        <span class="nt">&lt;goals&gt;</span>
</span><span class='line'>          <span class="nt">&lt;goal&gt;</span>testCompile<span class="nt">&lt;/goal&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/goals&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/execution&gt;</span>
</span><span class='line'>      <span class="nt">&lt;execution&gt;</span>
</span><span class='line'>        <span class="nt">&lt;id&gt;</span>default-compile<span class="nt">&lt;/id&gt;</span>
</span><span class='line'>        <span class="nt">&lt;phase&gt;</span>compile<span class="nt">&lt;/phase&gt;</span>
</span><span class='line'>        <span class="nt">&lt;goals&gt;</span>
</span><span class='line'>          <span class="nt">&lt;goal&gt;</span>compile<span class="nt">&lt;/goal&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/goals&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/execution&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/executions&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/plugin&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>主要是在phase节点和goals节点，上面的配置说明了maven-compile-plugin被分别绑定到了compile阶段和test-compile阶段，并且分别执行该插件的compile goal和testCompile goal。</p>

<p>另外有些plugin可能并没有在pom.xml中说明具体的执行阶段，那么就要看该插件中的/META-INF/maven/plugin.xml插件描述文件了，该描述文件说明了该plugin的前缀(goalPrefix)，所有的mojos或者说是goal，并且这些goal的名字以及默认的执行阶段，比如compile:testCompile节点就说明了&lt;phase&gt;test-compile&lt;/phase&gt;。因此如果没有在pom.xml中说明执行阶段的话，就按照该plugin的goal的自描述中的phase进行绑定。</p>

<h2>3.effective-xx</h2>

<p>maven有关于自己运行的配置文件settings.xml，该文件可以是$MAVEN_HOME/conf/settings.xml或者$USER/.m2/setttings.xml，并且后者会覆盖前者，可以通过mvn help:effective-settings查看相对于默认的settings.xml所改变的部分。</p>

<p>同样，前面提到的effective-pom也是由多个部分合并而来，首先是项目下的pom.xml，然后是maven的super pom($MAVEN_HOME/lib/maven-model-builder-x.x.x.jar#org/apache/maven/model/pom-x.x.x.xml)，还有一些是maven针对不同的生命周期默认绑定的插件信息($MAVEN_HOME/lib/maven-core-x.x.x.jar#/META-INF/plexus/components.xml)。最终的pom可以通过help:effective-pom查看)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[maven依赖的scope]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/13/scope-in-maven/"/>
    <updated>2013-09-13T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/13/scope-in-maven</id>
    <content type="html"><![CDATA[<p>maven中一些常用的scope及其介绍。</p>

<h3>compile:</h3>

<p>maven的默认依赖scope，并且会应用于所有的classpath，也就是说不论在compile, test compile, 还是直接用mvn来运行(runtime)都会起作用.</p>

<h3>runtime:</h3>

<p>在compile相关的阶段都不会起作用，仅仅是在运行(runtime)或者测试(test)的时候有效。</p>

<h3>provided:</h3>

<p>和compile类似，但是往往这些依赖不需要随应用一起发布，一般是由外部环境或者容器来提供，不需要自己准备，比如说servlet-api, jsp-api这些都可以由container提供。</p>

<h3>test:</h3>

<p>这个最好理解，仅仅是在测试的时候有用，compile和runtime都不需要</p>

<h3>system:</h3>

<p>有些依赖是仓库没有的，那么可以通过使用system范围来告诉maven在指定的本地路径上查找依赖。因此需要在dependency中指定systemPath元素，告诉maven依赖的具体位置。一般来说是不应该使用该范围的，很可能大家不能共享你的配置。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何针对缺少source包的jar添加source包]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/12/add-source-to-repository/"/>
    <updated>2013-09-12T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/12/add-source-to-repository</id>
    <content type="html"><![CDATA[<p>repository中的有些jar是没有对应的source的，比如在使用hadoop-core-1.0.4.jar包，但是由于缺少sources包，因此无法在依赖中查看源文件。</p>

<p>那么可以自己准备对应的源码包：hadoop-core-1.0.4-srouces.jar并安装到本地仓库中。</p>

<pre><code>mvn install:install-file -Dfile=e:\hadoop-core-1.0.4-sources.jar -DgroupId=org.apache.hadoop -DartifactId=hadoop-core -Dversion=1.0.4 -DgeneratePom=false -Dpackaging=java-source
</code></pre>

<p>注意<code>packaging=java-source</code>，不要使用<code>packaging=jar</code></p>

<p>从中我们可以推测maven打包和依赖查找的机制：</p>

<p>我们发布一个包，指定了groupId, artifacteId, version, packaging，那么maven会自动帮我们给要发布的文件重命名：</p>

<pre><code>packaging=jar =&gt; artifacteId-version.jar
packaging=java-srouce =&gt; artifacteId-version-sources.jar
packaging=java-doc =&gt; artifacteId-version-doc.jar
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[javascript测试框架jasmine]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/11/jasmine/"/>
    <updated>2013-09-11T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/11/jasmine</id>
    <content type="html"><![CDATA[<p><a href="http://pivotal.github.io/jasmine/">jasmine</a>是一个javascript的测试框架，不同于qunit等其他测试框架，它可以用于很多js环境，比如web，nodejs等。它上手简单，并且官方有很详细的实例和描述，这里将大部分实用的api和用法记录下来。</p>

<!-- more -->


<h2>一个DEMO</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">describe</span><span class="p">(</span><span class="s2">&quot;this is a test suite&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">foo</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// setup function run before every spec</span>
</span><span class='line'>  <span class="nx">beforeEach</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">foo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">foo</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="c1">// teardown function run before ever spec</span>
</span><span class='line'>  <span class="nx">afterEach</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">foo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">it</span><span class="p">(</span><span class="s2">&quot;this is a test spec 1&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">it</span><span class="p">(</span><span class="s2">&quot;this is a test spec 2&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">expect</span><span class="p">(</span><span class="kc">true</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<h2>jasmine提供的全局方法</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">describe</span><span class="p">(</span><span class="nx">testSuiteName</span><span class="p">,</span> <span class="nx">func</span><span class="p">)</span> <span class="c1">//定义一个test suite，其中可以包含it定义的spec，并且describe可以嵌套</span>
</span><span class='line'><span class="nx">xdescribe</span><span class="p">(</span><span class="nx">testSuiteName</span><span class="p">,</span> <span class="nx">func</span><span class="p">)</span> <span class="c1">//类似于JUnit的@Ignore，忽略这个test suite</span>
</span><span class='line'><span class="nx">it</span><span class="p">(</span><span class="nx">specName</span><span class="p">,</span> <span class="nx">func</span><span class="p">)</span> <span class="c1">//定义一个test unit(spec)</span>
</span><span class='line'><span class="nx">xit</span><span class="p">(</span><span class="nx">specName</span><span class="p">,</span> <span class="nx">func</span><span class="p">)</span> <span class="c1">//类似于@Ignore，忽略这个unit</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">actualValue</span><span class="p">)</span> <span class="c1">//assert</span>
</span><span class='line'><span class="nx">beforeEach</span><span class="p">(</span><span class="nx">func</span><span class="p">)</span> <span class="c1">//定义一个start function，在每个unit之前运行</span>
</span><span class='line'><span class="nx">afterEach</span><span class="p">(</span><span class="nx">func</span><span class="p">)</span> <span class="c1">//定义一个deardown function, 在每个unit之后运行</span>
</span><span class='line'><span class="nx">spyOn</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">funcName</span><span class="p">)</span> <span class="c1">//监视obj.funcName函数的调用情况</span>
</span><span class='line'>
</span><span class='line'><span class="nx">runs</span><span class="p">(</span><span class="nx">fun</span><span class="p">)</span>
</span><span class='line'><span class="nx">waitsFor</span><span class="p">(</span><span class="nx">fun</span><span class="p">,</span> <span class="nx">msg</span><span class="p">,</span> <span class="nx">timeout</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nx">jasmine</span><span class="p">.</span><span class="nx">createSpy</span><span class="p">(</span><span class="nx">spyName</span><span class="p">)</span> <span class="c1">//定义一个spy函数，该函数可以被任意调用，主要用于mock</span>
</span><span class='line'><span class="nx">jasmine</span><span class="p">.</span><span class="nx">createSpyObj</span><span class="p">(</span><span class="nx">objName</span><span class="p">,</span> <span class="nx">spyFuncNames</span><span class="p">)</span> <span class="c1">//定义一个spy对象，并且该对象具有spyFuncNames数组包含的方法。主要用于mock</span>
</span><span class='line'><span class="nx">jasmine</span><span class="p">.</span><span class="nx">any</span><span class="p">(</span><span class="nx">construct</span><span class="o">|</span><span class="nx">className</span><span class="p">)</span> <span class="c1">//配合expect使用，检测该对象是否是指定类型，如：expect(12).toEqual(jasmine.any(Number));</span>
</span><span class='line'><span class="nx">jasmine</span><span class="p">.</span><span class="nx">Clock</span><span class="p">.</span><span class="nx">useMock</span> <span class="c1">//启用模拟timer</span>
</span><span class='line'><span class="nx">jasmine</span><span class="p">.</span><span class="nx">Clock</span><span class="p">.</span><span class="nx">tick</span> <span class="c1">//手动触发一个timer事件</span>
</span></code></pre></td></tr></table></div></figure>


<h2>expectation api</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">//a === b</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">not</span><span class="p">.</span><span class="nx">toBe</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">//!(a===b)</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">//a是否和b相等，可以比较普通类型或者对象</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toMatch</span><span class="p">(</span><span class="nx">reg</span><span class="p">)</span> <span class="c1">//a是否符合reg的正则表达式</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeDefined</span><span class="p">()</span> <span class="c1">//o.a是否被定义</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeUnDefined</span><span class="p">()</span> <span class="c1">//o.a是否没有被定义</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeNull</span><span class="p">()</span> <span class="c1">//a === null ?</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeTruthy</span><span class="p">()</span> <span class="c1">//if (a) 是否成立</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeFalsy</span><span class="p">()</span> <span class="c1">//if (!a) 是否成立</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">array</span><span class="p">).</span><span class="nx">toContain</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">//数组array里是否有b</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeLessThan</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">//a &lt; b ?</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeGreaterThan</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">//a &gt; b?</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">func</span><span class="p">).</span><span class="nx">toThrow</span><span class="p">()</span> <span class="c1">//func被调用的时候是否抛出异常</span>
</span></code></pre></td></tr></table></div></figure>


<h2>spy</h2>

<p>jasmine可以对指定的函数进行调用监视，相关的函数有spyOn, jasmine.createSpy(), jasmine.createSpyObj()，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">hello</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello world&#39;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">spyOn</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么对obj.hello的调用都会被jasmine截获，但是实际上是不会真正调用obj.hello的，除非：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">sypOn</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">).</span><span class="nx">andCallThough</span><span class="p">()</span> <span class="c1">// 调用obj.hello()时，最终会真正调用console.log</span>
</span><span class='line'>
</span><span class='line'><span class="nx">spyOn</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">).</span><span class="nx">andReturn</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span> <span class="err">让</span><span class="nx">obj</span><span class="p">.</span><span class="nx">hello</span><span class="p">()</span><span class="err">永远返回</span><span class="mi">123</span>
</span><span class='line'>
</span><span class='line'><span class="nx">spyOn</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">).</span><span class="nx">andCallFake</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>             <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;welcome&#39;</span><span class="p">);</span>
</span><span class='line'>          <span class="p">});</span>  <span class="c1">// 该方法会让obj.hello()委派到console.log(&#39;welcome&#39;)上，也就是执行提供的函数内容。</span>
</span></code></pre></td></tr></table></div></figure>


<p>从此可以看出Jasmine确实考虑的非常周到</p>

<h2>expectation for spy</h2>

<p>以下expect要配合spyOn, jasmine.createSpy(), jasmine.createSpyObj()来使用</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">spyOn</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="s1">&#39;setBar&#39;</span><span class="p">);</span> <span class="c1">// 监视foo.setBar方法</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">setBar</span><span class="p">).</span><span class="nx">toHaveBeenCalled</span><span class="p">()</span><span class="o">:</span> <span class="err">该方法是否被调用过</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">setBar</span><span class="p">.</span><span class="nx">calls</span><span class="p">.</span><span class="nx">length</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">:</span> <span class="err">该方法是否被调用了两次</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">setBar</span><span class="p">).</span><span class="nx">toHaveBeenCalledWith</span><span class="p">(</span><span class="mi">456</span><span class="p">,</span> <span class="s1">&#39;another param&#39;</span><span class="p">)</span><span class="o">:</span> <span class="err">该方法是否被调用过，并且调用的参数是</span><span class="o">:</span><span class="mi">456</span><span class="err">和</span><span class="s1">&#39;another param&#39;</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">setBar</span><span class="p">.</span><span class="nx">mostRecentCall</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]).</span><span class="nx">toEqual</span><span class="p">(</span><span class="mi">456</span><span class="p">)</span><span class="o">:</span> <span class="err">最近一次调用的第一个参数是否是</span><span class="mi">456</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">setBar</span><span class="p">.</span><span class="nx">calls</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]).</span><span class="nx">toEqual</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span><span class="o">:</span> <span class="err">第一次调用的第一个参数是否是</span><span class="mi">123</span>
</span></code></pre></td></tr></table></div></figure>


<h2>HTML Reporter</h2>

<p>jasmine还可以控制执行以及测试结果的输出，比如下面的代码就是将测试报告输出到html页面上：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">jasmineEnv</span> <span class="o">=</span> <span class="nx">jasmine</span><span class="p">.</span><span class="nx">getEnv</span><span class="p">();</span>
</span><span class='line'>  <span class="nx">jasmineEnv</span><span class="p">.</span><span class="nx">updateInterval</span> <span class="o">=</span> <span class="mi">250</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">htmlReporter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">jasmine</span><span class="p">.</span><span class="nx">HtmlReporter</span><span class="p">();</span>
</span><span class='line'>  <span class="nx">jasmineEnv</span><span class="p">.</span><span class="nx">addReporter</span><span class="p">(</span><span class="nx">htmlReporter</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">jasmineEnv</span><span class="p">.</span><span class="nx">specFilter</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">htmlReporter</span><span class="p">.</span><span class="nx">specFilter</span><span class="p">(</span><span class="nx">spec</span><span class="p">);</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">currentWindowOnload</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span><span class="p">;</span>
</span><span class='line'>  <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">currentWindowOnload</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">currentWindowOnload</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;.version&#39;</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">jasmineEnv</span><span class="p">.</span><span class="nx">versionString</span><span class="p">();</span>
</span><span class='line'>    <span class="nx">execJasmine</span><span class="p">();</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">function</span> <span class="nx">execJasmine</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">jasmineEnv</span><span class="p">.</span><span class="nx">execute</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">})();</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SeaJS原理解析]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/10/inspect-seajs/"/>
    <updated>2013-09-10T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/10/inspect-seajs</id>
    <content type="html"><![CDATA[<p>对于前台javascript代码的模块化组织和依赖加载目前业界比较流行的有RequireJS和玉伯写的的SeaJS。看了下玉伯本人对这两款模块加载器的对比分析，个人还是比较喜欢SeaJS的，尤其是RequireJS在加载一个模块后就立刻执行的做法表示不能理解，可能也跟具体的应用场景有关系，不能用SeaJS的风格来使用RequireJS吧。</p>

<p>今天粗略看了下SeaJS的源码，不对源码的细节进行分析，仅仅对其模块的组织和加载原理做简单的分析，知道了原理剩下的就是代码效率和浏览器兼容性的问题了。</p>

<p>主要解决一下问题：</p>

<ol>
<li>怎么用SeaJS</li>
<li>怎么解析、加载和执行模块</li>
<li>模块标识符（依赖名）的path解析</li>
</ol>


<!--more-->


<h2>怎么用SeaJS</h2>

<p>模块A:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">define</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">require</span><span class="p">,</span> <span class="nx">exports</span><span class="p">,</span> <span class="nx">module</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">addModule</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;add&#39;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">exports</span><span class="p">.</span><span class="nx">hello</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello &#39;</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="s1">&#39;, 1 + 3 = &#39;</span> <span class="o">+</span> <span class="nx">addModule</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>模块add：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">define</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">require</span><span class="p">,</span> <span class="nx">exports</span><span class="p">,</span> <span class="nx">module</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">exports</span><span class="p">.</span><span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>页面入口:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>[html]
</span><span class='line'><span class="cp">&lt;!doctype html&gt;</span>
</span><span class='line'><span class="nt">&lt;html&gt;</span>
</span><span class='line'><span class="nt">&lt;head&gt;</span>
</span><span class='line'>  <span class="nt">&lt;title&gt;</span>seajs demo<span class="nt">&lt;/title&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span> <span class="na">src=</span><span class="s">&quot;lib/sea-debug.js&quot;</span> <span class="na">id=</span><span class="s">&quot;seajsnode&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</span><span class='line'>  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nx">seajs</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">A</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">A</span><span class="p">.</span><span class="nx">hello</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="nt">&lt;/script&gt;</span>
</span><span class='line'><span class="nt">&lt;/head&gt;</span>
</span><span class='line'><span class="nt">&lt;body&gt;</span>
</span><span class='line'><span class="nt">&lt;/body&gt;</span>
</span><span class='line'><span class="nt">&lt;/html&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>是不是很简单，这就是一个典型的模块依赖问题: A是页面入口模块，A->add模块。</p>

<h2>怎么解析、加载和执行模块</h2>

<p>不管是用seajs.use也好，还是在module中使用require也好，都是在告诉seajs去加载一个指定的模块，而且中本质上来说都是异步递归加载的，特别是:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">seajs</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="s1">&#39;module&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">entry</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="p">...</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种形式一看就知道是异步加载。但是在module中:<code>var m = require('mmm');</code>却让人感觉是同步加载，实际上不是这样的，当在模块里调用require时，对应的module文件都已经被load并执行了。</p>

<p>如果moduleA->moduleB，那么流程实际上是这样的：</p>

<p>1.通过fetch函数去加载moduleA</p>

<p>2.加载回来后肯定浏览器会自动执行define(factory)语句，在seajs流程里叫做解析(resolve)，但是factory方法不会被立刻调用(execute)。</p>

<p>3.seajs拿到factory方法，并调用factory.toString()来拿到方法体，通过一个很长的正则表达式提取出其中的require语句(因此seajs对require的写法要求很严格，并且require的模块名参数只能是字符串直接量)，进而拿到moduleA所依赖的所有module(moduleB)。保存moduleA的信息，比如说factory，准备加载moduleB。</p>

<p>4.开始加载moduleB，加载过程同moduleA，但是最后当拿到moduleB的factory方法，并进行依赖的进一步解析时，发现moduleB没有进一步的依赖了，就开始进入执行(execute)过程。</p>

<p>5.经过一系列的递归加载，可以说形成了一个加载栈，execute的过程实际上是从找execute入口函数的过程。回退栈（模块有依赖关系，栈的回退就是依赖的反向关系），直到发现有一个module对象有callback属性，然后就开始执行这个callback。实际上这个有callback属性的module就是seajs的启动方法，或者说use方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// Use function is equal to load a anonymous module</span>
</span><span class='line'><span class="nx">Module</span><span class="p">.</span><span class="nx">use</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">ids</span><span class="p">,</span> <span class="nx">callback</span><span class="p">,</span> <span class="nx">uri</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">mod</span> <span class="o">=</span> <span class="nx">Module</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">uri</span><span class="p">,</span> <span class="nx">isArray</span><span class="p">(</span><span class="nx">ids</span><span class="p">)</span> <span class="o">?</span> <span class="nx">ids</span> <span class="o">:</span> <span class="p">[</span><span class="nx">ids</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">mod</span><span class="p">.</span><span class="nx">callback</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">exports</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">uris</span> <span class="o">=</span> <span class="nx">mod</span><span class="p">.</span><span class="nx">resolve</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">uris</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">exports</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">cachedMods</span><span class="p">[</span><span class="nx">uris</span><span class="p">[</span><span class="nx">i</span><span class="p">]].</span><span class="nx">exec</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">callback</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">global</span><span class="p">,</span> <span class="nx">exports</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">delete</span> <span class="nx">mod</span><span class="p">.</span><span class="nx">callback</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">mod</span><span class="p">.</span><span class="nx">load</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，只有使用use方法加载的module才有callback属性，并且一旦callback被调用之后就会delete mod.callback来删除该属性(比如A同时依赖B和C，那么就会出现两个加载栈，回溯的时候这个callback就会被掉用两次，因此第一次调用之后就会被delete掉。那seajs是如何保证callback被调用的时候所有的依赖都已经加载完毕了呢？实际上seajs的每个模块不但有依赖关系，还有依赖关系的计数，也就是如果A->B,B同时依赖C和D，那么B的依赖计数就是2，每当C或者D被加载完毕后都会让B的计数减1，直到为0的时候B才会去通知A。因此，当callback被调用的时候，其下的所有依赖模块都已经是被resolve完毕的。</p>

<p>6.当进入到execute流程时，所有的模块不是集中被execute的，而是当遇到require(&lsquo;moduleX&rsquo;)的时候才会去检查moduleX是否被execute，如果已经被其他时序execute过了，那么就直接返回上次execute后的结果（模块exports对象）；如果没有，则开始第一次execute过程，execute过程实际上就是调用该模块的factory方法的过程，也是模块被真正定义和接口被exports的过程，由于仅仅是方法调用，因此是同步执行的(var x = require(&lsquo;moduleX&rsquo;)仅仅是个执行factory方法的过程，不涉及异步load）。</p>

<p><em>OK，流程就是这样了，但是需要强调几个事情：</em></p>

<p>a.seajs加载模块的方法就是往head头插入script节点的方法</p>

<p>b.创建和插入的script元素被设置了async=true属性，因此同一层次的所有依赖module可以并行下载</p>

<p>c.模块的解析和execute过程中间都有缓存机制，不会出现重复加载和执行的现象。</p>

<p>d.seajs是如何知道一个模块加载完毕了？看下面的代码就明白了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'>  <span class="nx">node</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">READY_STATE_RE</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">readyState</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// Ensure only run once and handle memory leak in IE</span>
</span><span class='line'>      <span class="nx">node</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kc">null</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// Remove the script to reduce memory leak</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isCSS</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">data</span><span class="p">.</span><span class="nx">debug</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">head</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// Dereference the node</span>
</span><span class='line'>      <span class="nx">node</span> <span class="o">=</span> <span class="kc">null</span>
</span><span class='line'>
</span><span class='line'>      <span class="nx">callback</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>模块标识符（依赖名）的path解析</h2>

<p>很多人对seajs的模块标识符解析有点迷糊，实际上该过程是被封装在了id2Uri(id, refUri)方法中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">id2Uri</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">refUri</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">id</span><span class="p">)</span> <span class="k">return</span> <span class="s2">&quot;&quot;</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">id</span> <span class="o">=</span> <span class="nx">parseAlias</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
</span><span class='line'>  <span class="nx">id</span> <span class="o">=</span> <span class="nx">parsePaths</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
</span><span class='line'>  <span class="nx">id</span> <span class="o">=</span> <span class="nx">parseVars</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
</span><span class='line'>  <span class="nx">id</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">uri</span> <span class="o">=</span> <span class="nx">addBase</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">refUri</span><span class="p">)</span>
</span><span class='line'>  <span class="nx">uri</span> <span class="o">=</span> <span class="nx">parseMap</span><span class="p">(</span><span class="nx">uri</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="nx">uri</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>大致过程如下：</p>

<p>1.检查别名,这个在config中配置</p>

<p>2.path检查</p>

<p>3.路径中的变量替换</p>

<p>4.标准化路径，可以理解成将/a/b/c改为/a/b/c.js</p>

<p>5.合成完整路径，addBase:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">addBase</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">refUri</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">ret</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">first</span> <span class="o">=</span> <span class="nx">id</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Absolute</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nx">ABSOLUTE_RE</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">id</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">ret</span> <span class="o">=</span> <span class="nx">id</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// Relative</span>
</span><span class='line'>  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">first</span> <span class="o">===</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">ret</span> <span class="o">=</span> <span class="nx">realpath</span><span class="p">((</span><span class="nx">refUri</span> <span class="o">?</span> <span class="nx">dirname</span><span class="p">(</span><span class="nx">refUri</span><span class="p">)</span> <span class="o">:</span> <span class="nx">data</span><span class="p">.</span><span class="nx">cwd</span><span class="p">)</span> <span class="o">+</span> <span class="nx">id</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// Root</span>
</span><span class='line'>  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">first</span> <span class="o">===</span> <span class="s2">&quot;/&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">cwd</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">ROOT_DIR_RE</span><span class="p">)</span>
</span><span class='line'>    <span class="nx">ret</span> <span class="o">=</span> <span class="nx">m</span> <span class="o">?</span> <span class="nx">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">id</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="nx">id</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// Top-level</span>
</span><span class='line'>  <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">ret</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">base</span> <span class="o">+</span> <span class="nx">id</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="nx">ret</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>6.map替换</p>

<p>最后的id就是解析的结果</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[setTimeout和setInterval]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/05/settimeout-and-setinterval/"/>
    <updated>2013-09-05T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/05/settimeout-and-setinterval</id>
    <content type="html"><![CDATA[<p>setTimeout和setInterval是浏览器环境中两个可用的定时器方案。在使用过程中曾经遇到了两个坑，在这里记录下：</p>

<h3>setInterval:</h3>

<p>可以定期按照一定的频率做一个事情，比如funA。但是如果funA中抛出了异常会怎样呢？  firefox和chrome不会因为抛出异常而做出什么奇怪的事情，毕竟调用setInterval只是告诉浏览器我要定期做一个事情，哪怕这个事情出错了；但是IE却在出现异常后停止继续定期做这个事情，所以千万要保证funA中的事情一定不要有异常出现。</p>

<h3>setTimeout:</h3>

<p>延时一段时间做某个事情funcB。比如：</p>

<p>setTimeout(tick, 1000)会在1秒之后将tick加入到事件队列中准备执行，并且tick方法的arguments是空的，但是在firefox13以下的tick的arguments却不一定是空的，有可能会有一个表示延时时间的数值(小于0)来表示执行该函数比预期时间推后了多少。新版本的firefox已经解决了该问题，但是还是不要试图在tick方法中根据arguments的数量来决定行为。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thread的状态]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/04/status-of-thread/"/>
    <updated>2013-09-04T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/04/status-of-thread</id>
    <content type="html"><![CDATA[<p>每个Thread在创建出来之后就有一个状态信息，可以通过Thread.getState()来获得该thread的状态，虽然javadoc中对thread的状态有详细的描述，但是很多人还是不能很好的说出所有的状态，以及不同状态的含义，理解这些状态还有助于使用java的线程分析工具，比如jstack</p>

<p>Thread的状态是由Thread.State枚举表示的，有下面的6个值：</p>

<h3>NEW</h3>

<p>当线程刚被new出来，并且没有start的时候处于NEW状态</p>

<h3>BLOCKED</h3>

<p>线程被阻塞，一般是由于锁的原因等待进入临界区时候的状态</p>

<h3>RUNNABLE</h3>

<p>正在运行，就算是没有获得CPU时间片的线程也是在RUNNABLE</p>

<h3>WAITING</h3>

<p>顾名思义，线程处于等待状态。它正在等待其他的操作被触发，比如wait()后等待notify()或者notifyAll()；Thread.join()后等待目标线程被结束；LockSupport.park()后等待LockSupport.unpark()。</p>

<p>注意，在调用wait()后会首先进入WAITING状态，如果被notify()了，并且无法获得锁并进入临界区，那么就在BLOCKED；如果进入临界区了，那么就是RUNNABLE</p>

<h3>TIMED_WAITING</h3>

<p>相比WAITING状态，只是多了一个时间参数，比如Thread.sleep(10)，object.wait(10)等等。</p>

<h3>TERMINATED</h3>

<p>运行完毕</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解GC暂停 - Hotspot中的minor gc[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2013/08/16/gc-stop-minor-gc-in-hotspot/"/>
    <updated>2013-08-16T02:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/08/16/gc-stop-minor-gc-in-hotspot</id>
    <content type="html"><![CDATA[<p><a href="http://blog.ragozin.info/2011/06/understanding-gc-pauses-in-jvm-hotspots.html">原文链接</a></p>

<p>当JVM进行垃圾搜集的时候会Stop-The-World暂停，它们是java应用程序的天敌。Hotspot JVM多种先进的、被优化的垃圾收集器，但是要想找到一个最优的配置需要首先了解垃圾搜集算法的机制。这篇文章介绍了GC在STW时怎么使用CPU，并且还介绍了一个新生代的垃圾搜集算法。</p>

<h2>堆结构</h2>

<p>大多数现代GC算法都是分代收集的，这意味着java的堆被划分为了多个空间。不同的空间用其中保存的对象的年龄划分。对象首先被分配到新生代，然后经过多次存活后，最终被放到了老年代。这个是基于“大多数的对象在创建后很快就会消亡”的假设。所有的Hotspot垃圾收集器都将内存划分为5个部分（对于G1收集器，空间可能不是连续的）。</p>

<p><img src="http://shenzhang.github.io/images/2013/08/java_heap_struct.png"></p>

<ol>
<li>Eden:eden区是对象被分配的地方</li>
<li>Survivor: Survivor区被用来在young gc或者minor gc中接收存活的对象</li>
<li>Tenured:Tenured区是保存长时间存活的对象</li>
<li>Permanent:Permanent是供JVM自己使用，比如classes或者被JIT编译后的代码，它的行为和tenured区类似，因此在文章的后面我们将忽略该区域。</li>
</ol>


<p>Eden和2个Survivor区在一起被称作新生代（yound space)。</p>

<h3>Hotspot GC算法</h3>

<ol>
<li>串行垃圾收集(-XX:+UseSerialGC)</li>
<li>新生代并行，老年代串行的分代收集(-XX:+UseParallelGC)</li>
<li>新生代和老年代都并行的分代收集(-XX:+UseParallelOldGC)</li>
<li>CMS收集算法和串行化的新生代收集器(-XX:+UseConcMarkSweep, -XX:-UseParNewGC)</li>
<li>CMS收集算法和并行化的新生代收集器(-XX:+UseConcMarkSweep, -XX:+UseParNewGC)</li>
<li>G1收集算法(-XX:+UseG1GC)</li>
</ol>


<p>除了G1之外，其他所有的垃圾收集算法在新生代部分都使用了类似的算法（串行或者并行）</p>

<h3>写屏障(Write barrier)</h3>

<p>分代垃圾收集器的关键点在于，是否有必要每次都对整个java堆进行垃圾收集，还是对其中的一部分进行收集（比如新生代)。但是JVM为了实现这个效果，需要实现一个特殊的机制“写屏障”。在Hotspot中实现了两种类型的写屏障：dirty cards和snaphot-at-the-beginning(SATB)。SATB被用于G1算法中（该文没有对其描述）。其他所有的垃圾收集算法都使用dirty cards。</p>

<h3>Dirty cards写屏障(卡片标记)</h3>

<p>Dirty cards写屏障的原理非常简单。每当应用程序改变内存中的引用时，都需要标记该内存页是脏(dirty)的。JVM中有一个特殊的卡片表(card table)，每512字节的页都对应其中的1个字节。</p>

<p><img src="http://shenzhang.github.io/images/2013/08/card-table.png"></p>

<h3>新生代垃圾收集算法</h3>

<p>绝大部分的对象会被首先分配到eden区（除了在一些特殊的情况下，对象可能会直接被分配到老年代）。为了更高效的分配内存，Hotspot使用了线程本地分配块（thread local allocation block, TLAB)来分配新的对象，但是TLAB本身又被分配在eden区。一旦eden区满了就会触发minor gc。minor gc的目标是清理eden区，释放内存。在这里使用的是拷贝算法，存活的对象被拷贝到另外的一块区域，之前的区域的所有空间被标记为可用（free）。但是在开始垃圾收集之前，JVM首先需要找到根（root）引用，所有用于minor gc的根引用是来自堆栈的引用或者来自老年代的引用。</p>

<p>通常情况下，搜集来自于老年代的引用需要扫描整个老年代对象的所有引用，因此我们需要写屏障（write-barrier）。所有在新生代中的对象都是在上次写屏障被复位之后分配的，也就意味着非脏(no-dirty)页是不可能引用新生代的对象，最后意味着我们没必要扫描整个老年代，而只需要扫描dirty pages中的对象即可。</p>

<p><img src="http://shenzhang.github.io/images/2013/08/dirty-pages.png"></p>

<p>最开始的dirty cards是空的，并且开始young gc后，JVM拷贝eden和其中一个survivor中存活的对象到另外一个survivor区。JVM只需要花费时间在存活对象上，拷贝和再分配（relocate）对象也需要更新指向它们的引用。</p>

<p><img src="http://shenzhang.github.io/images/2013/08/dirty-pages1.png"></p>

<p>当JVM更新移动后的对象的引用时，内存也同时也被修改了，自然会打上dirty的标记。最终在我们下次开始young gc的时候，只有位于dirty pages中的页才有可能引用新生代的对象。</p>

<p><img src="http://shenzhang.github.io/images/2013/08/dirty-pages2.png"></p>

<h3>对象升级</h3>

<p>如果对象没有在young gc中被清除，那么最终会被拷贝到老年代。对象升级会在下述情况下发生：</p>

<ol>
<li>-XX:+AlwaysTenure:让JVM直接将eden中的对象升级到老年代，而不通过survivor区（survivor区在这里不再使用）</li>
<li>其中一个survivor区已经满了，那么所有剩下的存活对象都直接升级到老年代。</li>
<li>如果对象在新生代的垃圾收集中存活了足够多的周期，就会被升级到老年代（存活周期数通过–XX:MaxTenuringThreshol选项和-XX:TargetSurvivorRatio选项调整）</li>
</ol>


<h3>对象直接被分配到老年代</h3>

<p>如果我们可以将存活时间较长的对象直接分配到老年代，那么我们会获得性能提升。但是很不幸，我们无法告诉JVM这么做。但是仍然还是有一些情况，对象可以直接被分配到老年代：</p>

<ol>
<li>-XX:PretenureSizeThreshold=<n>：告诉JVM如果对象的大小大于<n>时，就可以直接将该对象分配到老年代。</li>
<li>如果对象的大小大于了eden区，那么也会直接分配到老年代。</li>
</ol>


<p>不同于应用程序对象，系统级的对象会直接分配到永久带。</p>

<h3>并行执行</h3>

<p>在young gc中的大部分任务都可以并行执行。如果有多个CPU可用，那么JVM可以充分利用它们以减少STW的时间。可以通过选项–XX:ParallelGCTreads=<n>来告诉JVM使用多少个线程来执行GC。默认情况下，JVM会使用当前可用的CPU数量作为GC的线程数。但是串行版的收集器会忽律给选项，因为它只使用一个CPU线程。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解GC暂停 - Hotspot中的CMS[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2013/08/16/gc-stop-cms-in-hotspot/"/>
    <updated>2013-08-16T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/08/16/gc-stop-cms-in-hotspot</id>
    <content type="html"><![CDATA[<p><a href="http://blog.ragozin.info/2011/06/understanding-gc-pauses-in-jvm-hotspots_02.html">原文链接</a></p>

<p>Concurrent-Mark-Sweep(CMS)是Hotspot JVM中的一个短停顿垃圾回收器。CMS在回收内存时做的大部分工作都可以和应用程序并发执行（不用暂停应用程序）。但是仍然需要短暂的Stop-The-World暂停。这篇文章会介绍这个暂停的原因以及如何减少这样的暂停。</p>

<h2>CMS基础</h2>

<p>Hotspot中的CMS收集器是分代搜集的，因此整个java堆被分为了新生代和老年代，并且它们可以独立进行搜集。对于新生代Hotspot通常使用的是拷贝算法。要想开启CMS收集器，需要在命令行参数里指定-XX:+UseConcMarkSweepGC选项。</p>

<p>CMS被用来搜集老年代，一个CMS搜集周期包括以下阶段：</p>

<ol>
<li>Inital mark:CMS在这个阶段搜集所有的根(root)引用，并且是STW的。</li>
<li>Concurrent mark:这个阶段会与应用程序并发执行，在该阶段垃圾收集器会遍历老年代的所有对象(从root开始)，将存活的对象标记出来。</li>
<li>Concurrent pre clean:这是另外一个并发阶段，主要也是用于标记操作，它会找到从上次标记(mark)之后改变了的引用。这个阶段最主要的目的是减少remark阶段的STW时间。</li>
<li>Remark：一旦Concurrent mark结束了，垃圾收集器需要进入STW暂停，在暂停的时候找到所有从上次mark之后所有被改变了的引用。</li>
<li>Concurrent sweep:垃圾收集器在该阶段会扫描整个老年代，并且回收不再使用的内存。</li>
<li>Concurrent reset：在CMS周期结束后，一些数据结构需要在下次周期开始之前被重置。</li>
</ol>


<p>不同于其他大多数垃圾收集器，CMS不会对老年代的堆内存进行整理。CMS没有对内存对象进行移动以便让为使用的空间保持连续，它会维护所有空闲内存段的列表。这样CMS避免了对内存重新布局的开销（对内存重新布局需要STW），但是负面效果就是会产生内存碎片。为了减少产生内存碎片的风险，CMS会对对象尺寸进行统计，并且针对对象的不同尺寸来维护空闲列表。</p>

<h2>CMS暂停时间</h2>

<p>CMS本身只有两个暂停点，但是你的应用程序执行新生代的垃圾回收时同样会进行暂停。</p>

<h2>Inital mark</h2>

<p>在inital mark阶段，CMS会遍历老年代的所有根引用。这包括：</p>

<ol>
<li>来自于线程栈的引用</li>
<li>来自于新生代的引用</li>
</ol>


<p>来自于线程栈的引用会搜集的很快（不超过1毫秒），但是搜集来自于新生代的引用就依赖于新生代对象的多少了。通常inital mark会在新生代gc完毕后开始，所以eden区这个时候时空的，并且其中一个survivor区里面也仅仅包含了存活下来的对象。Survivor区通常很小，因此在young gc完成后执行inital mark会很快，不超过毫秒。但是，如果inital mark在eden区满的时候开启，那么将会花费很长的时间（往往比young gc本身都还要长）</p>

<p>一旦CMS收集器被触发了，JVM会等待一段时间，让young gc完成后再开始inital mark。JVM配置参数-XX:CMSWaitDuration=<t>可以用来配置CMS等待多长时间才开始inital mark。如果你不希望长时间的inital mark暂停，那么你可以配置该选项，让等待时间略微长于你的应用中执行一次young gc所需要的时间。</p>

<h2>Remark</h2>

<p>大多数的标记（marking）可以和应用程序并行执行，但是也不是绝对的，因为有可能应用会在mark阶段修改对象引用图。当concurrent mark结束后，垃圾收集器会暂停应用程序，并且进行重复的标记以保证所有可达的的对象都已经标记为存活状态。但是收集器不需要遍历整个对象图，它仅仅需要遍历哪些自从上次标记（marking）阶段之后被修改过的引用（确切的说是从上次pre clean阶段之后）。卡片表（card table)被用来标记那些老年代中被修改的内存区域，但是新生代和堆栈部分还是需要被重新扫描一遍。</p>

<p>通常情况下remark阶段大部分时间被花费在了扫描新生代部分。如果在开始remark之前对新生代进行了gc，那么这个时间会大大缩短。我们可以加上-XX:+CMSScanvengeBeforeRemark选项来让JVM在开始remark之前强制进行新生代的gc。就算新生代是空的，remark阶段还是会对老年代中已经修改的引用进行扫描，这个所花费的时间和新生代gc暂停时间差不多。</p>

<h2>什么时候会触发CMS</h2>

<p>不同于其他老年代STW收集器，CMS搜集周期在老年代满了之前就需要开始（其他老年代收集器只需要老年代满的时候出发，而CMS需要在老年代没满的时候就触发）。CMS收集器在老年代的可用空间达到一定的阈值时（这个阈值可根据JVM在运行中搜集的统计信息或者参数来决定），并且CMS可能会推迟到下一次young gc触发之后才开始。普通的对象只会在yong gc的过程中被分配到老年代，因此CMS一般是在yong gc发生之后才开始，并且这样也会让initial mark变得很小。但是在某些情况下，对象可能会直接被分配在老年代，并且CMS开始的时候eden区可能具有很多对象。这个时候inital mark会多耗费10-100倍的时间，这个情况是非常糟糕的。通常这种情况只会在分配很大对象的时候（好几M大小的数组）。为了避免这种长暂停，你可以配置-XX:CMSWaitDuration选项。</p>

<h2>配置CMS开始的固定阈值</h2>

<p>你可以配置固定的老年代充满比例阈值来触发CMS gc：</p>

<pre><code>‑XX:+UseCMSInitiatingOccupancyOnly 
‑XX:CMSInitiatingOccupancyFraction=70(这会告诉JVM只有当超过70%的老年代被使用后才触发CMS)
</code></pre>

<h2>显式触发CMS</h2>

<p>你可以配置JVM，只要代码调用System.gc()方法后就触发CMS：<code>-XX:+ExplicitGCInvokesConcurrent</code></p>

<h2>CMS和Full gc</h2>

<p>如果CMS不能释放足够的老年代内存，JVM会启用整理式的搜集算法(Compacting)。整理收集器会强迫进入STW暂停，因此它只会出现在紧急情况下。通常大家都不希望进行full gc和较长时间的STW暂停。当CMS不能足够快的释放老年代内存，或者CMS启动的太晚了，或者因为老年代的内存碎片（没有足够的连续空间存放对象）时才会发生full gc。又或者你没有配置足够的堆内存，那么在full gc之后就会抛出OutOfMemoryException。</p>

<h2>永久带gc</h2>

<p>CMS结束后会触发full gc的一个原因是因为永久带的垃圾问题。默认的，CMS不会对永久带进行搜集。如果你的应用程序使用了多个classloader，或者反射，你可能会需要开启对永久带的垃圾回收。JVM选项-XX:+CMSClassUnloadingEnabled会允许CMS对永久带进行垃圾搜集。需要注意的是，位于永久带的对象可能会具有老年代对象的引用，如果永久带并没有满，这些从永久带到老年代的引用会导致一些已经死掉(dead)的对象在CMS周期内不可达，除非开启了class unloading。</p>

<h2>有效使用多核</h2>

<p>CMS具有多个阶段，有些是可以并发执行的，另外的是需要STW暂停的，但是可以并行执行以压缩程序暂停时间。</p>

<pre><code>-XX:+CMSConcurrentMTEnabled:允许CMS在concurrent阶段使用多核。
-XX:ConcGCThreads=&lt;n&gt;:指定concurrent阶段使用的线程数量
-XX:ParallelGCThreads=&lt;n&gt;:指定在STW暂停中并行工作的线程数（默认是机器的物理核心数）
-XX:+UseParNewGC:让JVM在新生代使用并行收集器，配合老年代的CMS。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM是如何实现锁[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2013/08/14/how-to-implement-lock-in-jvm/"/>
    <updated>2013-08-14T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/08/14/how-to-implement-lock-in-jvm</id>
    <content type="html"><![CDATA[<p><a href="http://slava-technical.blogspot.de/2011/04/how-does-jvm-handle-locks.html">原文链接</a></p>

<p>Hotspot JVM 1.6具有三种类型的锁，当你试图使用java.util.concurrent.locks.Lock的实现去获取一个锁，或者进入一个synchronized块时就会使用JVM提供的锁：</p>

<h2>biased锁(偏向锁)</h2>

<p>在有些时候，就算时在一个并发环境中，实际上对于某些对象来说时没有真正的竞争的，这个时候jvm就不会向操作系统申请互斥对象(mutex)来实现锁。Hotspot可以使用一些内部的数据结构来更加高效的模拟锁。比如，一段被synchronized包裹的同步代码在当前并没有并发的执行，JVM就会使用CAS来将当前拥有锁的线程ID赋给一个用来表示互斥对象的对象中，并且如果CAS成功的话还会将重入次数也存进去。这个就是偏向锁，JVM最轻量级的锁。重入次数这个变量会被锁的当前拥有线程更新，就像更新一个局部变量一样，不会使用CAS。如果CAS失败，说明该锁当前正被其他线程拥有，这个时候JVM会暂停该互斥对象的拥有线程，将线程上下文刷新的主存中，并检查重入次数。如果重入次数时0，那么JVM就会将该锁升级为thin，否则就升级为fat。Hotspot使用互斥对象中的同样的域(field)来存储锁的拥有者线程ID</p>

<h2>thin锁</h2>

<p>这个实际上是一个简单的自旋锁。如果自旋的时间很短的话，它可以班组节约线程切换的时间（不立刻阻塞并且发生切换，而是先自旋一段时间）。当一个线程试图获取一个已经被占用的锁，那么该线程会先自旋一段时间，直到这个锁被释放。自旋的次数由内部的jvm实现决定，通常会考虑以下因素：JVM对当前应用所搜集的一些统计信息；当前线程数；CPU使用情况和数量等等。当自旋失败后，JVM决定将该thin锁升级为fat锁</p>

<h2>fat锁</h2>

<p>JVM中最高级别的锁，底层会向操作系统申请系统级别的互斥对象，并且使用操作系统的调度器来对线程进行挂起和恢复。这种类型的锁的开销比前面提到的锁要大得多，因为每次锁的释放和获取都会使得JVM与底层操作系统进行互操作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hotspot JVM中的垃圾收集器[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2013/08/14/garbage-collection-in-hotspot/"/>
    <updated>2013-08-14T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/08/14/garbage-collection-in-hotspot</id>
    <content type="html"><![CDATA[<p><a href="http://blog.ragozin.info/2011/12/garbage-collection-in-hotspot-jvm.html">原文连接</a>，该文和我的<a href="http://shenzhang.github.io/blog/2013/07/23/gc-in-hotspot">这篇文章</a>非常非常类似，纯属巧合。另外也可以看看<a href="http://hllvm.group.iteye.com/group/topic/38223#post-248757">这篇文章</a>对不同垃圾算法的描述。</p>

<p>Hotspot拥有好几种GC模式，具体采用那种模式可以通过命令行选项来指定。默认的GC模式由JVM的版本，client/server模式，以及当前的硬件条件来决定。</p>

<h2>串行GC（Serial GC)</h2>

<p>JVM开关：-XX:+UseSerialGC</p>

<p>串行GC是一种分代垃圾搜集算法（实际上现在的Hotspot虚拟机中的所有垃圾手机算法都是分代手机算法）。在新生代采用了拷贝算法，老年代采用了标记-整理(mark-sweep-compact MSC)算法。老年代和新生代在垃圾手机的时候都会发生STW，并且就行它的名称一样，所有手机操作都是在单个线程里完成。在老年代的垃圾收集中，所有存活的对象会被移动到空间的开始处，这样就可以让JVM将不使用的内存区域交还给操作系统。</p>

<p>如果你使用<code>-XX:+PrintGCDeitals</code>开启了GC log，你就可以看到如下输出：</p>

<p>新生代：</p>

<pre><code>41.614 [GC 41.614: [DefNew: 130716K-&gt;7953K(138240K), 0.0525908 secs] 890546K-&gt;771614K(906240K), 0.0527947 secs] [Times: user=0.05 sys=0.00, real=0.05 secs]
</code></pre>

<p>Full GC（新生代 + 老年代 + 永久区）：</p>

<pre><code>41.908 [GC 41.908: [DefNew: 130833K-&gt;130833K(138240K), 0.0000257 secs]41.909: [Tenured: 763660K-&gt;648667K(768000K), 1.4323505 secs] 894494K-&gt;648667K(906240K), [Perm : 1850K-&gt;1850K(12288K)], 1.4326801 secs] [Times: user=1.42 sys=0.00, real=1.43 secs]
</code></pre>

<h2>并行清除</h2>

<p>JVM开关:<code>-XX:+UseParallelGC</code></p>

<p>垃圾搜集的某些阶段本身就可以具有并行化的特点。并行处理可以减少GC和STW暂停需要的时间，并且可以充分利用多核CPU。现代VM中采用并行GC来有效利用多核硬件已经显得非常有必要了。并行GC在新生代中采用了并行的算法，老年代仍然采用的是单线程的Mark-Sweep-Compact算法。因此，采用该模式将会减少新生代的GC暂停时间，但是对于full gc的时间还是比较长的。</p>

<p>gc log如下：
新生代：</p>

<pre><code>59.821: [GC [PSYoungGen: 147904K-&gt;4783K(148288K)] 907842K-&gt;769258K(916288K), 0.2382801 secs] [Times: user=0.31 sys=0.00, real=0.24 secs]
</code></pre>

<p>老年代：</p>

<pre><code>60.060: [Full GC [PSYoungGen: 4783K-&gt;0K(148288K)] [PSOldGen: 764475K-&gt;660316K(768000K)] 769258K-&gt;660316K(916288K) [PSPermGen: 1850K-&gt;1850K(12288K)], 1.2817061 secs] [Times: user=1.26 sys=0.00, real=1.28 secs]
</code></pre>

<h2>老年代并行GC算法</h2>

<p>JVM开关:<code>-XX:+UseParallelOldGC</code></p>

<p>该模式是在并行清除模式基础上做的增量改进。它在老年代添加了并行化的Mark-Sweep-Compact算法，新生代还是采用并行清除里的并行算法。老年代仍然会产生较长的STW暂停，但是对多核处理器的利用可以让这个时间减少一些。不像串行MSC算法，并行的版本不会在堆的末尾产生一片连续的空闲内存区域（存活的对象都被移动到了区域的开始处），因此JVM无法将未用的区域归还给操作系统。</p>

<p>gc log如下：</p>

<p>新生代：</p>

<pre><code>65.411: [GC [PSYoungGen: 147878K-&gt;5434K(144576K)] 908129K-&gt;770314K(912576K), 0.2734699 secs] [Times: user=0.41 sys=0.00, real=0.27 secs]
</code></pre>

<p>full gc:</p>

<pre><code>65.411: [GC [PSYoungGen: 147878K-&gt;5434K(144576K)] 908129K-&gt;770314K(912576K), 0.2734699 secs] [Times: user=0.41 sys=0.00, real=0.27 secs]
</code></pre>

<h2>自适应策略</h2>

<p>JVM开关：<code>-XX:+UseAdaptiveSizePolicy</code></p>

<p>这个是在并行清除模式下的一种特殊模式，它可以动态调整新生代的大小以适应当前应用程序的特点。实际上它不会带来显著的性能提升，因此不要随便使用该选项。</p>

<h2>并行标记清除算法(CMS)</h2>

<p>JVM开关：<code>-XX:+UseConcMarkSweepGC</code></p>

<p>前面介绍的gc收集器通常被称为最大吞吐量收集器。CMS收集器是一种低暂停率的收集器，它被设计来减少STW暂停，并且提高应用程序的响应性。对于新生代可以采用串行的拷贝算法或者并行算法（该并行算法和前面介绍的并行搜集中的新生代并行算法有点类似，但是它们实际上是两套不同的实现代码，并且它们可能会使用不同的配置选项，比如自适应策略在CMS中就不存在）。</p>

<p>老年代采用了并发的搜集方法。就像名字所言，CMS是一种标记-清除算法（没有整理[compact]过程）。CMS在每个搜集周期内只需要两个很短暂的暂停，但是不像标记-整理算法，CMS不会做内存整理操作（将内存对象重新布局）并且会导致产生内存碎片。虽然CMS算法采用了一些手段来尽量克服内存碎片，但是这还是一个潜在的问题。</p>

<p>如果这种并发的收集器不能很快速的为应用程序分配内存，JVM还是会退化到使用串行的STW mark-sweep-compact（标记整理算法）来对老年代进行碎片整理（使用串行化的MSC算法的停顿时间往往是CMS停顿时间的50-500倍）。</p>

<p>gc log如下：</p>

<p>新生代：</p>

<pre><code>613.154: [GC 13.154: [DefNew: 130821K-&gt;8230K(138240K), 0.0507238 secs] 507428K-&gt;388797K(906240K), 0.0509611 secs] [Times: user=0.06 sys=0.00, real=0.05 secs]
</code></pre>

<p>老年代：</p>

<pre><code>13.433: [GC [1 CMS-initial-mark: 384529K(768000K)] 395044K(906240K), 0.0045952 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]
13.438: [CMS-concurrent-mark-start]
...
14.345: [CMS-concurrent-mark: 0.412/0.907 secs] [Times: user=1.20 sys=0.00, real=0.91 secs]
14.345: [CMS-concurrent-preclean-start]
14.366: [CMS-concurrent-preclean: 0.020/0.021 secs] [Times: user=0.03 sys=0.00, real=0.02 secs]
14.366: [CMS-concurrent-abortable-preclean-start]
...
14.707: [CMS-concurrent-abortable-preclean: 0.064/0.340 secs] [Times: user=0.36 sys=0.02, real=0.34 secs]
14.707: [GC[YG occupancy: 77441 K (138240 K)]14.708: [Rescan (non-parallel) 14.708: [grey object rescan, 0.0058016 secs]14.714: [root rescan, 0.0424011 secs], 0.0485593 secs]14.756: [weak refs processing, 0.0000109 secs] [1 CMS-remark: 404346K(768000K)] 481787K(906240K), 0.0487607 secs] [Times: user=0.05 sys=0.00, real=0.05 secs]
14.756: [CMS-concurrent-sweep-start]
...
14.927: [CMS-concurrent-sweep: 0.116/0.171 secs] [Times: user=0.23 sys=0.02, real=0.17 secs]
14.927: [CMS-concurrent-reset-start]
14.953: [CMS-concurrent-reset: 0.026/0.026 secs] [Times: user=0.05 sys=0.00, real=0.03 secs]
</code></pre>

<h2>当CMS后分配失败并且退化到MSC算法时</h2>

<pre><code>557.079: [GC 557.079: [DefNew557.097: [CMS-concurrent-abortable-preclean: 0.010/0.109 secs] [Times: user=0.12 sys=0.00, real=0.11 secs]
 (promotion failed) : 130817K-&gt;130813K(138240K), 0.1401674 secs]557.219: [CMS (concurrent mode failure): 731771K-&gt;584338K(768000K), 2.4659665 secs] 858916K-&gt;584338K(906240K), [CMS Perm : 1841K-&gt;1835K(12288K)], 2.6065527 secs] [Times: user=2.48 sys=0.03, real=2.61 secs]
</code></pre>

<h2>CMS增量模式</h2>

<p>JVM开关：<code>-XX:+CMSIncrementalMode</code></p>

<p>CMS使用一个或多个后台线程并且与应用程序线程并发的执行gc操作。这些线程会和应用程序线程竞争CPU时间。增量模式下会对gc后台线程占用的cpu时间做限制，如果只有1个或2个cpu核心，那么这会进一步提高应用程序的响应性。当然，老年代的搜集可能会变得更长，并且发生full gc的风险会更高。</p>

<h2>G1收集算法</h2>

<p>JVM开关：<code>-XX:+UseG1GC</code></p>

<p>G1(garbage first)是Hotspot中新设计的垃圾搜集器。它在jdk1.6的较新版本中本引入。G1是一种低停顿的算法，并且采用了mark-sweep-compact的改进增量型算法。G1将堆划分为大小固定的多个区域，并且可以在STW暂停中对其中的部分区域进行垃圾搜集（与CMS不同，G1大部分的工作需要在STW中运行）。增量式可以用多个短暂停代替少量的长暂停（多个短暂停的总和还是会远远大于CMS）。更精确的说，G1会采用多个后台线程与应用程序并发的运行，来对堆中的内存进行标记(mark)（与CMS类似），但是还是有大量的工作是在STW中执行。</p>

<p>G1在对其中的部分区域进行搜集时还是会采用拷贝算法，这样在每次搜集完成后会产生一些空闲的区域，它们可以被JVM在适当的时候归还给操作系统。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hotspot的垃圾回收：串行、并行和CMS[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2013/08/13/serial-paiallel-cms-in-hotspot/"/>
    <updated>2013-08-13T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/08/13/serial-paiallel-cms-in-hotspot</id>
    <content type="html"><![CDATA[<p><a href="http://www.tikalk.com/java/garbage-collection-serial-vs-parallel-vs-concurrent-mark-sweep">原文链接</a></p>

<p>串行(Serial)，并行(Parallel)和CMS（Concurrent-Mark-Sweep)垃圾搜集算法到底有什么不同呢？</p>

<p>首先，让我们看看哪些算法是用于新生代，哪些算法是用于老年代：</p>

<h3>以下算法用于新生代：</h3>

<pre><code>-XX:+UseSerialGC 
-XX:+UseParallelGC 
-XX:+UseParNewGC
</code></pre>

<h3>以下算法用于老年代:</h3>

<pre><code>-XX:+UseParallelOldGC 
-XX:+UseConcMarkSweepGC
</code></pre>

<h3>串行和并行收集器有什么不同</h3>

<p>串行和并行垃圾收集器在GC的时候都会造成Stop-The-World，串行收集器默认是一个拷贝算法，并且使用单个线程来完成GC操作；并行收集器采用多个线程完成GC操作。</p>

<h3>并行收集器和CMS有什么不同</h3>

<p>CMS会通过以下步骤（所有步骤都使用一个线程完成）</p>

<ol>
<li>inital mark</li>
<li>concurrent marking</li>
<li>remark</li>
<li>concurrent sweeping</li>
</ol>


<p><em>主要有两点不同：</em></p>

<ol>
<li>并行收集器使用多个线程，CMS只使用单个线程</li>
<li>并行收集器会Stop-The-World，但是CMS仅仅在inital mark和remark阶段会STW,concrrent marking和concurrent sweeping阶段时，GC线程会和应用程序线程并发运行。</li>
</ol>


<h3>如果你想将GC定制化为并行化和并发化，那么可以使用下面的参数:</h3>

<pre><code>-XX:UserParNewGC：让新生代使用多个线程
-XX:+UseConcMarkSweepGC:在老年代使用CMS（一个线程，仅仅在inital mark和remark阶段才发生STW)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hotspot中的safepoints[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2013/08/13/safepoints-in-hotspot/"/>
    <updated>2013-08-13T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/08/13/safepoints-in-hotspot</id>
    <content type="html"><![CDATA[<p><a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">原文链接</a></p>

<p>术语Stop-The-World(STW)通常和垃圾搜集相关。虽然GC是STW暂停的最主要原因，但并不是唯一的原因。</p>

<h2>Safepoints</h2>

<p>在Hotspot虚拟机中Stop-The-World暂停机制被称作safepoint。在safepoint期间，所有运行java代码的线程都会被挂起。运行本地代码的线程都会继续执行，直到与JVM进行交互（比如调用java的方法或者从本地代码返回到java代码）。</p>

<p>在暂停所有的线程时，要求safepoint的发起者具有JVM数据的排他访问权限，这样就可以做很多疯狂的事情，比如在堆中移动数据或者替换正在运行的方法中的代码。</p>

<h2>Safepoint是怎么工作的？</h2>

<p>Hotspot JVM中的safepoint是一种协作性的协议。所有的应用程序线程会检查safepoint的状态，当需要进入safepoint的时候，线程会暂停自己并且保持在一个安全的状态下。</p>

<p>对于已经被编译的代码（JIT编译），JIT编译器会在某些代码点插入safepoint检查代码（一般是在调用返回的时候或者是循环退出的时候）。对于解释执行的代码，JVM有两个字节码分发表(byte code dispatch table)，当需要进入safepoint的时候，JVM会在这两个表之间切换以便做safepoint检查。</p>

<p>safepoint状态检查实现的非常巧妙，普通的内存变量检查需要内存屏障的支持。safepoint检查以读取内存屏障的方式实现。当需要safepoint的时候，JVM取消对应用程序线程中导致页错误的地址映射（由JVM直接处理）。这样，Hotspot可以让经过JIT编译的代码保持CPU流水线的友好性，同时也保证了正确的内存语义。</p>

<h2>什么时候会触发safepoints</h2>

<p>下面是Hotspot JVM中会触发safepoints的一些原因：</p>

<ol>
<li>垃圾回收</li>
<li>代码优化</li>
<li>刷新缓存</li>
<li>类重定义(比如hotswap或者instrumentation)</li>
<li>撤销偏向锁</li>
<li>多种调试操作(比如死锁检查，运行栈dump)</li>
</ol>


<h2>safepoints问题排查</h2>

<p>通常情况下safepoints会经常存在并一直工作者，因此你并不需要怎么关系它（大多数情况下，除了GC，都非常快速和短暂）。如果由于偶然的因素破坏了safepoint的正常工作，就会让事情变得很糟，因此下面是一些有用的诊断方法：</p>

<ol>
<li><p><code>-XX:+PrintGCApplicationStoppedTime</code>:该选项会报告所有safepoints的暂停时间（与GC相关的或者不相关的）。但是不幸的是，这个选项的输出缺少时间戳信息，但是它仍然可以帮助定位问题。</p></li>
<li><p><code>-XX:+PrintSafepointStatistics和-XX:PrintSafepointStatisticsCount=1</code>:这两个选项会强制JVM在safepoint后报告发生safepoint的原因及耗时（仅会输出到stdout，不会输出到GC日志(log)里）</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不同浏览器支持的最小时间精度]]></title>
    <link href="http://shenzhang.github.io/blog/2013/08/12/timeout-in-different-browser/"/>
    <updated>2013-08-12T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/08/12/timeout-in-different-browser</id>
    <content type="html"><![CDATA[<p>最近在实现一个灵活的div滚动条方案，主要用于解决windows下滚动条的美化问题，以及IE下对滚动条位置计算的不足。其中需要对div的内容大小进行持续监视，找了一个jquery的mutate插件，但是该插件的代码实在不敢恭维，于是对其进行了一些优化，减少了很多不必要的jquery对象创建过程。</p>

<p>该插件的原理非常简单，直接使用的setTimeout对检测属性进行监控，并且时间间隔是1ms，最初担心性能问题，但是发现实际上由于浏览器对时间的精度不会很高(不到1ms)，因此没有什么影响。但是还是对各浏览器的精度做了个简单测试,代码很简单：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">begin</span> <span class="o">=</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">begin</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">begin</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getTime</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">((</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getTime</span><span class="p">()</span> <span class="o">-</span> <span class="nx">begin</span><span class="p">)</span> <span class="o">/</span> <span class="nx">count</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">test</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">test</span><span class="p">();</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后的结果为：</p>

<pre><code>chrome: 4-5ms
firefox: 5-6ms
ie: 15ms
</code></pre>

<p>因此，最后将检测间隔设置成了50，既可以避免潜在的性能问题，也不会影响表现效果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识zookeeper]]></title>
    <link href="http://shenzhang.github.io/blog/2013/08/05/fist-view-of-zookeeper/"/>
    <updated>2013-08-05T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/08/05/fist-view-of-zookeeper</id>
    <content type="html"><![CDATA[<p>zookeeper是apache基金会下的一个高可用的分布式数据管理和协调框架，它最初也是hadoop下的一个子项目被用于hadoop生态系统中，但是随着被大家的不断挖掘，zookeeper有了更广泛的应用(应用场景可以参见<a href="http://rdc.taobao.com/team/jm/archives/1232">这里</a>).</p>

<h2>如何搭建单机版的zookeeper服务</h2>

<p>1.下载zookeeper</p>

<p>2.创建配置文件conf/zoo.cfg，并加入下面的配置信息：</p>

<pre><code>tickTime=2000
dataDir=/var/lib/zookeeper
clientPort=2181
</code></pre>

<p>完整的配置参数请参见<a href="http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_configuration">官方文档</a>.</p>

<p>3.启动zookeeper服务</p>

<pre><code>bin/zkServer.sh start
</code></pre>

<h2>测试</h2>

<p>可以直接使用bin/zkCli.sh这个脚本提供的java客户端来进行测试，该脚本的内容也非常简单:</p>

<ol>
<li>执行zkEnv.sh设置环境变量</li>
<li>执行org.apache.zookeeper.ZooKeeperMain</li>
</ol>


<p><code>bin/zkCli.sh -server host:port</code>来启动客户端，或者直接使用zkCli.sh来连接localhost:2181，连接上后可以使用help命令来查看所有客户端支持的命令：</p>

<pre><code>connect host:port
get path [watch]
ls path [watch]
set path data [version]
rmr path
delquota [-n|-b] path
quit
printwatches on|off
create [-s] [-e] path data acl
stat path [watch]
close
ls2 path [watch]
history
listquota path
setAcl path acl
getAcl path
sync path
redo cmdno
addauth scheme auth
delete path [version]
setquota -n|-b val path
</code></pre>

<p>例如：</p>

<ol>
<li>查看根路径: ls /</li>
<li>创建一个znode(节点): create /fish helloworld</li>
<li>查看一个节点: get /fish</li>
<li>重新设置一个节点的内容: set /fish hello</li>
</ol>


<h2>关闭zookeeper</h2>

<pre><code>bin/zkServer.sh stop
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JNDI环境初始化深入分析]]></title>
    <link href="http://shenzhang.github.io/blog/2013/07/27/inspect-jndi/"/>
    <updated>2013-07-27T05:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/07/27/inspect-jndi</id>
    <content type="html"><![CDATA[<h2>JNDI是什么</h2>

<p>jndi: Java Naming and Directory Interface</p>

<p>jndi是j2ee提供的用于对象查找和获取的接口规范，该规范需要j2ee容器去实现以提供jndi的功能，不同的容器或者说jndi实现者对jndi里的对象的注册方式和内部管理方式都不完全一样，但是获取方式都完全一样（jndi规定了怎么获取）,如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">InitalContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">InitialContext</span><span class="o">();</span>
</span><span class='line'><span class="n">Object</span> <span class="n">yourObject</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">lookup</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然jndi中还包含了LDAP等更高层次的接口规范，这里不进行描述。</p>

<h2>JNDI中可用的环境变量</h2>

<p>JNDI中预定义了一些环境变量，这些环境变量可以控制JNDI环境的行为（包括初始化过程），变量的定义在javax.naming.Context接口中，对应的javadoc有对各变量的说明，但是如果不看源码很难准确理解这些变量的意义。下面的片段截取了一些变量：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">String</span> <span class="n">INITIAL_CONTEXT_FACTORY</span> <span class="o">=</span> <span class="s">&quot;java.naming.factory.initial&quot;</span><span class="o">;</span>
</span><span class='line'><span class="n">String</span> <span class="n">OBJECT_FACTORIES</span> <span class="o">=</span> <span class="s">&quot;java.naming.factory.object&quot;</span><span class="o">;</span>
</span><span class='line'><span class="n">String</span> <span class="n">URL_PKG_PREFIXES</span> <span class="o">=</span> <span class="s">&quot;java.naming.factory.url.pkgs&quot;</span><span class="o">;</span>
</span><span class='line'><span class="n">String</span> <span class="n">APPLET</span> <span class="o">=</span> <span class="s">&quot;java.naming.applet&quot;</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>InitalContext</h2>

<p>javax.naming.InitalContext是客户端使用jndi的入口，也是jndi容器初始化的入口，因此jndi容器(环境)的初始化是lazy的，只有到需要的时候才会进行初始化。InitalContext的构造函数有两个：</p>

<p>1.不接受任何初始化环境变量</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="nf">InitialContext</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">NamingException</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">init</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.主动设置初始化环境变量(就是在上一节提到的环境变量)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="nf">InitialContext</span><span class="o">(</span><span class="n">Hashtable</span><span class="o">&lt;?,?&gt;</span> <span class="n">environment</span><span class="o">)</span><span class="kd">throws</span> <span class="n">NamingException</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">environment</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">environment</span> <span class="o">=</span> <span class="o">(</span><span class="n">Hashtable</span><span class="o">)</span><span class="n">environment</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">init</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来会调用init函数来初始化InitalContext.defaultInitCtx变量，该变量也是Context类型，并且由具体的容器来实现，它才是真正的实现者。待defaultInitCtx创建好之后，InitalContext的所有操作就会被分发给defaultInitCtx执行，InitalContext本质上讲就是defaultInitCtx的工厂和代理。</p>

<h2>初始化过程</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">(</span><span class="n">Hashtable</span><span class="o">&lt;?,?&gt;</span> <span class="n">environment</span><span class="o">)</span><span class="kd">throws</span> <span class="n">NamingException</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">myProps</span> <span class="o">=</span> <span class="n">ResourceManager</span><span class="o">.</span><span class="na">getInitialEnvironment</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">myProps</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">INITIAL_CONTEXT_FACTORY</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// user has specified initial context factory; try to get it</span>
</span><span class='line'>        <span class="n">getDefaultInitCtx</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="n">Hashtable</span> <span class="nf">getInitialEnvironment</span><span class="o">(</span><span class="n">Hashtable</span> <span class="n">env</span><span class="o">)</span>
</span><span class='line'>        <span class="kd">throws</span> <span class="n">NamingException</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">String</span><span class="o">[]</span> <span class="n">props</span> <span class="o">=</span> <span class="n">VersionHelper</span><span class="o">.</span><span class="na">PROPS</span><span class="o">;</span>   <span class="c1">// system/applet properties</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">env</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">env</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Hashtable</span><span class="o">(</span><span class="mi">11</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">Object</span> <span class="n">applet</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">APPLET</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Merge property values from env param, applet params, and system</span>
</span><span class='line'>    <span class="c1">// properties.  The first value wins:  there&#39;s no concatenation of</span>
</span><span class='line'>    <span class="c1">// colon-separated lists.</span>
</span><span class='line'>    <span class="c1">// Read system properties by first trying System.getProperties(),</span>
</span><span class='line'>    <span class="c1">// and then trying System.getProperty() if that fails.  The former</span>
</span><span class='line'>    <span class="c1">// is more efficient due to fewer permission checks.</span>
</span><span class='line'>    <span class="n">String</span><span class="o">[]</span> <span class="n">jndiSysProps</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="na">getJndiProperties</span><span class="o">();</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">props</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Object</span> <span class="n">val</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">props</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">val</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">applet</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">val</span> <span class="o">=</span> <span class="n">AppletParameter</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">applet</span><span class="o">,</span> <span class="n">props</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">val</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="c1">// Read system property.</span>
</span><span class='line'>                <span class="n">val</span> <span class="o">=</span> <span class="o">(</span><span class="n">jndiSysProps</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>                    <span class="o">?</span> <span class="n">jndiSysProps</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>
</span><span class='line'>                    <span class="o">:</span> <span class="n">helper</span><span class="o">.</span><span class="na">getJndiProperty</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">env</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">props</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">val</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Merge the above with the values read from all application</span>
</span><span class='line'>    <span class="c1">// resource files.  Colon-separated lists are concatenated.</span>
</span><span class='line'>    <span class="n">mergeTables</span><span class="o">(</span><span class="n">env</span><span class="o">,</span> <span class="n">getApplicationResources</span><span class="o">());</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">env</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数实际上就是从一些环境变量（参数）源搜集jndi需要的环境变量，然后再以map的形式返回。</p>

<ol>
<li>InitalContext(environment)构造函数传递的环境变量。</li>
<li>如果a中指定了javax.naming.applet对象，则转换为Applet对象，这个Applet对象也成了源(applet)</li>
<li>System.getProperties()提供的环境变量(systemProperties)</li>
<li>应用程序提供的环境变量(application)。</li>
</ol>


<p>这些环境变量的优先级如下：2和3只能够提供以下的环境变量，其他的变量将被忽略：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">final</span> <span class="kd">static</span> <span class="n">String</span><span class="o">[]</span> <span class="n">PROPS</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[]</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">javax</span><span class="o">.</span><span class="na">naming</span><span class="o">.</span><span class="na">Context</span><span class="o">.</span><span class="na">INITIAL_CONTEXT_FACTORY</span><span class="o">,</span>
</span><span class='line'>    <span class="n">javax</span><span class="o">.</span><span class="na">naming</span><span class="o">.</span><span class="na">Context</span><span class="o">.</span><span class="na">OBJECT_FACTORIES</span><span class="o">,</span>
</span><span class='line'>    <span class="n">javax</span><span class="o">.</span><span class="na">naming</span><span class="o">.</span><span class="na">Context</span><span class="o">.</span><span class="na">URL_PKG_PREFIXES</span><span class="o">,</span>
</span><span class='line'>    <span class="n">javax</span><span class="o">.</span><span class="na">naming</span><span class="o">.</span><span class="na">Context</span><span class="o">.</span><span class="na">STATE_FACTORIES</span><span class="o">,</span>
</span><span class='line'>    <span class="n">javax</span><span class="o">.</span><span class="na">naming</span><span class="o">.</span><span class="na">Context</span><span class="o">.</span><span class="na">PROVIDER_URL</span><span class="o">,</span>
</span><span class='line'>    <span class="n">javax</span><span class="o">.</span><span class="na">naming</span><span class="o">.</span><span class="na">Context</span><span class="o">.</span><span class="na">DNS_URL</span><span class="o">,</span>
</span><span class='line'>    <span class="c1">// The following shouldn&#39;t create a runtime dependence on ldap package.</span>
</span><span class='line'>    <span class="n">javax</span><span class="o">.</span><span class="na">naming</span><span class="o">.</span><span class="na">ldap</span><span class="o">.</span><span class="na">LdapContext</span><span class="o">.</span><span class="na">CONTROL_FACTORIES</span>
</span><span class='line'><span class="o">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>优先级是environment > applet > systemProperties</p>

<p>最后的env会和application（应用指定的）环境变量合并（如果env没有提供就采用application的，如果env有了，那么就会和application的合并，用逗号分割），如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">mergeTables</span><span class="o">(</span><span class="n">Hashtable</span> <span class="n">props1</span><span class="o">,</span> <span class="n">Hashtable</span> <span class="n">props2</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Enumeration</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">props2</span><span class="o">.</span><span class="na">keys</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">while</span> <span class="o">(</span><span class="n">keys</span><span class="o">.</span><span class="na">hasMoreElements</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">prop</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span><span class="n">keys</span><span class="o">.</span><span class="na">nextElement</span><span class="o">();</span>
</span><span class='line'>        <span class="n">Object</span> <span class="n">val1</span> <span class="o">=</span> <span class="n">props1</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">prop</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">val1</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">props1</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">prop</span><span class="o">,</span> <span class="n">props2</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">prop</span><span class="o">));</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">isListProperty</span><span class="o">(</span><span class="n">prop</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">String</span> <span class="n">val2</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span><span class="n">props2</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">prop</span><span class="o">);</span>
</span><span class='line'>            <span class="n">props1</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">prop</span><span class="o">,</span> <span class="o">((</span><span class="n">String</span><span class="o">)</span><span class="n">val1</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot;:&quot;</span> <span class="o">+</span> <span class="n">val2</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后来看下怎么获取application(应用级别)的环境变量:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="n">Hashtable</span> <span class="nf">getApplicationResources</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">NamingException</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">ClassLoader</span> <span class="n">cl</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="na">getContextClassLoader</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">propertiesCache</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Hashtable</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">Hashtable</span><span class="o">)</span><span class="n">propertiesCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">cl</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">NamingEnumeration</span> <span class="n">resources</span> <span class="o">=</span>
</span><span class='line'>                <span class="n">helper</span><span class="o">.</span><span class="na">getResources</span><span class="o">(</span><span class="n">cl</span><span class="o">,</span> <span class="n">APP_RESOURCE_FILE_NAME</span><span class="o">);</span>
</span><span class='line'>            <span class="k">while</span> <span class="o">(</span><span class="n">resources</span><span class="o">.</span><span class="na">hasMore</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Properties</span><span class="o">();</span>
</span><span class='line'>                <span class="n">props</span><span class="o">.</span><span class="na">load</span><span class="o">((</span><span class="n">InputStream</span><span class="o">)</span><span class="n">resources</span><span class="o">.</span><span class="na">next</span><span class="o">());</span>
</span><span class='line'>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">result</span> <span class="o">=</span> <span class="n">props</span><span class="o">;</span>
</span><span class='line'>                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">mergeTables</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">props</span><span class="o">);</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// Merge in properties from file in &lt;java.home&gt;/lib.</span>
</span><span class='line'>            <span class="n">InputStream</span> <span class="n">istream</span> <span class="o">=</span>
</span><span class='line'>                <span class="n">helper</span><span class="o">.</span><span class="na">getJavaHomeLibStream</span><span class="o">(</span><span class="n">JRELIB_PROPERTY_FILE_NAME</span><span class="o">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">istream</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Properties</span><span class="o">();</span>
</span><span class='line'>                <span class="n">props</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">istream</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">result</span> <span class="o">=</span> <span class="n">props</span><span class="o">;</span>
</span><span class='line'>                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">mergeTables</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">props</span><span class="o">);</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">NamingException</span> <span class="n">ne</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConfigurationException</span><span class="o">(</span>
</span><span class='line'>                    <span class="s">&quot;Error reading application resource file&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="n">ne</span><span class="o">.</span><span class="na">setRootCause</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>            <span class="k">throw</span> <span class="n">ne</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Hashtable</span><span class="o">(</span><span class="mi">11</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">propertiesCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">cl</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>实际上就是使用当前线程的ContextClassLoader去尝试加载两个peropery形式的配置文件：</p>

<ol>
<li>APP_RESOURCE_FILE = jndi.properties</li>
<li>&lt;java.home>/lib/jndi.properties</li>
</ol>


<p>这个步骤对于某些jndi容器来说是相当重要的，因为前面提到了环境变量指定方式都需要应用做额外的配置或者写特定的代码，这个步骤就可以让容器的实现者可以将自己的配置放在约定的配置文件里，供jndi使用。比如jetty8的jndi容器实现就是通过<code>classpath://jndi.properties</code>来做配置的:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">java</span><span class="o">.</span><span class="na">naming</span><span class="o">.</span><span class="na">factory</span><span class="o">.</span><span class="na">url</span><span class="o">.</span><span class="na">pkgs</span><span class="o">=</span><span class="n">org</span><span class="o">.</span><span class="na">eclipse</span><span class="o">.</span><span class="na">jetty</span><span class="o">.</span><span class="na">jndi</span>
</span><span class='line'><span class="n">java</span><span class="o">.</span><span class="na">naming</span><span class="o">.</span><span class="na">factory</span><span class="o">.</span><span class="na">initial</span><span class="o">=</span><span class="n">org</span><span class="o">.</span><span class="na">eclipse</span><span class="o">.</span><span class="na">jetty</span><span class="o">.</span><span class="na">jndi</span><span class="o">.</span><span class="na">InitialContextFactory</span>
</span></code></pre></td></tr></table></div></figure>


<p>之前有个朋友问他的jetty中的应用为什么InitalContext.lookup总是报错，配置不对。实际上就是没有将jetty-jndi-[version].jar依赖进来，这个里面就包含了jndi.properties的配置文件，除非使用jetty-all.jar的集合包，否则要想让jetty提供jndi的功能就一定需要该jar包。</p>

<p>好了通过上面的分析，最后搜集到了所有的环境变量的值，并保存在InitialContext.myProps中，继续初始化defaultInitCtx&hellip;</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">(</span><span class="n">Hashtable</span><span class="o">&lt;?,?&gt;</span> <span class="n">environment</span><span class="o">)</span><span class="kd">throws</span> <span class="n">NamingException</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">myProps</span> <span class="o">=</span> <span class="n">ResourceManager</span><span class="o">.</span><span class="na">getInitialEnvironment</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">myProps</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">INITIAL_CONTEXT_FACTORY</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// user has specified initial context factory; try to get it</span>
</span><span class='line'>        <span class="n">getDefaultInitCtx</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果环境变量里指明了INITAL_CONTEXT_FACTORY(java.naming.factory.inital)就开始初始化默认的Context:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="n">Context</span> <span class="nf">getDefaultInitCtx</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">NamingException</span><span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(!</span><span class="n">gotDefault</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">defaultInitCtx</span> <span class="o">=</span> <span class="n">NamingManager</span><span class="o">.</span><span class="na">getInitialContext</span><span class="o">(</span><span class="n">myProps</span><span class="o">);</span>
</span><span class='line'>        <span class="n">gotDefault</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">defaultInitCtx</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoInitialContextException</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">defaultInitCtx</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="n">Context</span> <span class="nf">getInitialContext</span><span class="o">(</span><span class="n">Hashtable</span><span class="o">&lt;?,?&gt;</span> <span class="n">env</span><span class="o">)</span>
</span><span class='line'>    <span class="kd">throws</span> <span class="n">NamingException</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">InitialContextFactory</span> <span class="n">factory</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">InitialContextFactoryBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="n">getInitialContextFactoryBuilder</span><span class="o">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">builder</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// No factory installed, use property</span>
</span><span class='line'>        <span class="c1">// Get initial context factory class name</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">String</span> <span class="n">className</span> <span class="o">=</span> <span class="n">env</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span>
</span><span class='line'>            <span class="o">(</span><span class="n">String</span><span class="o">)</span><span class="n">env</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">INITIAL_CONTEXT_FACTORY</span><span class="o">)</span> <span class="o">:</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">className</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">NoInitialContextException</span> <span class="n">ne</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NoInitialContextException</span><span class="o">(</span>
</span><span class='line'>                <span class="s">&quot;Need to specify class name in environment or system &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;property, or as an applet parameter, or in an &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;application resource file:  &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="n">Context</span><span class="o">.</span><span class="na">INITIAL_CONTEXT_FACTORY</span><span class="o">);</span>
</span><span class='line'>            <span class="k">throw</span> <span class="n">ne</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">factory</span> <span class="o">=</span> <span class="o">(</span><span class="n">InitialContextFactory</span><span class="o">)</span>
</span><span class='line'>                <span class="n">helper</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span><span class="n">className</span><span class="o">).</span><span class="na">newInstance</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">NoInitialContextException</span> <span class="n">ne</span> <span class="o">=</span>
</span><span class='line'>                <span class="k">new</span> <span class="nf">NoInitialContextException</span><span class="o">(</span>
</span><span class='line'>                    <span class="s">&quot;Cannot instantiate class: &quot;</span> <span class="o">+</span> <span class="n">className</span><span class="o">);</span>
</span><span class='line'>            <span class="n">ne</span><span class="o">.</span><span class="na">setRootCause</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>            <span class="k">throw</span> <span class="n">ne</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">factory</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">createInitialContextFactory</span><span class="o">(</span><span class="n">env</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">factory</span><span class="o">.</span><span class="na">getInitialContext</span><span class="o">(</span><span class="n">env</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出创建Context的过程实际上是一个工厂模式，要先找到这个工厂(InitalContextFactory)</p>

<ol>
<li>首先检查NamingManager中是否配置的有IntialContextFactoryBuilder（Context工厂的工厂），如果有的话就用指定的factoryBuilder创建一个ContextFactory</li>
<li>否则就用环境变量里java.naming.factory.inital指定的工厂。</li>
<li>得到工厂后，就用这个工厂去创建这个defaultContext(InitalContext就是这个真正的Context的代理）。</li>
</ol>


<p>至于这个defaultContext是怎么实现的就依赖具体的容器了，只要符合jndi的规范就可以了，但是实际上规范中对这块的要求也是很少的，只是对一些概念和接口做了确定。</p>

<p>回头看来其实jndi的初始化是很简单的，就是简单的指定一些环境变量，特别是<code>INITAL_CONTEXT_FACTORY(java.naming.factory.inital)</code>参数，特工一个真正Context的工厂就行了，连创建的过程都交给具体容器去实现了。</p>
]]></content>
  </entry>
  
</feed>
