<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Keep going]]></title>
  <link href="http://shenzhang.github.io/atom.xml" rel="self"/>
  <link href="http://shenzhang.github.io/"/>
  <updated>2014-04-06T13:58:57+08:00</updated>
  <id>http://shenzhang.github.io/</id>
  <author>
    <name><![CDATA[zshen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[避免死锁[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2013/06/26/prevent-deadlock/"/>
    <updated>2013-06-26T02:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/06/26/prevent-deadlock</id>
    <content type="html"><![CDATA[<p><a href="http://tutorials.jenkov.com/java-concurrency/deadlock-prevention.html">原文链接</a></p>

<p>在有些情况下死锁是可以避免的。本文将展示三种用于避免死锁的技术：</p>

<ol>
<li>加锁顺序</li>
<li>加锁时限</li>
<li>死锁检测</li>
</ol>


<!--more-->


<h2>加锁顺序</h2>

<p>当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。</p>

<p>如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。看下面这个例子：</p>

<pre><code>Thread 1:
  lock A 
  lock B

Thread 2:
   wait for A
   lock C (when A locked)

Thread 3:
   wait for A
   wait for B
   wait for C
</code></pre>

<p>如果一个线程（比如线程3）需要一些锁，那么它必须按照确定的顺序获取锁。它只有获得了从顺序上排在前面的锁之后，才能获取后面的锁。</p>

<p>例如，线程2和线程3只有在获取了锁A之后才能尝试获取锁C(获取锁A是获取锁C的必要条件)。因为线程1已经拥有了锁A，所以线程2和3需要一直等到锁A被释放。然后在它们尝试对B或C加锁之前，必须成功地对A加了锁。</p>

<p>按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(并对这些锁做适当的排序)，但总有些时候是无法预知的。</p>

<h2>加锁时限</h2>

<p>另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行(加锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)。</p>

<p>以下是一个例子，展示了两个线程以不同的顺序尝试获取相同的两个锁，在发生超时后回退并重试的场景：</p>

<pre><code>Thread 1 locks A
Thread 2 locks B

Thread 1 attempts to lock B but is blocked
Thread 2 attempts to lock A but is blocked

Thread 1's lock attempt on B times out
Thread 1 backs up and releases A as well
Thread 1 waits randomly (e.g. 257 millis) before retrying.

Thread 2's lock attempt on A times out
Thread 2 backs up and releases B as well
Thread 2 waits randomly (e.g. 43 millis) before retrying.
</code></pre>

<p>在上面的例子中，线程2比线程1早200毫秒进行重试加锁，因此它可以先成功地获取到两个锁。这时，线程1尝试获取锁A并且处于等待状态。当线程2结束时，线程1也可以顺利的获得这两个锁（除非线程2或者其它线程在线程1成功获得两个锁之前又获得其中的一些锁）。</p>

<p>需要注意的是，由于存在锁的超时，所以我们不能认为这种场景就一定是出现了死锁。也可能是因为获得了锁的线程（导致其它线程超时）需要很长的时间去完成它的任务。</p>

<p>此外，如果有非常多的线程同一时间去竞争同一批资源，就算有超时和回退机制，还是可能会导致这些线程重复地尝试但却始终得不到锁。如果只有两个线程，并且重试的超时时间设定为0到500毫秒之间，这种现象可能不会发生，但是如果是10个或20个线程情况就不同了。因为这些线程等待相等的重试时间的概率就高的多（或者非常接近以至于会出现问题）。
(超时和重试机制是为了避免在同一时间出现的竞争，但是当线程很多时，其中两个或多个线程的超时时间一样或者接近的可能性就会很大，因此就算出现竞争而导致超时后，由于超时时间一样，它们又会同时开始重试，导致新一轮的竞争，带来了新的问题。)</p>

<p>这种机制存在一个问题，在Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具。写一个自定义锁类不复杂，但超出了本文的内容。</p>

<h2>死锁检测</h2>

<p>死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。</p>

<p>每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。</p>

<p>当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）。</p>

<p>当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。线程A等待线程B，线程B等待线程C，线程C等待线程D，线程D又在等待线程A。线程A为了检测死锁，它需要递进地检测所有被B请求的锁。从线程B所请求的锁开始，线程A找到了线程C，然后又找到了线程D，发现线程D请求的锁被线程A自己持有着。这是它就知道发生了死锁。</p>

<p>下面是一幅关于四个线程（A,B,C和D）之间锁占有和请求的关系图。像这样的数据结构就可以被用来检测死锁。</p>

<p><img src="http://shenzhang.github.io/images/2013/06/deadlock-detection-graph.png"></p>

<p>那么当检测出死锁时，这些线程该做些什么呢？</p>

<p>一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁。</p>

<p>一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[死锁[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2013/06/26/deadlock/"/>
    <updated>2013-06-26T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/06/26/deadlock</id>
    <content type="html"><![CDATA[<p><a href="http://tutorials.jenkov.com/java-concurrency/deadlock.html">原文链接</a></p>

<p>死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。</p>

<p>例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。</p>

<!--more-->


<p>该情况如下：</p>

<pre><code>Thread 1  locks A, waits for B
Thread 2  locks B, waits for A
</code></pre>

<p>这里有一个TreeNode类的例子，它调用了不同实例的synchronized方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TreeNode</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">TreeNode</span> <span class="n">parent</span>   <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>  <span class="n">List</span> <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">addChild</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">child</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span><span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">child</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">this</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">child</span><span class="o">);</span>
</span><span class='line'>          <span class="n">child</span><span class="o">.</span><span class="na">setParentOnly</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">addChildOnly</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">child</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span><span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">child</span><span class="o">){</span>
</span><span class='line'>          <span class="k">this</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">child</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">setParent</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">parent</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">;</span>
</span><span class='line'>      <span class="n">parent</span><span class="o">.</span><span class="na">addChildOnly</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">setParentOnly</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">parent</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果线程1调用parent.addChild(child)方法的同时有另外一个线程2调用child.setParent(parent)方法，两个线程中的parent表示的是同一个对象，child亦然，此时就会发生死锁。下面的伪代码说明了这个过程：</p>

<pre><code>Thread 1: parent.addChild(child); //locks parent
          --&gt; child.setParentOnly(parent);

Thread 2: child.setParent(parent); //locks child
          --&gt; parent.addChildOnly()
</code></pre>

<p>首先线程1调用parent.addChild(child)。因为addChild()是同步的，所以线程1会对parent对象加锁以不让其它线程访问该对象。</p>

<p>然后线程2调用child.setParent(parent)。因为setParent()是同步的，所以线程2会对child对象加锁以不让其它线程访问该对象。</p>

<p>现在child和parent对象被两个不同的线程锁住了。接下来线程1尝试调用child.setParentOnly()方法，但是由于child对象现在被线程2锁住的，所以该调用会被阻塞。线程2也尝试调用parent.addChildOnly()，但是由于parent对象现在被线程1锁住，导致线程2也阻塞在该方法处。现在两个线程都被阻塞并等待着获取另外一个线程所持有的锁。</p>

<p>注意：像上文描述的，这两个线程需要同时调用parent.addChild(child)和child.setParent(parent)方法，并且是同一个parent对象和同一个child对象，才有可能发生死锁。上面的代码可能运行一段时间才会出现死锁。</p>

<p>这些线程需要同时获得锁。举个例子，如果线程1稍微领先线程2，然后成功地锁住了A和B两个对象，那么线程2就会在尝试对B加锁的时候被阻塞，这样死锁就不会发生。因为线程调度通常是不可预测的，因此没有一个办法可以准确预测什么时候死锁会发生，仅仅是可能会发生。</p>

<h2>更复杂的死锁</h2>

<p>死锁可能不止包含2个线程，这让检测死锁变得更加困难。下面是4个线程发生死锁的例子：</p>

<pre><code>Thread 1  locks A, waits for B
Thread 2  locks B, waits for C
Thread 3  locks C, waits for D
Thread 4  locks D, waits for A
</code></pre>

<p>线程1等待线程2，线程2等待线程3，线程3等待线程4，线程4等待线程1。</p>

<h2>数据库的死锁</h2>

<p>更加复杂的死锁场景发生在数据库事务中。一个数据库事务可能由多条SQL更新请求组成。当在一个事务中更新一条记录，这条记录就会被锁住避免其他事务的更新请求，直到第一个事务结束。同一个事务中每一个更新请求都可能会锁住一些记录。</p>

<p>当多个事务同时需要对一些相同的记录做更新操作时，就很有可能发生死锁，例如：</p>

<pre><code>Transaction 1, request 1, locks record 1 for update
Transaction 2, request 1, locks record 2 for update
Transaction 1, request 2, tries to lock record 2 for update.
Transaction 2, request 2, tries to lock record 1 for update.
</code></pre>

<p>因为锁发生在不同的请求中，并且对于一个事务来说不可能提前知道所有它需要的锁，因此很难检测和避免数据库事务中的死锁。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[spring对redis的支持]]></title>
    <link href="http://shenzhang.github.io/blog/2013/06/25/spring-for-redis/"/>
    <updated>2013-06-25T07:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/06/25/spring-for-redis</id>
    <content type="html"><![CDATA[<p>spring-data项目提供了多种数据操作的包，其中spring-data-redis就提供了与redis交互的实现，现在最新的版本是1.0.4。</p>

<p>spring-data-redis提供了对多种redis客户端的集成和抽象，比如jedis, jRedis, RJC, SRP等。并且提供了以下几个方面的支持：</p>

<ol>
<li>底层抽象：主要封装了配置和连接过程，以及异常的转换和翻译。</li>
<li>高层抽象：以RedisTemplate的形式提供。</li>
<li>可复用的工具类。</li>
</ol>


<!--more-->


<h2>引用spring-data-redis</h2>

<p>可以在pom.xml中加入如下依赖：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;dependency&gt;</span>
</span><span class='line'>  <span class="nt">&lt;groupId&gt;</span>org.springframework.data<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>  <span class="nt">&lt;artifactId&gt;</span>spring-data-redis<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>  <span class="nt">&lt;version&gt;</span>1.0.4.RELEASE<span class="nt">&lt;/version&gt;</span>
</span><span class='line'><span class="nt">&lt;/dependency&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>引入该依赖后会自动引入org.slf4j:jcl-over-slf4j，如果不想使用jcl可以使用excludes排除。</p>

<h2>连接redis</h2>

<p>连接redis的逻辑主要在org.springframework.data.redis.connection包中，里面提供了一些针对不同client的connection实现和一些公共类。本文都以jedis为客户端举例。</p>

<p>连接过程主要涉及RedisConnection和RedisConnectionFactory两个类，RedisConnectionFactory接受连接配置并可以创建具体的连接RedisConnection；RedisConnection封装了底层客户端真实的链接，并且可以自动翻译底层连接抛出的异常，有点类似spring jdbc的异常机制。根据不同的配置每次从Factory获得的connection可以是一个新创建的或者是一个缓存的(pooled)。RedisConnection.getNativeConnection()可以得到底层真正的Connection。</p>

<p>不同客户端的connection并不一定提供了所有redis所支持的特性，因此，如果在connection上使用了一个并不支持的操作，那么RedisConnection会抛出UnsupportedOperationException。</p>

<h2>连接配置</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>
</span><span class='line'><span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">&quot;http://www.springframework.org/schema/beans&quot;</span> <span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
</span><span class='line'>  <span class="na">xmlns:context=</span><span class="s">&quot;http://www.springframework.org/schema/context&quot;</span>
</span><span class='line'>  <span class="na">xsi:schemaLocation=</span><span class="s">&quot;</span>
</span><span class='line'><span class="s">  http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span>
</span><span class='line'><span class="s">  http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  
</span><span class='line'>  <span class="nt">&lt;context:component-scan</span> <span class="na">base-package=</span><span class="s">&quot;redis.spring&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>  
</span><span class='line'>  <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&quot;connectionFactory&quot;</span> <span class="na">class=</span><span class="s">&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>      <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;hostName&quot;</span> <span class="na">value=</span><span class="s">&quot;redisserver&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;port&quot;</span> <span class="na">value=</span><span class="s">&quot;6379&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;usePool&quot;</span> <span class="na">value=</span><span class="s">&quot;true&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/bean&gt;</span>
</span><span class='line'><span class="nt">&lt;/beans&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>RedisTemplate</h2>

<p>RedisTemplate对Redis操作的高层次封装，主要提供了两种操作方式：</p>

<h3>1.Operation</h3>

<p>Redis现在所支持的value类型主要有五种：String，Hash，Set，List，Sorted Set(ZSet)。因此RedisTemplate可以获取针对这五种类型的Operation，并且这五种类型的Operation又分为普通的KV Operation和与Key已经绑定的value Operation：</p>

<ul>
<li><strong>String:</strong> ValueOperations/BoundValueOperations</li>
<li><strong>Hash:</strong> HashOperations/BoundHashOperations</li>
<li><strong>List:</strong> ListOperations/BoundListOperations</li>
<li><strong>Set:</strong> SetOperations/BoundSetOperations</li>
<li><strong>ZSet:</strong> ZSetOperations/BoundZSetOperations</li>
</ul>


<p>KV Operation和Value Operation的不同，拿set name &lsquo;fish&#8217;举例：</p>

<ul>
<li><strong>KV Operation:</strong> template.opsForValue().set(&ldquo;name&rdquo;, &ldquo;fish&rdquo;);</li>
<li><strong>Value Operation:</strong> template.boundValueOps(&ldquo;name&rdquo;).set(&ldquo;fish&rdquo;);  // 获得的Operation可以复用，但是所有操作都是绑定到name这个key上了。</li>
</ul>


<h3>2.Callback</h3>

<p>可以使用Callback的方式直接拿到RedisConnection，并操作Redis</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Test</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testCallback</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">template</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="n">RedisCallback</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;()</span> <span class="o">{</span>
</span><span class='line'>        <span class="nd">@Override</span>
</span><span class='line'>        <span class="kd">public</span> <span class="n">Object</span> <span class="nf">doInRedis</span><span class="o">(</span><span class="n">RedisConnection</span> <span class="n">connection</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">DataAccessException</span> <span class="o">{</span>
</span><span class='line'>     <span class="c1">// use connection to op redis   </span>
</span><span class='line'>           <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">});</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>spring还提供了专门针对String类型的模版：StringRedisTemplate，要求Key和Value都是String类型。</p>

<h2>序列化</h2>

<p>由于redis本质上是存的二进制字节，因此在用java与redis交互的时候需要将java对象（包括String）序列化和反序列化。spring-data-redis的序列化支持在org.springframework.data.redis.serializer包中，所有的序列化机制都需要实现RedisSerializer接口：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">RedisSerializer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="cm">/**</span>
</span><span class='line'><span class="cm">  * Serialize the given object to binary data.</span>
</span><span class='line'><span class="cm">  * </span>
</span><span class='line'><span class="cm">  * @param t object to serialize</span>
</span><span class='line'><span class="cm">  * @return the equivalent binary data</span>
</span><span class='line'><span class="cm">  */</span>
</span><span class='line'>  <span class="kt">byte</span><span class="o">[]</span> <span class="nf">serialize</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">SerializationException</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/**</span>
</span><span class='line'><span class="cm">  * Deserialize an object from the given binary data.</span>
</span><span class='line'><span class="cm">  * </span>
</span><span class='line'><span class="cm">  * @param bytes object binary representation</span>
</span><span class='line'><span class="cm">  * @return the equivalent object instance</span>
</span><span class='line'><span class="cm">  */</span>
</span><span class='line'>  <span class="n">T</span> <span class="nf">deserialize</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">SerializationException</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>已经提供的序列化器:</p>

<ul>
<li><strong>StringRedisSerializer:</strong> 专门用于String对象的序列化器，可以配置编码格式</li>
<li><strong>JdkSerializationRedisSerializer:</strong> 使用jdk的二进制序列化机制 （RedisTemplate的默认序列化器）</li>
<li><strong>OxmSerializer:</strong> Object/XML序列化</li>
<li><strong>JacksonJsonRedisSerializer:</strong> JSON序列化</li>
</ul>


<p>我们可以在配置RedisTemplate的时候配置需要的序列化器。</p>

<h2>Redis事务</h2>

<p>Redis的事务虽然不像RDBMS一样支持回滚，但是可以保证在事务中的操作以原子的方式执行（中间不会被其他操作打断）。Redis提供了multi, exec, discard来实现事务的原子性。</p>

<p>在spring-data-redis中将这种事务机制和spring的事务整合在了一起，一般使用下面的模版来操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//execute a transaction</span>
</span><span class='line'><span class="n">redisTemplate</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="n">SessionCallback</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;()</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">execute</span><span class="o">(</span><span class="n">RedisOperations</span> <span class="n">operations</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">DataAccessException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">operations</span><span class="o">.</span><span class="na">multi</span><span class="o">();</span>
</span><span class='line'>        <span class="n">operations</span><span class="o">.</span><span class="na">opsForValue</span><span class="o">().</span><span class="na">set</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">,</span> <span class="s">&quot;value&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span>  <span class="n">operations</span><span class="o">.</span><span class="na">exec</span><span class="o">();</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">});</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java中的四舍五入]]></title>
    <link href="http://shenzhang.github.io/blog/2013/06/25/round-mode-in-java/"/>
    <updated>2013-06-25T06:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/06/25/round-mode-in-java</id>
    <content type="html"><![CDATA[<p>说四舍五入可能有点不太准确，应该说在精度范围之内的精度调整方法。</p>

<p>主要在java.math.RoundingMode里定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">UP</span><span class="o">(</span><span class="n">BigDecimal</span><span class="o">.</span><span class="na">ROUND_UP</span><span class="o">),</span>
</span><span class='line'><span class="n">DOWN</span><span class="o">(</span><span class="n">BigDecimal</span><span class="o">.</span><span class="na">ROUND_DOWN</span><span class="o">),</span>
</span><span class='line'><span class="n">CEILING</span><span class="o">(</span><span class="n">BigDecimal</span><span class="o">.</span><span class="na">ROUND_CEILING</span><span class="o">),</span>
</span><span class='line'><span class="n">FLOOR</span><span class="o">(</span><span class="n">BigDecimal</span><span class="o">.</span><span class="na">ROUND_FLOOR</span><span class="o">),</span>
</span><span class='line'><span class="n">HALF_UP</span><span class="o">(</span><span class="n">BigDecimal</span><span class="o">.</span><span class="na">ROUND_HALF_UP</span><span class="o">),</span>
</span><span class='line'><span class="n">HALF_DOWN</span><span class="o">(</span><span class="n">BigDecimal</span><span class="o">.</span><span class="na">ROUND_HALF_DOWN</span><span class="o">),</span>
</span><span class='line'><span class="n">HALF_EVEN</span><span class="o">(</span><span class="n">BigDecimal</span><span class="o">.</span><span class="na">ROUND_HALF_EVEN</span><span class="o">),</span>
</span><span class='line'><span class="n">UNNECESSARY</span><span class="o">(</span><span class="n">BigDecimal</span><span class="o">.</span><span class="na">ROUND_UNNECESSARY</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>UP:</strong>调整的方向是远离0，如：1.1 &ndash;> 2，-1.1 &ndash;> -2</p>

<p><strong>DOWN:</strong>调整的方向是靠近0，如：1.6 &ndash;> 1，-1.6 &ndash;> -1</p>

<p><strong>CEILING:</strong>调整的方向从数字大小的角度讲会变大，也就是说当大于0时等同于UP，当小于0时等同于DOWN，如：1.1->2，-1.1->1</p>

<p><strong>FLOOR:</strong>与CEILING相反</p>

<p><strong>HALF_UP:</strong>当尾数>=5时与UP相同，否则与DOWN相同</p>

<p><strong>HALF_DOWN:</strong>与HALF_UP类似，只是条件是>5，不是>=5</p>

<p><strong>HALF_EVEN:</strong>当尾数的前一位是奇数时，同HALF_UP，否则同HALF_DOWN</p>

<p><strong>UNNECESSARY:</strong>说明该数字不需要四舍五入，如果超出了精度则throw ArithmeticException。</p>

<p>更多例子可参见RoundingMode的javadoc.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[javac的调试选项-g的意义]]></title>
    <link href="http://shenzhang.github.io/blog/2013/06/25/debug-parameter-in-javac/"/>
    <updated>2013-06-25T05:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/06/25/debug-parameter-in-javac</id>
    <content type="html"><![CDATA[<p>javac的调试选项-g 主要包含了三个子选项：lines, vars, source</p>

<p>如果没有指定-g参数，javac是默认包含了lines和source选项，若指定-g参数则会包含所有三个选项。</p>

<p>下面分别简要解释下三个子选项的意义和效果：</p>

<p><strong>source:</strong> 将该class文件对应的源文件名称写进class中，这样在调试进入这个类时调试器就可以找到指定的源文件。可能有些同学会问：class的类名不就是源文件的名称吗，包命就是从classpath开始的路径。这种情况只是针对访问修饰符为public的类，一个源文件可以定义多个类（甚至是内部类）。如果在调试的过程中说找不到源文件，则很有可能是在编译的时候没有加上该选项。</p>

<p><strong>lines:</strong> 将源文件中的行号和class中字节码的偏移量对应起来，这样当你下断点的时候，调试器就知道该断点对应到class字节码的哪条指令。如果不设置该选项，那么你根本就没办法下断点。抛异常的时候也不会给出行数信息。</p>

<p><strong>vars:</strong> 局部变量的符号表。比如在eclipse调试的时候，可以边调试边看变量的信息，这些都要归功与局部变量的符号表，它可以帮助把运行过程中的变量值和源代码中的变量名对应起来。如果没有它，调试的时候是不能看到局部变量的值的，方法的参数也变成了arg1,arg2&hellip;。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux下ssh免输入密码方法]]></title>
    <link href="http://shenzhang.github.io/blog/2013/06/25/ssh-without-password/"/>
    <updated>2013-06-25T04:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/06/25/ssh-without-password</id>
    <content type="html"><![CDATA[<p>我们在日常开发或者运维过程中需要在不同的主机之间切换或者scp，在内网可信网络环境下重复输入密码是件很繁琐和考验记忆的事情，因此我们可以在自己常用的机器之间通过使用ssh-keygen工具做ssh的授权配置来省去输入密码的过程。</p>

<p>若要实现从A访问B不需要密码直接ssh(使用账户zhangsan)，需要以下步骤：</p>

<p>1.登陆A，并切换到zhangsan: <code>su - zhangsan</code>;</p>

<p>2.生成公钥和私钥：<code>ssh-keygen -t dsa</code>。其中-t参数后面可以为dsa或rsa，具体类型根据机器环境决定，现在大部分应该是dsa。接下来一路回车后会在~zhangsan/.ssh/目录下生成id_dsa和id_dsa.pub文件，其中id_dsa.pub文件就是公钥文件，需要拷贝到目标及其B上的。</p>

<p>3.拷贝公钥到目标机器:
<code>scp id_dsa.pub zhangsan@B:/home/zhangsan/.ssh/id_dsa.pub.A</code></p>

<p>4.追加到目标机器~/.ssh/authorized_keys中: <code>~/.ssh/cat id_dsa.pub.A &gt;&gt; ~/.ssh/authorized_keys</code></p>

<p>5.Done</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mysql远程客户端无法连接的问题]]></title>
    <link href="http://shenzhang.github.io/blog/2013/06/25/can-not-connect-mysql/"/>
    <updated>2013-06-25T03:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/06/25/can-not-connect-mysql</id>
    <content type="html"><![CDATA[<p>默认安装的mysql是不能在远程进行访问的，主要由以下两个原因造成：</p>

<p>1.mysqld服务没有监听可供远程访问的IP地址，解决方法：
修改mysqld的启动参数（或my.cnf），注释掉[mysqld]部分的bind-address=127.0.0.1，或修改为可访问到的IP。services mysql restart;</p>

<p>2.客户端连接时所使用的账户没有权限。查看mysql.user表可看到所有的账户及可供访问的HOST配置，检查所使用的账户是否有权限在当前客户端（IP）具有访问权限，如过没有可以通过以下语句添加：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">GRANT</span> <span class="k">ALL</span> <span class="k">PRIVILEGES</span> <span class="k">ON</span> <span class="o">*</span><span class="p">.</span><span class="o">*</span> <span class="k">TO</span> <span class="s1">&#39;root&#39;</span><span class="o">@</span><span class="s1">&#39;%&#39;</span> <span class="n">IDENTIFIED</span> <span class="k">BY</span> <span class="s1">&#39;123456&#39;</span> <span class="k">WITH</span> <span class="k">GRANT</span> <span class="k">OPTION</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux下mysql编码设置]]></title>
    <link href="http://shenzhang.github.io/blog/2013/06/25/charset-in-mysql/"/>
    <updated>2013-06-25T02:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/06/25/charset-in-mysql</id>
    <content type="html"><![CDATA[<p>在linux(debian)安装的mysql-server实例启动时的默认字符集是latin1。因此在创建数据库和表的默认编码也是latin1（除非显示指定character set）,这样会导致部分客户端在读取包含中文的结果集时产生乱码。因此我们需要改变linux下mysql的默认编码（windows下的默认编码是gbk，一般不会有问题），主要有两种方法：</p>

<p>1.在创建数据库是显示指定编码：<code>create database db1 character set utf8</code>;</p>

<p>2.在/etc/my.cnf中的[mysqld]部分加入<code>character-set-server=utf8</code>,最后在[client]部分加入<code>default-character-set=utf8</code>。
注：网上部分帖子说在[mysqld]部分加入default-character-set=utf8是不可行的，至少在mysql5.5之后的版本是无法启动的，可以通过mysqld &mdash;verbose &mdash;help查看具体的参数信息，或者mysql在新的版本中将<code>default-character-set</code>换成了<code>character-set-server</code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中的锁]]></title>
    <link href="http://shenzhang.github.io/blog/2013/06/25/lock-in-java/"/>
    <updated>2013-06-25T02:26:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/06/25/lock-in-java</id>
    <content type="html"><![CDATA[<p><a href="http://tutorials.jenkov.com/java-concurrency/locks.html">原文链接</a></p>

<p>锁像synchronized同步块一样，是一种线程同步机制，但比Java中的synchronized同步块更复杂。因为锁（以及其它更高级的线程同步机制）是由synchronized同步块的方式实现的，所以我们还不能完全摆脱synchronized关键字。</p>

<p>自Java 5开始，java.util.concurrent.locks包中包含了一些锁的实现，因此你不用去实现自己的锁了。但是你仍然需要去了解怎样使用这些锁，且了解这些实现背后的理论也是很有用处的。可以参考我对java.util.concurrent.locks.Lock的介绍，以了解更多关于锁的信息。</p>

<!--more-->


<h2>一个简单的锁</h2>

<p>让我们从java中的一个同步块开始：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">inc</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="o">++</span><span class="n">count</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到在inc()方法中有一个synchronized(this)代码块。该代码块可以保证在同一时间只有一个线程可以执行return ++count。虽然在synchronized的同步块中的代码可以更加复杂，但是++count这种简单的操作已经足以表达出线程同步的意思。</p>

<p>以下的Counter类用Lock代替synchronized达到了同样的目的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Lock</span><span class="o">();</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">inc</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">newCount</span> <span class="o">=</span> <span class="o">++</span><span class="n">count</span><span class="o">;</span>
</span><span class='line'>      <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">newCount</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>lock()方法会对Lock实例对象进行加锁，因此所有对该对象调用lock()方法的线程都会被阻塞，直到该Lock对象的unlock()方法被调用。</p>

<p>这里有一个Lock类的简单实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Lock</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isLocked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span>
</span><span class='line'>      <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">while</span><span class="o">(</span><span class="n">isLocked</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">wait</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="n">isLocked</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">isLocked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>      <span class="n">notify</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意其中的while(isLocked)循环，它又被叫做“自旋锁”。自旋锁以及wait()和notify()方法在线程通信这篇文章中有更加详细的介绍。当isLocked为true时，调用lock()的线程在wait()调用上阻塞等待。为防止该线程没有收到notify()调用也从wait()中返回（也称作虚假唤醒），这个线程会重新去检查isLocked条件以决定当前是否可以安全地继续执行还是需要重新保持等待，而不是认为线程被唤醒了就可以安全地继续执行了。如果isLocked为false，当前线程会退出while(isLocked)循环，并将isLocked设回true，让其它正在调用lock()方法的线程能够在Lock实例上加锁。</p>

<p>当线程完成了临界区（位于lock()和unlock()之间）中的代码，就会调用unlock()。执行unlock()会重新将isLocked设置为false，并且通知（唤醒）其中一个（若有的话）在lock()方法中调用了wait()函数而处于等待状态的线程。</p>

<h2>锁的可重入性</h2>

<p>Java中的synchronized同步块是可重入的。这意味着如果一个java线程进入了代码中的synchronized同步块，并因此获得了该同步块使用的同步对象对应的管程上的锁，那么这个线程可以进入由同一个管程对象所同步的另一个java代码块。下面是一个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Reentrant</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="nf">outer</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">inner</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="nf">inner</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">//do something</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意outer()和inner()都被声明为synchronized，这在Java中和synchronized(this)块等效。如果一个线程调用了outer()，在outer()里调用inner()就没有什么问题，因为这两个方法（代码块）都由同一个管程对象(&lsquo;this&rsquo;)所同步。如果一个线程已经拥有了一个管程对象上的锁，那么它就有权访问被这个管程对象同步的所有代码块。这就是可重入。线程可以进入任何一个它已经拥有的锁所同步着的代码块。</p>

<p>前面给出的锁实现不是可重入的。如果我们像下面这样重写Reentrant类，当线程调用outer()时，会在inner()方法的lock.lock()处阻塞住。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Reentrant2</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Lock</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">outer</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
</span><span class='line'>      <span class="n">inner</span><span class="o">();</span>
</span><span class='line'>      <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="nf">inner</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
</span><span class='line'>      <span class="c1">//do something</span>
</span><span class='line'>      <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用outer()的线程首先会锁住Lock实例，然后继续调用inner()。inner()方法中该线程将再一次尝试锁住Lock实例，结果该动作会失败（也就是说该线程会被阻塞），因为这个Lock实例已经在outer()方法中被锁住了。</p>

<p>两次lock()之间没有调用unlock()，第二次调用lock就会阻塞，看过lock()实现后，会发现原因很明显：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Lock</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">boolean</span> <span class="n">isLocked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span>
</span><span class='line'>      <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">while</span><span class="o">(</span><span class="n">isLocked</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">wait</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="n">isLocked</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>一个线程是否被允许退出lock()方法是由while循环（自旋锁）中的条件决定的。当前的判断条件是只有当isLocked为false时lock操作才被允许，而没有考虑是哪个线程锁住了它。</p>

<p>为了让这个Lock类具有可重入性，我们需要对它做一点小的改动：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Lock</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">boolean</span> <span class="n">isLocked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>  <span class="n">Thread</span>  <span class="n">lockedBy</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">lockedCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">Thread</span> <span class="n">callingThread</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
</span><span class='line'>      <span class="k">while</span><span class="o">(</span><span class="n">isLocked</span> <span class="o">&amp;&amp;</span> <span class="n">lockedBy</span> <span class="o">!=</span> <span class="n">callingThread</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">wait</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="n">isLocked</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>      <span class="n">lockedCount</span><span class="o">++;</span>
</span><span class='line'>      <span class="n">lockedBy</span> <span class="o">=</span> <span class="n">callingThread</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">curentThread</span><span class="o">()</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="na">lockedBy</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">lockedCount</span><span class="o">--;</span>
</span><span class='line'>
</span><span class='line'>          <span class="k">if</span><span class="o">(</span><span class="n">lockedCount</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">isLocked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>              <span class="n">notify</span><span class="o">();</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意到现在的while循环（自旋锁）也考虑到了已锁住该Lock实例的线程。如果当前的锁对象没有被加锁(isLocked = false)，或者当前调用线程已经对该Lock实例加了锁，那么while循环就不会被执行，调用lock()的线程就可以退出该方法。</p>

<p>除此之外，我们需要记录同一个线程重复对一个锁对象加锁的次数。否则，一次unblock()调用就会解除整个锁，即使当前锁已经被加锁过多次。在unlock()调用没有达到对应lock()调用的次数之前，我们不希望锁被解除。</p>

<p>现在这个Lock类就是可重入的了。</p>

<h2>锁的公平性</h2>

<p>Java的synchronized块并不保证尝试进入它们的线程的顺序。因此，如果多个线程不断竞争访问相同的synchronized同步块，就存在一种风险，其中一个或多个线程永远也得不到访问权 —— 也就是说访问权总是分配给了其它线程。这种情况被称作线程饥饿。为了避免这种问题，锁需要实现公平性。本文所展现的锁在内部是用synchronized同步块实现的，因此它们也不保证公平性。<a href="http://tutorials.jenkov.com/java-concurrency/starvation-and-fairness.html">饥饿和公平</a>中有更多关于该内容的讨论。</p>

<h2>在finally语句中调用unlock()</h2>

<p>如果用Lock来保护临界区，并且临界区有可能会抛出异常，那么在finally语句中调用unlock()就显得非常重要了。这样可以保证这个锁对象可以被解锁以便其它线程能继续对其加锁。以下是一个示例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
</span><span class='line'><span class="k">try</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">//do critical section code,</span>
</span><span class='line'>  <span class="c1">//which may throw exception</span>
</span><span class='line'><span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个简单的结构可以保证当临界区抛出异常时Lock对象可以被解锁。如果不是在finally语句中调用的unlock()，当临界区抛出异常时，Lock对象将永远停留在被锁住的状态，这会导致其它所有在该Lock对象上调用lock()的线程一直阻塞。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[blog template]]></title>
    <link href="http://shenzhang.github.io/blog/2000/01/01/template-blog/"/>
    <updated>2000-01-01T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2000/01/01/template-blog</id>
    <content type="html"><![CDATA[<p>This is a template file</p>
]]></content>
  </entry>
  
</feed>
