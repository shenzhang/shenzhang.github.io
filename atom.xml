<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Keep going]]></title>
  <link href="http://shenzhang.github.io/atom.xml" rel="self"/>
  <link href="http://shenzhang.github.io/"/>
  <updated>2014-04-09T22:06:52+08:00</updated>
  <id>http://shenzhang.github.io/</id>
  <author>
    <name><![CDATA[zshen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[maven杂谈(生命周期,插件绑定,effective-xx)]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/15/something-about-maven/"/>
    <updated>2013-09-15T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/15/something-about-maven</id>
    <content type="html"><![CDATA[<h2>1.生命周期</h2>

<h3>Clean</h3>

<pre><code>pre-clean
clean
post-clean
</code></pre>

<h3>Default</h3>

<pre><code>validate
initialize
generate-sources
process-sources
generate-resources
process-resources
compile
process-classes
generate-test-sources
process-test-sources
generate-test-resources
process-test-resources
test-compile
process-test-classes
test
prepare-package
package
pre-integration-test
integration-test
post-integration-test
verify
install
deploy
</code></pre>

<h3>Site</h3>

<pre><code>pre-site
site
post-site
site-deploy
</code></pre>

<h2>2.插件绑定</h2>

<p>maven在不同的生命周期中会按顺序进入不同的阶段，每个阶段又会执行与该阶段绑定的plugins。如何将plugins绑定到生命周期中呢，maven-compile-plugin又是怎么知道在每次的compile阶段执行的呢？</p>

<p>plugin绑定到生命周期中需要在pom.xml中的<build>=><plugins>中进行声明，有些是在pom.xml中，有些可能是在super pom中，有些甚至是maven默认的绑定，但是最终都会出现在effective pom中（mvn help:effective-pom查看)。</p>

<p>那么具体是在哪个阶段执行呢？看effective pom中对maven-compile-plugin的描述：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>  <span class="nt">&lt;plugin&gt;</span>
</span><span class='line'>    <span class="nt">&lt;artifactId&gt;</span>maven-compiler-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;version&gt;</span>2.3.2<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>    <span class="nt">&lt;executions&gt;</span>
</span><span class='line'>      <span class="nt">&lt;execution&gt;</span>
</span><span class='line'>        <span class="nt">&lt;id&gt;</span>default-testCompile<span class="nt">&lt;/id&gt;</span>
</span><span class='line'>        <span class="nt">&lt;phase&gt;</span>test-compile<span class="nt">&lt;/phase&gt;</span>
</span><span class='line'>        <span class="nt">&lt;goals&gt;</span>
</span><span class='line'>          <span class="nt">&lt;goal&gt;</span>testCompile<span class="nt">&lt;/goal&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/goals&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/execution&gt;</span>
</span><span class='line'>      <span class="nt">&lt;execution&gt;</span>
</span><span class='line'>        <span class="nt">&lt;id&gt;</span>default-compile<span class="nt">&lt;/id&gt;</span>
</span><span class='line'>        <span class="nt">&lt;phase&gt;</span>compile<span class="nt">&lt;/phase&gt;</span>
</span><span class='line'>        <span class="nt">&lt;goals&gt;</span>
</span><span class='line'>          <span class="nt">&lt;goal&gt;</span>compile<span class="nt">&lt;/goal&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/goals&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/execution&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/executions&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/plugin&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>主要是在phase节点和goals节点，上面的配置说明了maven-compile-plugin被分别绑定到了compile阶段和test-compile阶段，并且分别执行该插件的compile goal和testCompile goal。</p>

<p>另外有些plugin可能并没有在pom.xml中说明具体的执行阶段，那么就要看该插件中的/META-INF/maven/plugin.xml插件描述文件了，该描述文件说明了该plugin的前缀(goalPrefix)，所有的mojos或者说是goal，并且这些goal的名字以及默认的执行阶段，比如compile:testCompile节点就说明了&lt;phase&gt;test-compile&lt;/phase&gt;。因此如果没有在pom.xml中说明执行阶段的话，就按照该plugin的goal的自描述中的phase进行绑定。</p>

<h2>3.effective-xx</h2>

<p>maven有关于自己运行的配置文件settings.xml，该文件可以是$MAVEN_HOME/conf/settings.xml或者$USER/.m2/setttings.xml，并且后者会覆盖前者，可以通过mvn help:effective-settings查看相对于默认的settings.xml所改变的部分。</p>

<p>同样，前面提到的effective-pom也是由多个部分合并而来，首先是项目下的pom.xml，然后是maven的super pom($MAVEN_HOME/lib/maven-model-builder-x.x.x.jar#org/apache/maven/model/pom-x.x.x.xml)，还有一些是maven针对不同的生命周期默认绑定的插件信息($MAVEN_HOME/lib/maven-core-x.x.x.jar#/META-INF/plexus/components.xml)。最终的pom可以通过help:effective-pom查看)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[maven依赖的scope]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/13/scope-in-maven/"/>
    <updated>2013-09-13T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/13/scope-in-maven</id>
    <content type="html"><![CDATA[<p>maven中一些常用的scope及其介绍。</p>

<h3>compile:</h3>

<p>maven的默认依赖scope，并且会应用于所有的classpath，也就是说不论在compile, test compile, 还是直接用mvn来运行(runtime)都会起作用.</p>

<h3>runtime:</h3>

<p>在compile相关的阶段都不会起作用，仅仅是在运行(runtime)或者测试(test)的时候有效。</p>

<h3>provided:</h3>

<p>和compile类似，但是往往这些依赖不需要随应用一起发布，一般是由外部环境或者容器来提供，不需要自己准备，比如说servlet-api, jsp-api这些都可以由container提供。</p>

<h3>test:</h3>

<p>这个最好理解，仅仅是在测试的时候有用，compile和runtime都不需要</p>

<h3>system:</h3>

<p>有些依赖是仓库没有的，那么可以通过使用system范围来告诉maven在指定的本地路径上查找依赖。因此需要在dependency中指定systemPath元素，告诉maven依赖的具体位置。一般来说是不应该使用该范围的，很可能大家不能共享你的配置。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何针对缺少source包的jar添加source包]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/12/add-source-to-repository/"/>
    <updated>2013-09-12T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/12/add-source-to-repository</id>
    <content type="html"><![CDATA[<p>repository中的有些jar是没有对应的source的，比如在使用hadoop-core-1.0.4.jar包，但是由于缺少sources包，因此无法在依赖中查看源文件。</p>

<p>那么可以自己准备对应的源码包：hadoop-core-1.0.4-srouces.jar并安装到本地仓库中。</p>

<pre><code>mvn install:install-file -Dfile=e:\hadoop-core-1.0.4-sources.jar -DgroupId=org.apache.hadoop -DartifactId=hadoop-core -Dversion=1.0.4 -DgeneratePom=false -Dpackaging=java-source
</code></pre>

<p>注意<code>packaging=java-source</code>，不要使用<code>packaging=jar</code></p>

<p>从中我们可以推测maven打包和依赖查找的机制：</p>

<p>我们发布一个包，指定了groupId, artifacteId, version, packaging，那么maven会自动帮我们给要发布的文件重命名：</p>

<pre><code>packaging=jar =&gt; artifacteId-version.jar
packaging=java-srouce =&gt; artifacteId-version-sources.jar
packaging=java-doc =&gt; artifacteId-version-doc.jar
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[javascript测试框架jasmine]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/11/jasmine/"/>
    <updated>2013-09-11T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/11/jasmine</id>
    <content type="html"><![CDATA[<p><a href="http://pivotal.github.io/jasmine/">jasmine</a>是一个javascript的测试框架，不同于qunit等其他测试框架，它可以用于很多js环境，比如web，nodejs等。它上手简单，并且官方有很详细的实例和描述，这里将大部分实用的api和用法记录下来。</p>

<!-- more -->


<h2>一个DEMO</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">describe</span><span class="p">(</span><span class="s2">&quot;this is a test suite&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">foo</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// setup function run before every spec</span>
</span><span class='line'>  <span class="nx">beforeEach</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">foo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">foo</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="c1">// teardown function run before ever spec</span>
</span><span class='line'>  <span class="nx">afterEach</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">foo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">it</span><span class="p">(</span><span class="s2">&quot;this is a test spec 1&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">it</span><span class="p">(</span><span class="s2">&quot;this is a test spec 2&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="nx">expect</span><span class="p">(</span><span class="kc">true</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<h2>jasmine提供的全局方法</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">describe</span><span class="p">(</span><span class="nx">testSuiteName</span><span class="p">,</span> <span class="nx">func</span><span class="p">)</span> <span class="c1">//定义一个test suite，其中可以包含it定义的spec，并且describe可以嵌套</span>
</span><span class='line'><span class="nx">xdescribe</span><span class="p">(</span><span class="nx">testSuiteName</span><span class="p">,</span> <span class="nx">func</span><span class="p">)</span> <span class="c1">//类似于JUnit的@Ignore，忽略这个test suite</span>
</span><span class='line'><span class="nx">it</span><span class="p">(</span><span class="nx">specName</span><span class="p">,</span> <span class="nx">func</span><span class="p">)</span> <span class="c1">//定义一个test unit(spec)</span>
</span><span class='line'><span class="nx">xit</span><span class="p">(</span><span class="nx">specName</span><span class="p">,</span> <span class="nx">func</span><span class="p">)</span> <span class="c1">//类似于@Ignore，忽略这个unit</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">actualValue</span><span class="p">)</span> <span class="c1">//assert</span>
</span><span class='line'><span class="nx">beforeEach</span><span class="p">(</span><span class="nx">func</span><span class="p">)</span> <span class="c1">//定义一个start function，在每个unit之前运行</span>
</span><span class='line'><span class="nx">afterEach</span><span class="p">(</span><span class="nx">func</span><span class="p">)</span> <span class="c1">//定义一个deardown function, 在每个unit之后运行</span>
</span><span class='line'><span class="nx">spyOn</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">funcName</span><span class="p">)</span> <span class="c1">//监视obj.funcName函数的调用情况</span>
</span><span class='line'>
</span><span class='line'><span class="nx">runs</span><span class="p">(</span><span class="nx">fun</span><span class="p">)</span>
</span><span class='line'><span class="nx">waitsFor</span><span class="p">(</span><span class="nx">fun</span><span class="p">,</span> <span class="nx">msg</span><span class="p">,</span> <span class="nx">timeout</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nx">jasmine</span><span class="p">.</span><span class="nx">createSpy</span><span class="p">(</span><span class="nx">spyName</span><span class="p">)</span> <span class="c1">//定义一个spy函数，该函数可以被任意调用，主要用于mock</span>
</span><span class='line'><span class="nx">jasmine</span><span class="p">.</span><span class="nx">createSpyObj</span><span class="p">(</span><span class="nx">objName</span><span class="p">,</span> <span class="nx">spyFuncNames</span><span class="p">)</span> <span class="c1">//定义一个spy对象，并且该对象具有spyFuncNames数组包含的方法。主要用于mock</span>
</span><span class='line'><span class="nx">jasmine</span><span class="p">.</span><span class="nx">any</span><span class="p">(</span><span class="nx">construct</span><span class="o">|</span><span class="nx">className</span><span class="p">)</span> <span class="c1">//配合expect使用，检测该对象是否是指定类型，如：expect(12).toEqual(jasmine.any(Number));</span>
</span><span class='line'><span class="nx">jasmine</span><span class="p">.</span><span class="nx">Clock</span><span class="p">.</span><span class="nx">useMock</span> <span class="c1">//启用模拟timer</span>
</span><span class='line'><span class="nx">jasmine</span><span class="p">.</span><span class="nx">Clock</span><span class="p">.</span><span class="nx">tick</span> <span class="c1">//手动触发一个timer事件</span>
</span></code></pre></td></tr></table></div></figure>


<h2>expectation api</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">//a === b</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">not</span><span class="p">.</span><span class="nx">toBe</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">//!(a===b)</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">//a是否和b相等，可以比较普通类型或者对象</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toMatch</span><span class="p">(</span><span class="nx">reg</span><span class="p">)</span> <span class="c1">//a是否符合reg的正则表达式</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeDefined</span><span class="p">()</span> <span class="c1">//o.a是否被定义</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeUnDefined</span><span class="p">()</span> <span class="c1">//o.a是否没有被定义</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeNull</span><span class="p">()</span> <span class="c1">//a === null ?</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeTruthy</span><span class="p">()</span> <span class="c1">//if (a) 是否成立</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeFalsy</span><span class="p">()</span> <span class="c1">//if (!a) 是否成立</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">array</span><span class="p">).</span><span class="nx">toContain</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">//数组array里是否有b</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeLessThan</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">//a &lt; b ?</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">a</span><span class="p">).</span><span class="nx">toBeGreaterThan</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">//a &gt; b?</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">func</span><span class="p">).</span><span class="nx">toThrow</span><span class="p">()</span> <span class="c1">//func被调用的时候是否抛出异常</span>
</span></code></pre></td></tr></table></div></figure>


<h2>spy</h2>

<p>jasmine可以对指定的函数进行调用监视，相关的函数有spyOn, jasmine.createSpy(), jasmine.createSpyObj()，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">hello</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello world&#39;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">spyOn</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么对obj.hello的调用都会被jasmine截获，但是实际上是不会真正调用obj.hello的，除非：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">sypOn</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">).</span><span class="nx">andCallThough</span><span class="p">()</span> <span class="c1">// 调用obj.hello()时，最终会真正调用console.log</span>
</span><span class='line'>
</span><span class='line'><span class="nx">spyOn</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">).</span><span class="nx">andReturn</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span> <span class="err">让</span><span class="nx">obj</span><span class="p">.</span><span class="nx">hello</span><span class="p">()</span><span class="err">永远返回</span><span class="mi">123</span>
</span><span class='line'>
</span><span class='line'><span class="nx">spyOn</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">).</span><span class="nx">andCallFake</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>             <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;welcome&#39;</span><span class="p">);</span>
</span><span class='line'>          <span class="p">});</span>  <span class="c1">// 该方法会让obj.hello()委派到console.log(&#39;welcome&#39;)上，也就是执行提供的函数内容。</span>
</span></code></pre></td></tr></table></div></figure>


<p>从此可以看出Jasmine确实考虑的非常周到</p>

<h2>expectation for spy</h2>

<p>以下expect要配合spyOn, jasmine.createSpy(), jasmine.createSpyObj()来使用</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">spyOn</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="s1">&#39;setBar&#39;</span><span class="p">);</span> <span class="c1">// 监视foo.setBar方法</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">setBar</span><span class="p">).</span><span class="nx">toHaveBeenCalled</span><span class="p">()</span><span class="o">:</span> <span class="err">该方法是否被调用过</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">setBar</span><span class="p">.</span><span class="nx">calls</span><span class="p">.</span><span class="nx">length</span><span class="p">).</span><span class="nx">toEqual</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">:</span> <span class="err">该方法是否被调用了两次</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">setBar</span><span class="p">).</span><span class="nx">toHaveBeenCalledWith</span><span class="p">(</span><span class="mi">456</span><span class="p">,</span> <span class="s1">&#39;another param&#39;</span><span class="p">)</span><span class="o">:</span> <span class="err">该方法是否被调用过，并且调用的参数是</span><span class="o">:</span><span class="mi">456</span><span class="err">和</span><span class="s1">&#39;another param&#39;</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">setBar</span><span class="p">.</span><span class="nx">mostRecentCall</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]).</span><span class="nx">toEqual</span><span class="p">(</span><span class="mi">456</span><span class="p">)</span><span class="o">:</span> <span class="err">最近一次调用的第一个参数是否是</span><span class="mi">456</span>
</span><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">setBar</span><span class="p">.</span><span class="nx">calls</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]).</span><span class="nx">toEqual</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span><span class="o">:</span> <span class="err">第一次调用的第一个参数是否是</span><span class="mi">123</span>
</span></code></pre></td></tr></table></div></figure>


<h2>HTML Reporter</h2>

<p>jasmine还可以控制执行以及测试结果的输出，比如下面的代码就是将测试报告输出到html页面上：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">jasmineEnv</span> <span class="o">=</span> <span class="nx">jasmine</span><span class="p">.</span><span class="nx">getEnv</span><span class="p">();</span>
</span><span class='line'>  <span class="nx">jasmineEnv</span><span class="p">.</span><span class="nx">updateInterval</span> <span class="o">=</span> <span class="mi">250</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">htmlReporter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">jasmine</span><span class="p">.</span><span class="nx">HtmlReporter</span><span class="p">();</span>
</span><span class='line'>  <span class="nx">jasmineEnv</span><span class="p">.</span><span class="nx">addReporter</span><span class="p">(</span><span class="nx">htmlReporter</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">jasmineEnv</span><span class="p">.</span><span class="nx">specFilter</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">spec</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">htmlReporter</span><span class="p">.</span><span class="nx">specFilter</span><span class="p">(</span><span class="nx">spec</span><span class="p">);</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">currentWindowOnload</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span><span class="p">;</span>
</span><span class='line'>  <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">currentWindowOnload</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">currentWindowOnload</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;.version&#39;</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">jasmineEnv</span><span class="p">.</span><span class="nx">versionString</span><span class="p">();</span>
</span><span class='line'>    <span class="nx">execJasmine</span><span class="p">();</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">function</span> <span class="nx">execJasmine</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">jasmineEnv</span><span class="p">.</span><span class="nx">execute</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">})();</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SeaJS原理解析]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/10/inspect-seajs/"/>
    <updated>2013-09-10T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/10/inspect-seajs</id>
    <content type="html"><![CDATA[<p>对于前台javascript代码的模块化组织和依赖加载目前业界比较流行的有RequireJS和玉伯写的的SeaJS。看了下玉伯本人对这两款模块加载器的对比分析，个人还是比较喜欢SeaJS的，尤其是RequireJS在加载一个模块后就立刻执行的做法表示不能理解，可能也跟具体的应用场景有关系，不能用SeaJS的风格来使用RequireJS吧。</p>

<p>今天粗略看了下SeaJS的源码，不对源码的细节进行分析，仅仅对其模块的组织和加载原理做简单的分析，知道了原理剩下的就是代码效率和浏览器兼容性的问题了。</p>

<p>主要解决一下问题：</p>

<ol>
<li>怎么用SeaJS</li>
<li>怎么解析、加载和执行模块</li>
<li>模块标识符（依赖名）的path解析</li>
</ol>


<!--more-->


<h2>怎么用SeaJS</h2>

<p>模块A:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">define</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">require</span><span class="p">,</span> <span class="nx">exports</span><span class="p">,</span> <span class="nx">module</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">addModule</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;add&#39;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">exports</span><span class="p">.</span><span class="nx">hello</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello &#39;</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="s1">&#39;, 1 + 3 = &#39;</span> <span class="o">+</span> <span class="nx">addModule</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>模块add：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">define</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">require</span><span class="p">,</span> <span class="nx">exports</span><span class="p">,</span> <span class="nx">module</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">exports</span><span class="p">.</span><span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>页面入口:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>[html]
</span><span class='line'><span class="cp">&lt;!doctype html&gt;</span>
</span><span class='line'><span class="nt">&lt;html&gt;</span>
</span><span class='line'><span class="nt">&lt;head&gt;</span>
</span><span class='line'>  <span class="nt">&lt;title&gt;</span>seajs demo<span class="nt">&lt;/title&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span> <span class="na">src=</span><span class="s">&quot;lib/sea-debug.js&quot;</span> <span class="na">id=</span><span class="s">&quot;seajsnode&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</span><span class='line'>  <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nx">seajs</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">A</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">A</span><span class="p">.</span><span class="nx">hello</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="nt">&lt;/script&gt;</span>
</span><span class='line'><span class="nt">&lt;/head&gt;</span>
</span><span class='line'><span class="nt">&lt;body&gt;</span>
</span><span class='line'><span class="nt">&lt;/body&gt;</span>
</span><span class='line'><span class="nt">&lt;/html&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>是不是很简单，这就是一个典型的模块依赖问题: A是页面入口模块，A->add模块。</p>

<h2>怎么解析、加载和执行模块</h2>

<p>不管是用seajs.use也好，还是在module中使用require也好，都是在告诉seajs去加载一个指定的模块，而且中本质上来说都是异步递归加载的，特别是:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">seajs</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="s1">&#39;module&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">entry</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="p">...</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种形式一看就知道是异步加载。但是在module中:<code>var m = require('mmm');</code>却让人感觉是同步加载，实际上不是这样的，当在模块里调用require时，对应的module文件都已经被load并执行了。</p>

<p>如果moduleA->moduleB，那么流程实际上是这样的：</p>

<p>1.通过fetch函数去加载moduleA</p>

<p>2.加载回来后肯定浏览器会自动执行define(factory)语句，在seajs流程里叫做解析(resolve)，但是factory方法不会被立刻调用(execute)。</p>

<p>3.seajs拿到factory方法，并调用factory.toString()来拿到方法体，通过一个很长的正则表达式提取出其中的require语句(因此seajs对require的写法要求很严格，并且require的模块名参数只能是字符串直接量)，进而拿到moduleA所依赖的所有module(moduleB)。保存moduleA的信息，比如说factory，准备加载moduleB。</p>

<p>4.开始加载moduleB，加载过程同moduleA，但是最后当拿到moduleB的factory方法，并进行依赖的进一步解析时，发现moduleB没有进一步的依赖了，就开始进入执行(execute)过程。</p>

<p>5.经过一系列的递归加载，可以说形成了一个加载栈，execute的过程实际上是从找execute入口函数的过程。回退栈（模块有依赖关系，栈的回退就是依赖的反向关系），直到发现有一个module对象有callback属性，然后就开始执行这个callback。实际上这个有callback属性的module就是seajs的启动方法，或者说use方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// Use function is equal to load a anonymous module</span>
</span><span class='line'><span class="nx">Module</span><span class="p">.</span><span class="nx">use</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">ids</span><span class="p">,</span> <span class="nx">callback</span><span class="p">,</span> <span class="nx">uri</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">mod</span> <span class="o">=</span> <span class="nx">Module</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">uri</span><span class="p">,</span> <span class="nx">isArray</span><span class="p">(</span><span class="nx">ids</span><span class="p">)</span> <span class="o">?</span> <span class="nx">ids</span> <span class="o">:</span> <span class="p">[</span><span class="nx">ids</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">mod</span><span class="p">.</span><span class="nx">callback</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">exports</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">uris</span> <span class="o">=</span> <span class="nx">mod</span><span class="p">.</span><span class="nx">resolve</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">uris</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">exports</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">cachedMods</span><span class="p">[</span><span class="nx">uris</span><span class="p">[</span><span class="nx">i</span><span class="p">]].</span><span class="nx">exec</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">callback</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">global</span><span class="p">,</span> <span class="nx">exports</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">delete</span> <span class="nx">mod</span><span class="p">.</span><span class="nx">callback</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">mod</span><span class="p">.</span><span class="nx">load</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，只有使用use方法加载的module才有callback属性，并且一旦callback被调用之后就会delete mod.callback来删除该属性(比如A同时依赖B和C，那么就会出现两个加载栈，回溯的时候这个callback就会被掉用两次，因此第一次调用之后就会被delete掉。那seajs是如何保证callback被调用的时候所有的依赖都已经加载完毕了呢？实际上seajs的每个模块不但有依赖关系，还有依赖关系的计数，也就是如果A->B,B同时依赖C和D，那么B的依赖计数就是2，每当C或者D被加载完毕后都会让B的计数减1，直到为0的时候B才会去通知A。因此，当callback被调用的时候，其下的所有依赖模块都已经是被resolve完毕的。</p>

<p>6.当进入到execute流程时，所有的模块不是集中被execute的，而是当遇到require(&lsquo;moduleX&rsquo;)的时候才会去检查moduleX是否被execute，如果已经被其他时序execute过了，那么就直接返回上次execute后的结果（模块exports对象）；如果没有，则开始第一次execute过程，execute过程实际上就是调用该模块的factory方法的过程，也是模块被真正定义和接口被exports的过程，由于仅仅是方法调用，因此是同步执行的(var x = require(&lsquo;moduleX&rsquo;)仅仅是个执行factory方法的过程，不涉及异步load）。</p>

<p><em>OK，流程就是这样了，但是需要强调几个事情：</em></p>

<p>a.seajs加载模块的方法就是往head头插入script节点的方法</p>

<p>b.创建和插入的script元素被设置了async=true属性，因此同一层次的所有依赖module可以并行下载</p>

<p>c.模块的解析和execute过程中间都有缓存机制，不会出现重复加载和执行的现象。</p>

<p>d.seajs是如何知道一个模块加载完毕了？看下面的代码就明白了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'>  <span class="nx">node</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">READY_STATE_RE</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">readyState</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// Ensure only run once and handle memory leak in IE</span>
</span><span class='line'>      <span class="nx">node</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kc">null</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// Remove the script to reduce memory leak</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isCSS</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">data</span><span class="p">.</span><span class="nx">debug</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">head</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// Dereference the node</span>
</span><span class='line'>      <span class="nx">node</span> <span class="o">=</span> <span class="kc">null</span>
</span><span class='line'>
</span><span class='line'>      <span class="nx">callback</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>模块标识符（依赖名）的path解析</h2>

<p>很多人对seajs的模块标识符解析有点迷糊，实际上该过程是被封装在了id2Uri(id, refUri)方法中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">id2Uri</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">refUri</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">id</span><span class="p">)</span> <span class="k">return</span> <span class="s2">&quot;&quot;</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">id</span> <span class="o">=</span> <span class="nx">parseAlias</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
</span><span class='line'>  <span class="nx">id</span> <span class="o">=</span> <span class="nx">parsePaths</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
</span><span class='line'>  <span class="nx">id</span> <span class="o">=</span> <span class="nx">parseVars</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
</span><span class='line'>  <span class="nx">id</span> <span class="o">=</span> <span class="nx">normalize</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">uri</span> <span class="o">=</span> <span class="nx">addBase</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">refUri</span><span class="p">)</span>
</span><span class='line'>  <span class="nx">uri</span> <span class="o">=</span> <span class="nx">parseMap</span><span class="p">(</span><span class="nx">uri</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="nx">uri</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>大致过程如下：</p>

<p>1.检查别名,这个在config中配置</p>

<p>2.path检查</p>

<p>3.路径中的变量替换</p>

<p>4.标准化路径，可以理解成将/a/b/c改为/a/b/c.js</p>

<p>5.合成完整路径，addBase:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">addBase</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">refUri</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">ret</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">first</span> <span class="o">=</span> <span class="nx">id</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Absolute</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nx">ABSOLUTE_RE</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">id</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">ret</span> <span class="o">=</span> <span class="nx">id</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// Relative</span>
</span><span class='line'>  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">first</span> <span class="o">===</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">ret</span> <span class="o">=</span> <span class="nx">realpath</span><span class="p">((</span><span class="nx">refUri</span> <span class="o">?</span> <span class="nx">dirname</span><span class="p">(</span><span class="nx">refUri</span><span class="p">)</span> <span class="o">:</span> <span class="nx">data</span><span class="p">.</span><span class="nx">cwd</span><span class="p">)</span> <span class="o">+</span> <span class="nx">id</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// Root</span>
</span><span class='line'>  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">first</span> <span class="o">===</span> <span class="s2">&quot;/&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">cwd</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">ROOT_DIR_RE</span><span class="p">)</span>
</span><span class='line'>    <span class="nx">ret</span> <span class="o">=</span> <span class="nx">m</span> <span class="o">?</span> <span class="nx">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">id</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="nx">id</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// Top-level</span>
</span><span class='line'>  <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">ret</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">base</span> <span class="o">+</span> <span class="nx">id</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="nx">ret</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>6.map替换</p>

<p>最后的id就是解析的结果</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[setTimeout和setInterval]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/05/settimeout-and-setinterval/"/>
    <updated>2013-09-05T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/05/settimeout-and-setinterval</id>
    <content type="html"><![CDATA[<p>setTimeout和setInterval是浏览器环境中两个可用的定时器方案。在使用过程中曾经遇到了两个坑，在这里记录下：</p>

<h3>setInterval:</h3>

<p>可以定期按照一定的频率做一个事情，比如funA。但是如果funA中抛出了异常会怎样呢？  firefox和chrome不会因为抛出异常而做出什么奇怪的事情，毕竟调用setInterval只是告诉浏览器我要定期做一个事情，哪怕这个事情出错了；但是IE却在出现异常后停止继续定期做这个事情，所以千万要保证funA中的事情一定不要有异常出现。</p>

<h3>setTimeout:</h3>

<p>延时一段时间做某个事情funcB。比如：</p>

<p>setTimeout(tick, 1000)会在1秒之后将tick加入到事件队列中准备执行，并且tick方法的arguments是空的，但是在firefox13以下的tick的arguments却不一定是空的，有可能会有一个表示延时时间的数值(小于0)来表示执行该函数比预期时间推后了多少。新版本的firefox已经解决了该问题，但是还是不要试图在tick方法中根据arguments的数量来决定行为。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thread的状态]]></title>
    <link href="http://shenzhang.github.io/blog/2013/09/04/status-of-thread/"/>
    <updated>2013-09-04T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/09/04/status-of-thread</id>
    <content type="html"><![CDATA[<p>每个Thread在创建出来之后就有一个状态信息，可以通过Thread.getState()来获得该thread的状态，虽然javadoc中对thread的状态有详细的描述，但是很多人还是不能很好的说出所有的状态，以及不同状态的含义，理解这些状态还有助于使用java的线程分析工具，比如jstack</p>

<p>Thread的状态是由Thread.State枚举表示的，有下面的6个值：</p>

<h3>NEW</h3>

<p>当线程刚被new出来，并且没有start的时候处于NEW状态</p>

<h3>BLOCKED</h3>

<p>线程被阻塞，一般是由于锁的原因等待进入临界区时候的状态</p>

<h3>RUNNABLE</h3>

<p>正在运行，就算是没有获得CPU时间片的线程也是在RUNNABLE</p>

<h3>WAITING</h3>

<p>顾名思义，线程处于等待状态。它正在等待其他的操作被触发，比如wait()后等待notify()或者notifyAll()；Thread.join()后等待目标线程被结束；LockSupport.park()后等待LockSupport.unpark()。</p>

<p>注意，在调用wait()后会首先进入WAITING状态，如果被notify()了，并且无法获得锁并进入临界区，那么就在BLOCKED；如果进入临界区了，那么就是RUNNABLE</p>

<h3>TIMED_WAITING</h3>

<p>相比WAITING状态，只是多了一个时间参数，比如Thread.sleep(10)，object.wait(10)等等。</p>

<h3>TERMINATED</h3>

<p>运行完毕</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解GC暂停 - Hotspot中的minor gc[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2013/08/16/gc-stop-minor-gc-in-hotspot/"/>
    <updated>2013-08-16T02:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/08/16/gc-stop-minor-gc-in-hotspot</id>
    <content type="html"><![CDATA[<p><a href="http://blog.ragozin.info/2011/06/understanding-gc-pauses-in-jvm-hotspots.html">原文链接</a></p>

<p>当JVM进行垃圾搜集的时候会Stop-The-World暂停，它们是java应用程序的天敌。Hotspot JVM多种先进的、被优化的垃圾收集器，但是要想找到一个最优的配置需要首先了解垃圾搜集算法的机制。这篇文章介绍了GC在STW时怎么使用CPU，并且还介绍了一个新生代的垃圾搜集算法。</p>

<h2>堆结构</h2>

<p>大多数现代GC算法都是分代收集的，这意味着java的堆被划分为了多个空间。不同的空间用其中保存的对象的年龄划分。对象首先被分配到新生代，然后经过多次存活后，最终被放到了老年代。这个是基于“大多数的对象在创建后很快就会消亡”的假设。所有的Hotspot垃圾收集器都将内存划分为5个部分（对于G1收集器，空间可能不是连续的）。</p>

<p><img src="http://shenzhang.github.io/images/2013/08/java_heap_struct.png"></p>

<ol>
<li>Eden:eden区是对象被分配的地方</li>
<li>Survivor: Survivor区被用来在young gc或者minor gc中接收存活的对象</li>
<li>Tenured:Tenured区是保存长时间存活的对象</li>
<li>Permanent:Permanent是供JVM自己使用，比如classes或者被JIT编译后的代码，它的行为和tenured区类似，因此在文章的后面我们将忽略该区域。</li>
</ol>


<p>Eden和2个Survivor区在一起被称作新生代（yound space)。</p>

<h3>Hotspot GC算法</h3>

<ol>
<li>串行垃圾收集(-XX:+UseSerialGC)</li>
<li>新生代并行，老年代串行的分代收集(-XX:+UseParallelGC)</li>
<li>新生代和老年代都并行的分代收集(-XX:+UseParallelOldGC)</li>
<li>CMS收集算法和串行化的新生代收集器(-XX:+UseConcMarkSweep, -XX:-UseParNewGC)</li>
<li>CMS收集算法和并行化的新生代收集器(-XX:+UseConcMarkSweep, -XX:+UseParNewGC)</li>
<li>G1收集算法(-XX:+UseG1GC)</li>
</ol>


<p>除了G1之外，其他所有的垃圾收集算法在新生代部分都使用了类似的算法（串行或者并行）</p>

<h3>写屏障(Write barrier)</h3>

<p>分代垃圾收集器的关键点在于，是否有必要每次都对整个java堆进行垃圾收集，还是对其中的一部分进行收集（比如新生代)。但是JVM为了实现这个效果，需要实现一个特殊的机制“写屏障”。在Hotspot中实现了两种类型的写屏障：dirty cards和snaphot-at-the-beginning(SATB)。SATB被用于G1算法中（该文没有对其描述）。其他所有的垃圾收集算法都使用dirty cards。</p>

<h3>Dirty cards写屏障(卡片标记)</h3>

<p>Dirty cards写屏障的原理非常简单。每当应用程序改变内存中的引用时，都需要标记该内存页是脏(dirty)的。JVM中有一个特殊的卡片表(card table)，每512字节的页都对应其中的1个字节。</p>

<p><img src="http://shenzhang.github.io/images/2013/08/card-table.png"></p>

<h3>新生代垃圾收集算法</h3>

<p>绝大部分的对象会被首先分配到eden区（除了在一些特殊的情况下，对象可能会直接被分配到老年代）。为了更高效的分配内存，Hotspot使用了线程本地分配块（thread local allocation block, TLAB)来分配新的对象，但是TLAB本身又被分配在eden区。一旦eden区满了就会触发minor gc。minor gc的目标是清理eden区，释放内存。在这里使用的是拷贝算法，存活的对象被拷贝到另外的一块区域，之前的区域的所有空间被标记为可用（free）。但是在开始垃圾收集之前，JVM首先需要找到根（root）引用，所有用于minor gc的根引用是来自堆栈的引用或者来自老年代的引用。</p>

<p>通常情况下，搜集来自于老年代的引用需要扫描整个老年代对象的所有引用，因此我们需要写屏障（write-barrier）。所有在新生代中的对象都是在上次写屏障被复位之后分配的，也就意味着非脏(no-dirty)页是不可能引用新生代的对象，最后意味着我们没必要扫描整个老年代，而只需要扫描dirty pages中的对象即可。</p>

<p><img src="http://shenzhang.github.io/images/2013/08/dirty-pages.png"></p>

<p>最开始的dirty cards是空的，并且开始young gc后，JVM拷贝eden和其中一个survivor中存活的对象到另外一个survivor区。JVM只需要花费时间在存活对象上，拷贝和再分配（relocate）对象也需要更新指向它们的引用。</p>

<p><img src="http://shenzhang.github.io/images/2013/08/dirty-pages1.png"></p>

<p>当JVM更新移动后的对象的引用时，内存也同时也被修改了，自然会打上dirty的标记。最终在我们下次开始young gc的时候，只有位于dirty pages中的页才有可能引用新生代的对象。</p>

<p><img src="http://shenzhang.github.io/images/2013/08/dirty-pages2.png"></p>

<h3>对象升级</h3>

<p>如果对象没有在young gc中被清除，那么最终会被拷贝到老年代。对象升级会在下述情况下发生：</p>

<ol>
<li>-XX:+AlwaysTenure:让JVM直接将eden中的对象升级到老年代，而不通过survivor区（survivor区在这里不再使用）</li>
<li>其中一个survivor区已经满了，那么所有剩下的存活对象都直接升级到老年代。</li>
<li>如果对象在新生代的垃圾收集中存活了足够多的周期，就会被升级到老年代（存活周期数通过–XX:MaxTenuringThreshol选项和-XX:TargetSurvivorRatio选项调整）</li>
</ol>


<h3>对象直接被分配到老年代</h3>

<p>如果我们可以将存活时间较长的对象直接分配到老年代，那么我们会获得性能提升。但是很不幸，我们无法告诉JVM这么做。但是仍然还是有一些情况，对象可以直接被分配到老年代：</p>

<ol>
<li>-XX:PretenureSizeThreshold=<n>：告诉JVM如果对象的大小大于<n>时，就可以直接将该对象分配到老年代。</li>
<li>如果对象的大小大于了eden区，那么也会直接分配到老年代。</li>
</ol>


<p>不同于应用程序对象，系统级的对象会直接分配到永久带。</p>

<h3>并行执行</h3>

<p>在young gc中的大部分任务都可以并行执行。如果有多个CPU可用，那么JVM可以充分利用它们以减少STW的时间。可以通过选项–XX:ParallelGCTreads=<n>来告诉JVM使用多少个线程来执行GC。默认情况下，JVM会使用当前可用的CPU数量作为GC的线程数。但是串行版的收集器会忽律给选项，因为它只使用一个CPU线程。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解GC暂停 - Hotspot中的CMS[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2013/08/16/gc-stop-cms-in-hotspot/"/>
    <updated>2013-08-16T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/08/16/gc-stop-cms-in-hotspot</id>
    <content type="html"><![CDATA[<p><a href="http://blog.ragozin.info/2011/06/understanding-gc-pauses-in-jvm-hotspots_02.html">原文链接</a></p>

<p>Concurrent-Mark-Sweep(CMS)是Hotspot JVM中的一个短停顿垃圾回收器。CMS在回收内存时做的大部分工作都可以和应用程序并发执行（不用暂停应用程序）。但是仍然需要短暂的Stop-The-World暂停。这篇文章会介绍这个暂停的原因以及如何减少这样的暂停。</p>

<h2>CMS基础</h2>

<p>Hotspot中的CMS收集器是分代搜集的，因此整个java堆被分为了新生代和老年代，并且它们可以独立进行搜集。对于新生代Hotspot通常使用的是拷贝算法。要想开启CMS收集器，需要在命令行参数里指定-XX:+UseConcMarkSweepGC选项。</p>

<p>CMS被用来搜集老年代，一个CMS搜集周期包括以下阶段：</p>

<ol>
<li>Inital mark:CMS在这个阶段搜集所有的根(root)引用，并且是STW的。</li>
<li>Concurrent mark:这个阶段会与应用程序并发执行，在该阶段垃圾收集器会遍历老年代的所有对象(从root开始)，将存活的对象标记出来。</li>
<li>Concurrent pre clean:这是另外一个并发阶段，主要也是用于标记操作，它会找到从上次标记(mark)之后改变了的引用。这个阶段最主要的目的是减少remark阶段的STW时间。</li>
<li>Remark：一旦Concurrent mark结束了，垃圾收集器需要进入STW暂停，在暂停的时候找到所有从上次mark之后所有被改变了的引用。</li>
<li>Concurrent sweep:垃圾收集器在该阶段会扫描整个老年代，并且回收不再使用的内存。</li>
<li>Concurrent reset：在CMS周期结束后，一些数据结构需要在下次周期开始之前被重置。</li>
</ol>


<p>不同于其他大多数垃圾收集器，CMS不会对老年代的堆内存进行整理。CMS没有对内存对象进行移动以便让为使用的空间保持连续，它会维护所有空闲内存段的列表。这样CMS避免了对内存重新布局的开销（对内存重新布局需要STW），但是负面效果就是会产生内存碎片。为了减少产生内存碎片的风险，CMS会对对象尺寸进行统计，并且针对对象的不同尺寸来维护空闲列表。</p>

<h2>CMS暂停时间</h2>

<p>CMS本身只有两个暂停点，但是你的应用程序执行新生代的垃圾回收时同样会进行暂停。</p>

<h2>Inital mark</h2>

<p>在inital mark阶段，CMS会遍历老年代的所有根引用。这包括：</p>

<ol>
<li>来自于线程栈的引用</li>
<li>来自于新生代的引用</li>
</ol>


<p>来自于线程栈的引用会搜集的很快（不超过1毫秒），但是搜集来自于新生代的引用就依赖于新生代对象的多少了。通常inital mark会在新生代gc完毕后开始，所以eden区这个时候时空的，并且其中一个survivor区里面也仅仅包含了存活下来的对象。Survivor区通常很小，因此在young gc完成后执行inital mark会很快，不超过毫秒。但是，如果inital mark在eden区满的时候开启，那么将会花费很长的时间（往往比young gc本身都还要长）</p>

<p>一旦CMS收集器被触发了，JVM会等待一段时间，让young gc完成后再开始inital mark。JVM配置参数-XX:CMSWaitDuration=<t>可以用来配置CMS等待多长时间才开始inital mark。如果你不希望长时间的inital mark暂停，那么你可以配置该选项，让等待时间略微长于你的应用中执行一次young gc所需要的时间。</p>

<h2>Remark</h2>

<p>大多数的标记（marking）可以和应用程序并行执行，但是也不是绝对的，因为有可能应用会在mark阶段修改对象引用图。当concurrent mark结束后，垃圾收集器会暂停应用程序，并且进行重复的标记以保证所有可达的的对象都已经标记为存活状态。但是收集器不需要遍历整个对象图，它仅仅需要遍历哪些自从上次标记（marking）阶段之后被修改过的引用（确切的说是从上次pre clean阶段之后）。卡片表（card table)被用来标记那些老年代中被修改的内存区域，但是新生代和堆栈部分还是需要被重新扫描一遍。</p>

<p>通常情况下remark阶段大部分时间被花费在了扫描新生代部分。如果在开始remark之前对新生代进行了gc，那么这个时间会大大缩短。我们可以加上-XX:+CMSScanvengeBeforeRemark选项来让JVM在开始remark之前强制进行新生代的gc。就算新生代是空的，remark阶段还是会对老年代中已经修改的引用进行扫描，这个所花费的时间和新生代gc暂停时间差不多。</p>

<h2>什么时候会触发CMS</h2>

<p>不同于其他老年代STW收集器，CMS搜集周期在老年代满了之前就需要开始（其他老年代收集器只需要老年代满的时候出发，而CMS需要在老年代没满的时候就触发）。CMS收集器在老年代的可用空间达到一定的阈值时（这个阈值可根据JVM在运行中搜集的统计信息或者参数来决定），并且CMS可能会推迟到下一次young gc触发之后才开始。普通的对象只会在yong gc的过程中被分配到老年代，因此CMS一般是在yong gc发生之后才开始，并且这样也会让initial mark变得很小。但是在某些情况下，对象可能会直接被分配在老年代，并且CMS开始的时候eden区可能具有很多对象。这个时候inital mark会多耗费10-100倍的时间，这个情况是非常糟糕的。通常这种情况只会在分配很大对象的时候（好几M大小的数组）。为了避免这种长暂停，你可以配置-XX:CMSWaitDuration选项。</p>

<h2>配置CMS开始的固定阈值</h2>

<p>你可以配置固定的老年代充满比例阈值来触发CMS gc：</p>

<pre><code>‑XX:+UseCMSInitiatingOccupancyOnly 
‑XX:CMSInitiatingOccupancyFraction=70(这会告诉JVM只有当超过70%的老年代被使用后才触发CMS)
</code></pre>

<h2>显式触发CMS</h2>

<p>你可以配置JVM，只要代码调用System.gc()方法后就触发CMS：<code>-XX:+ExplicitGCInvokesConcurrent</code></p>

<h2>CMS和Full gc</h2>

<p>如果CMS不能释放足够的老年代内存，JVM会启用整理式的搜集算法(Compacting)。整理收集器会强迫进入STW暂停，因此它只会出现在紧急情况下。通常大家都不希望进行full gc和较长时间的STW暂停。当CMS不能足够快的释放老年代内存，或者CMS启动的太晚了，或者因为老年代的内存碎片（没有足够的连续空间存放对象）时才会发生full gc。又或者你没有配置足够的堆内存，那么在full gc之后就会抛出OutOfMemoryException。</p>

<h2>永久带gc</h2>

<p>CMS结束后会触发full gc的一个原因是因为永久带的垃圾问题。默认的，CMS不会对永久带进行搜集。如果你的应用程序使用了多个classloader，或者反射，你可能会需要开启对永久带的垃圾回收。JVM选项-XX:+CMSClassUnloadingEnabled会允许CMS对永久带进行垃圾搜集。需要注意的是，位于永久带的对象可能会具有老年代对象的引用，如果永久带并没有满，这些从永久带到老年代的引用会导致一些已经死掉(dead)的对象在CMS周期内不可达，除非开启了class unloading。</p>

<h2>有效使用多核</h2>

<p>CMS具有多个阶段，有些是可以并发执行的，另外的是需要STW暂停的，但是可以并行执行以压缩程序暂停时间。</p>

<pre><code>-XX:+CMSConcurrentMTEnabled:允许CMS在concurrent阶段使用多核。
-XX:ConcGCThreads=&lt;n&gt;:指定concurrent阶段使用的线程数量
-XX:ParallelGCThreads=&lt;n&gt;:指定在STW暂停中并行工作的线程数（默认是机器的物理核心数）
-XX:+UseParNewGC:让JVM在新生代使用并行收集器，配合老年代的CMS。
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM是如何实现锁[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2013/08/14/how-to-implement-lock-in-jvm/"/>
    <updated>2013-08-14T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/08/14/how-to-implement-lock-in-jvm</id>
    <content type="html"><![CDATA[<p><a href="http://slava-technical.blogspot.de/2011/04/how-does-jvm-handle-locks.html">原文链接</a></p>

<p>Hotspot JVM 1.6具有三种类型的锁，当你试图使用java.util.concurrent.locks.Lock的实现去获取一个锁，或者进入一个synchronized块时就会使用JVM提供的锁：</p>

<h2>biased锁(偏向锁)</h2>

<p>在有些时候，就算时在一个并发环境中，实际上对于某些对象来说时没有真正的竞争的，这个时候jvm就不会向操作系统申请互斥对象(mutex)来实现锁。Hotspot可以使用一些内部的数据结构来更加高效的模拟锁。比如，一段被synchronized包裹的同步代码在当前并没有并发的执行，JVM就会使用CAS来将当前拥有锁的线程ID赋给一个用来表示互斥对象的对象中，并且如果CAS成功的话还会将重入次数也存进去。这个就是偏向锁，JVM最轻量级的锁。重入次数这个变量会被锁的当前拥有线程更新，就像更新一个局部变量一样，不会使用CAS。如果CAS失败，说明该锁当前正被其他线程拥有，这个时候JVM会暂停该互斥对象的拥有线程，将线程上下文刷新的主存中，并检查重入次数。如果重入次数时0，那么JVM就会将该锁升级为thin，否则就升级为fat。Hotspot使用互斥对象中的同样的域(field)来存储锁的拥有者线程ID</p>

<h2>thin锁</h2>

<p>这个实际上是一个简单的自旋锁。如果自旋的时间很短的话，它可以班组节约线程切换的时间（不立刻阻塞并且发生切换，而是先自旋一段时间）。当一个线程试图获取一个已经被占用的锁，那么该线程会先自旋一段时间，直到这个锁被释放。自旋的次数由内部的jvm实现决定，通常会考虑以下因素：JVM对当前应用所搜集的一些统计信息；当前线程数；CPU使用情况和数量等等。当自旋失败后，JVM决定将该thin锁升级为fat锁</p>

<h2>fat锁</h2>

<p>JVM中最高级别的锁，底层会向操作系统申请系统级别的互斥对象，并且使用操作系统的调度器来对线程进行挂起和恢复。这种类型的锁的开销比前面提到的锁要大得多，因为每次锁的释放和获取都会使得JVM与底层操作系统进行互操作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hotspot JVM中的垃圾收集器[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2013/08/14/garbage-collection-in-hotspot/"/>
    <updated>2013-08-14T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/08/14/garbage-collection-in-hotspot</id>
    <content type="html"><![CDATA[<p><a href="http://blog.ragozin.info/2011/12/garbage-collection-in-hotspot-jvm.html">原文连接</a>，该文和我的<a href="http://shenzhang.github.io/blog/2013/07/23/gc-in-hotspot">这篇文章</a>非常非常类似，纯属巧合。另外也可以看看<a href="http://hllvm.group.iteye.com/group/topic/38223#post-248757">这篇文章</a>对不同垃圾算法的描述。</p>

<p>Hotspot拥有好几种GC模式，具体采用那种模式可以通过命令行选项来指定。默认的GC模式由JVM的版本，client/server模式，以及当前的硬件条件来决定。</p>

<h2>串行GC（Serial GC)</h2>

<p>JVM开关：-XX:+UseSerialGC</p>

<p>串行GC是一种分代垃圾搜集算法（实际上现在的Hotspot虚拟机中的所有垃圾手机算法都是分代手机算法）。在新生代采用了拷贝算法，老年代采用了标记-整理(mark-sweep-compact MSC)算法。老年代和新生代在垃圾手机的时候都会发生STW，并且就行它的名称一样，所有手机操作都是在单个线程里完成。在老年代的垃圾收集中，所有存活的对象会被移动到空间的开始处，这样就可以让JVM将不使用的内存区域交还给操作系统。</p>

<p>如果你使用<code>-XX:+PrintGCDeitals</code>开启了GC log，你就可以看到如下输出：</p>

<p>新生代：</p>

<pre><code>41.614 [GC 41.614: [DefNew: 130716K-&gt;7953K(138240K), 0.0525908 secs] 890546K-&gt;771614K(906240K), 0.0527947 secs] [Times: user=0.05 sys=0.00, real=0.05 secs]
</code></pre>

<p>Full GC（新生代 + 老年代 + 永久区）：</p>

<pre><code>41.908 [GC 41.908: [DefNew: 130833K-&gt;130833K(138240K), 0.0000257 secs]41.909: [Tenured: 763660K-&gt;648667K(768000K), 1.4323505 secs] 894494K-&gt;648667K(906240K), [Perm : 1850K-&gt;1850K(12288K)], 1.4326801 secs] [Times: user=1.42 sys=0.00, real=1.43 secs]
</code></pre>

<h2>并行清除</h2>

<p>JVM开关:<code>-XX:+UseParallelGC</code></p>

<p>垃圾搜集的某些阶段本身就可以具有并行化的特点。并行处理可以减少GC和STW暂停需要的时间，并且可以充分利用多核CPU。现代VM中采用并行GC来有效利用多核硬件已经显得非常有必要了。并行GC在新生代中采用了并行的算法，老年代仍然采用的是单线程的Mark-Sweep-Compact算法。因此，采用该模式将会减少新生代的GC暂停时间，但是对于full gc的时间还是比较长的。</p>

<p>gc log如下：
新生代：</p>

<pre><code>59.821: [GC [PSYoungGen: 147904K-&gt;4783K(148288K)] 907842K-&gt;769258K(916288K), 0.2382801 secs] [Times: user=0.31 sys=0.00, real=0.24 secs]
</code></pre>

<p>老年代：</p>

<pre><code>60.060: [Full GC [PSYoungGen: 4783K-&gt;0K(148288K)] [PSOldGen: 764475K-&gt;660316K(768000K)] 769258K-&gt;660316K(916288K) [PSPermGen: 1850K-&gt;1850K(12288K)], 1.2817061 secs] [Times: user=1.26 sys=0.00, real=1.28 secs]
</code></pre>

<h2>老年代并行GC算法</h2>

<p>JVM开关:<code>-XX:+UseParallelOldGC</code></p>

<p>该模式是在并行清除模式基础上做的增量改进。它在老年代添加了并行化的Mark-Sweep-Compact算法，新生代还是采用并行清除里的并行算法。老年代仍然会产生较长的STW暂停，但是对多核处理器的利用可以让这个时间减少一些。不像串行MSC算法，并行的版本不会在堆的末尾产生一片连续的空闲内存区域（存活的对象都被移动到了区域的开始处），因此JVM无法将未用的区域归还给操作系统。</p>

<p>gc log如下：</p>

<p>新生代：</p>

<pre><code>65.411: [GC [PSYoungGen: 147878K-&gt;5434K(144576K)] 908129K-&gt;770314K(912576K), 0.2734699 secs] [Times: user=0.41 sys=0.00, real=0.27 secs]
</code></pre>

<p>full gc:</p>

<pre><code>65.411: [GC [PSYoungGen: 147878K-&gt;5434K(144576K)] 908129K-&gt;770314K(912576K), 0.2734699 secs] [Times: user=0.41 sys=0.00, real=0.27 secs]
</code></pre>

<h2>自适应策略</h2>

<p>JVM开关：<code>-XX:+UseAdaptiveSizePolicy</code></p>

<p>这个是在并行清除模式下的一种特殊模式，它可以动态调整新生代的大小以适应当前应用程序的特点。实际上它不会带来显著的性能提升，因此不要随便使用该选项。</p>

<h2>并行标记清除算法(CMS)</h2>

<p>JVM开关：<code>-XX:+UseConcMarkSweepGC</code></p>

<p>前面介绍的gc收集器通常被称为最大吞吐量收集器。CMS收集器是一种低暂停率的收集器，它被设计来减少STW暂停，并且提高应用程序的响应性。对于新生代可以采用串行的拷贝算法或者并行算法（该并行算法和前面介绍的并行搜集中的新生代并行算法有点类似，但是它们实际上是两套不同的实现代码，并且它们可能会使用不同的配置选项，比如自适应策略在CMS中就不存在）。</p>

<p>老年代采用了并发的搜集方法。就像名字所言，CMS是一种标记-清除算法（没有整理[compact]过程）。CMS在每个搜集周期内只需要两个很短暂的暂停，但是不像标记-整理算法，CMS不会做内存整理操作（将内存对象重新布局）并且会导致产生内存碎片。虽然CMS算法采用了一些手段来尽量克服内存碎片，但是这还是一个潜在的问题。</p>

<p>如果这种并发的收集器不能很快速的为应用程序分配内存，JVM还是会退化到使用串行的STW mark-sweep-compact（标记整理算法）来对老年代进行碎片整理（使用串行化的MSC算法的停顿时间往往是CMS停顿时间的50-500倍）。</p>

<p>gc log如下：</p>

<p>新生代：</p>

<pre><code>613.154: [GC 13.154: [DefNew: 130821K-&gt;8230K(138240K), 0.0507238 secs] 507428K-&gt;388797K(906240K), 0.0509611 secs] [Times: user=0.06 sys=0.00, real=0.05 secs]
</code></pre>

<p>老年代：</p>

<pre><code>13.433: [GC [1 CMS-initial-mark: 384529K(768000K)] 395044K(906240K), 0.0045952 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]
13.438: [CMS-concurrent-mark-start]
...
14.345: [CMS-concurrent-mark: 0.412/0.907 secs] [Times: user=1.20 sys=0.00, real=0.91 secs]
14.345: [CMS-concurrent-preclean-start]
14.366: [CMS-concurrent-preclean: 0.020/0.021 secs] [Times: user=0.03 sys=0.00, real=0.02 secs]
14.366: [CMS-concurrent-abortable-preclean-start]
...
14.707: [CMS-concurrent-abortable-preclean: 0.064/0.340 secs] [Times: user=0.36 sys=0.02, real=0.34 secs]
14.707: [GC[YG occupancy: 77441 K (138240 K)]14.708: [Rescan (non-parallel) 14.708: [grey object rescan, 0.0058016 secs]14.714: [root rescan, 0.0424011 secs], 0.0485593 secs]14.756: [weak refs processing, 0.0000109 secs] [1 CMS-remark: 404346K(768000K)] 481787K(906240K), 0.0487607 secs] [Times: user=0.05 sys=0.00, real=0.05 secs]
14.756: [CMS-concurrent-sweep-start]
...
14.927: [CMS-concurrent-sweep: 0.116/0.171 secs] [Times: user=0.23 sys=0.02, real=0.17 secs]
14.927: [CMS-concurrent-reset-start]
14.953: [CMS-concurrent-reset: 0.026/0.026 secs] [Times: user=0.05 sys=0.00, real=0.03 secs]
</code></pre>

<h2>当CMS后分配失败并且退化到MSC算法时</h2>

<pre><code>557.079: [GC 557.079: [DefNew557.097: [CMS-concurrent-abortable-preclean: 0.010/0.109 secs] [Times: user=0.12 sys=0.00, real=0.11 secs]
 (promotion failed) : 130817K-&gt;130813K(138240K), 0.1401674 secs]557.219: [CMS (concurrent mode failure): 731771K-&gt;584338K(768000K), 2.4659665 secs] 858916K-&gt;584338K(906240K), [CMS Perm : 1841K-&gt;1835K(12288K)], 2.6065527 secs] [Times: user=2.48 sys=0.03, real=2.61 secs]
</code></pre>

<h2>CMS增量模式</h2>

<p>JVM开关：<code>-XX:+CMSIncrementalMode</code></p>

<p>CMS使用一个或多个后台线程并且与应用程序线程并发的执行gc操作。这些线程会和应用程序线程竞争CPU时间。增量模式下会对gc后台线程占用的cpu时间做限制，如果只有1个或2个cpu核心，那么这会进一步提高应用程序的响应性。当然，老年代的搜集可能会变得更长，并且发生full gc的风险会更高。</p>

<h2>G1收集算法</h2>

<p>JVM开关：<code>-XX:+UseG1GC</code></p>

<p>G1(garbage first)是Hotspot中新设计的垃圾搜集器。它在jdk1.6的较新版本中本引入。G1是一种低停顿的算法，并且采用了mark-sweep-compact的改进增量型算法。G1将堆划分为大小固定的多个区域，并且可以在STW暂停中对其中的部分区域进行垃圾搜集（与CMS不同，G1大部分的工作需要在STW中运行）。增量式可以用多个短暂停代替少量的长暂停（多个短暂停的总和还是会远远大于CMS）。更精确的说，G1会采用多个后台线程与应用程序并发的运行，来对堆中的内存进行标记(mark)（与CMS类似），但是还是有大量的工作是在STW中执行。</p>

<p>G1在对其中的部分区域进行搜集时还是会采用拷贝算法，这样在每次搜集完成后会产生一些空闲的区域，它们可以被JVM在适当的时候归还给操作系统。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hotspot的垃圾回收：串行、并行和CMS[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2013/08/13/serial-paiallel-cms-in-hotspot/"/>
    <updated>2013-08-13T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/08/13/serial-paiallel-cms-in-hotspot</id>
    <content type="html"><![CDATA[<p><a href="http://www.tikalk.com/java/garbage-collection-serial-vs-parallel-vs-concurrent-mark-sweep">原文链接</a></p>

<p>串行(Serial)，并行(Parallel)和CMS（Concurrent-Mark-Sweep)垃圾搜集算法到底有什么不同呢？</p>

<p>首先，让我们看看哪些算法是用于新生代，哪些算法是用于老年代：</p>

<h3>以下算法用于新生代：</h3>

<pre><code>-XX:+UseSerialGC 
-XX:+UseParallelGC 
-XX:+UseParNewGC
</code></pre>

<h3>以下算法用于老年代:</h3>

<pre><code>-XX:+UseParallelOldGC 
-XX:+UseConcMarkSweepGC
</code></pre>

<h3>串行和并行收集器有什么不同</h3>

<p>串行和并行垃圾收集器在GC的时候都会造成Stop-The-World，串行收集器默认是一个拷贝算法，并且使用单个线程来完成GC操作；并行收集器采用多个线程完成GC操作。</p>

<h3>并行收集器和CMS有什么不同</h3>

<p>CMS会通过以下步骤（所有步骤都使用一个线程完成）</p>

<ol>
<li>inital mark</li>
<li>concurrent marking</li>
<li>remark</li>
<li>concurrent sweeping</li>
</ol>


<p><em>主要有两点不同：</em></p>

<ol>
<li>并行收集器使用多个线程，CMS只使用单个线程</li>
<li>并行收集器会Stop-The-World，但是CMS仅仅在inital mark和remark阶段会STW,concrrent marking和concurrent sweeping阶段时，GC线程会和应用程序线程并发运行。</li>
</ol>


<h3>如果你想将GC定制化为并行化和并发化，那么可以使用下面的参数:</h3>

<pre><code>-XX:UserParNewGC：让新生代使用多个线程
-XX:+UseConcMarkSweepGC:在老年代使用CMS（一个线程，仅仅在inital mark和remark阶段才发生STW)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hotspot中的safepoints[译]]]></title>
    <link href="http://shenzhang.github.io/blog/2013/08/13/safepoints-in-hotspot/"/>
    <updated>2013-08-13T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/08/13/safepoints-in-hotspot</id>
    <content type="html"><![CDATA[<p><a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html">原文链接</a></p>

<p>术语Stop-The-World(STW)通常和垃圾搜集相关。虽然GC是STW暂停的最主要原因，但并不是唯一的原因。</p>

<h2>Safepoints</h2>

<p>在Hotspot虚拟机中Stop-The-World暂停机制被称作safepoint。在safepoint期间，所有运行java代码的线程都会被挂起。运行本地代码的线程都会继续执行，直到与JVM进行交互（比如调用java的方法或者从本地代码返回到java代码）。</p>

<p>在暂停所有的线程时，要求safepoint的发起者具有JVM数据的排他访问权限，这样就可以做很多疯狂的事情，比如在堆中移动数据或者替换正在运行的方法中的代码。</p>

<h2>Safepoint是怎么工作的？</h2>

<p>Hotspot JVM中的safepoint是一种协作性的协议。所有的应用程序线程会检查safepoint的状态，当需要进入safepoint的时候，线程会暂停自己并且保持在一个安全的状态下。</p>

<p>对于已经被编译的代码（JIT编译），JIT编译器会在某些代码点插入safepoint检查代码（一般是在调用返回的时候或者是循环退出的时候）。对于解释执行的代码，JVM有两个字节码分发表(byte code dispatch table)，当需要进入safepoint的时候，JVM会在这两个表之间切换以便做safepoint检查。</p>

<p>safepoint状态检查实现的非常巧妙，普通的内存变量检查需要内存屏障的支持。safepoint检查以读取内存屏障的方式实现。当需要safepoint的时候，JVM取消对应用程序线程中导致页错误的地址映射（由JVM直接处理）。这样，Hotspot可以让经过JIT编译的代码保持CPU流水线的友好性，同时也保证了正确的内存语义。</p>

<h2>什么时候会触发safepoints</h2>

<p>下面是Hotspot JVM中会触发safepoints的一些原因：</p>

<ol>
<li>垃圾回收</li>
<li>代码优化</li>
<li>刷新缓存</li>
<li>类重定义(比如hotswap或者instrumentation)</li>
<li>撤销偏向锁</li>
<li>多种调试操作(比如死锁检查，运行栈dump)</li>
</ol>


<h2>safepoints问题排查</h2>

<p>通常情况下safepoints会经常存在并一直工作者，因此你并不需要怎么关系它（大多数情况下，除了GC，都非常快速和短暂）。如果由于偶然的因素破坏了safepoint的正常工作，就会让事情变得很糟，因此下面是一些有用的诊断方法：</p>

<ol>
<li><p><code>-XX:+PrintGCApplicationStoppedTime</code>:该选项会报告所有safepoints的暂停时间（与GC相关的或者不相关的）。但是不幸的是，这个选项的输出缺少时间戳信息，但是它仍然可以帮助定位问题。</p></li>
<li><p><code>-XX:+PrintSafepointStatistics和-XX:PrintSafepointStatisticsCount=1</code>:这两个选项会强制JVM在safepoint后报告发生safepoint的原因及耗时（仅会输出到stdout，不会输出到GC日志(log)里）</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不同浏览器支持的最小时间精度]]></title>
    <link href="http://shenzhang.github.io/blog/2013/08/12/timeout-in-different-browser/"/>
    <updated>2013-08-12T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/08/12/timeout-in-different-browser</id>
    <content type="html"><![CDATA[<p>最近在实现一个灵活的div滚动条方案，主要用于解决windows下滚动条的美化问题，以及IE下对滚动条位置计算的不足。其中需要对div的内容大小进行持续监视，找了一个jquery的mutate插件，但是该插件的代码实在不敢恭维，于是对其进行了一些优化，减少了很多不必要的jquery对象创建过程。</p>

<p>该插件的原理非常简单，直接使用的setTimeout对检测属性进行监控，并且时间间隔是1ms，最初担心性能问题，但是发现实际上由于浏览器对时间的精度不会很高(不到1ms)，因此没有什么影响。但是还是对各浏览器的精度做了个简单测试,代码很简单：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">begin</span> <span class="o">=</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">begin</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">begin</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getTime</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">((</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getTime</span><span class="p">()</span> <span class="o">-</span> <span class="nx">begin</span><span class="p">)</span> <span class="o">/</span> <span class="nx">count</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">test</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">test</span><span class="p">();</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后的结果为：</p>

<pre><code>chrome: 4-5ms
firefox: 5-6ms
ie: 15ms
</code></pre>

<p>因此，最后将检测间隔设置成了50，既可以避免潜在的性能问题，也不会影响表现效果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识zookeeper]]></title>
    <link href="http://shenzhang.github.io/blog/2013/08/05/fist-view-of-zookeeper/"/>
    <updated>2013-08-05T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/08/05/fist-view-of-zookeeper</id>
    <content type="html"><![CDATA[<p>zookeeper是apache基金会下的一个高可用的分布式数据管理和协调框架，它最初也是hadoop下的一个子项目被用于hadoop生态系统中，但是随着被大家的不断挖掘，zookeeper有了更广泛的应用(应用场景可以参见<a href="http://rdc.taobao.com/team/jm/archives/1232">这里</a>).</p>

<h2>如何搭建单机版的zookeeper服务</h2>

<p>1.下载zookeeper</p>

<p>2.创建配置文件conf/zoo.cfg，并加入下面的配置信息：</p>

<pre><code>tickTime=2000
dataDir=/var/lib/zookeeper
clientPort=2181
</code></pre>

<p>完整的配置参数请参见<a href="http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_configuration">官方文档</a>.</p>

<p>3.启动zookeeper服务</p>

<pre><code>bin/zkServer.sh start
</code></pre>

<h2>测试</h2>

<p>可以直接使用bin/zkCli.sh这个脚本提供的java客户端来进行测试，该脚本的内容也非常简单:</p>

<ol>
<li>执行zkEnv.sh设置环境变量</li>
<li>执行org.apache.zookeeper.ZooKeeperMain</li>
</ol>


<p><code>bin/zkCli.sh -server host:port</code>来启动客户端，或者直接使用zkCli.sh来连接localhost:2181，连接上后可以使用help命令来查看所有客户端支持的命令：</p>

<pre><code>connect host:port
get path [watch]
ls path [watch]
set path data [version]
rmr path
delquota [-n|-b] path
quit
printwatches on|off
create [-s] [-e] path data acl
stat path [watch]
close
ls2 path [watch]
history
listquota path
setAcl path acl
getAcl path
sync path
redo cmdno
addauth scheme auth
delete path [version]
setquota -n|-b val path
</code></pre>

<p>例如：</p>

<ol>
<li>查看根路径: ls /</li>
<li>创建一个znode(节点): create /fish helloworld</li>
<li>查看一个节点: get /fish</li>
<li>重新设置一个节点的内容: set /fish hello</li>
</ol>


<h2>关闭zookeeper</h2>

<pre><code>bin/zkServer.sh stop
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JNDI环境初始化深入分析]]></title>
    <link href="http://shenzhang.github.io/blog/2013/07/27/inspect-jndi/"/>
    <updated>2013-07-27T05:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/07/27/inspect-jndi</id>
    <content type="html"><![CDATA[<h2>JNDI是什么</h2>

<p>jndi: Java Naming and Directory Interface</p>

<p>jndi是j2ee提供的用于对象查找和获取的接口规范，该规范需要j2ee容器去实现以提供jndi的功能，不同的容器或者说jndi实现者对jndi里的对象的注册方式和内部管理方式都不完全一样，但是获取方式都完全一样（jndi规定了怎么获取）,如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">InitalContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">InitialContext</span><span class="o">();</span>
</span><span class='line'><span class="n">Object</span> <span class="n">yourObject</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">lookup</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然jndi中还包含了LDAP等更高层次的接口规范，这里不进行描述。</p>

<h2>JNDI中可用的环境变量</h2>

<p>JNDI中预定义了一些环境变量，这些环境变量可以控制JNDI环境的行为（包括初始化过程），变量的定义在javax.naming.Context接口中，对应的javadoc有对各变量的说明，但是如果不看源码很难准确理解这些变量的意义。下面的片段截取了一些变量：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">String</span> <span class="n">INITIAL_CONTEXT_FACTORY</span> <span class="o">=</span> <span class="s">&quot;java.naming.factory.initial&quot;</span><span class="o">;</span>
</span><span class='line'><span class="n">String</span> <span class="n">OBJECT_FACTORIES</span> <span class="o">=</span> <span class="s">&quot;java.naming.factory.object&quot;</span><span class="o">;</span>
</span><span class='line'><span class="n">String</span> <span class="n">URL_PKG_PREFIXES</span> <span class="o">=</span> <span class="s">&quot;java.naming.factory.url.pkgs&quot;</span><span class="o">;</span>
</span><span class='line'><span class="n">String</span> <span class="n">APPLET</span> <span class="o">=</span> <span class="s">&quot;java.naming.applet&quot;</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>InitalContext</h2>

<p>javax.naming.InitalContext是客户端使用jndi的入口，也是jndi容器初始化的入口，因此jndi容器(环境)的初始化是lazy的，只有到需要的时候才会进行初始化。InitalContext的构造函数有两个：</p>

<p>1.不接受任何初始化环境变量</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="nf">InitialContext</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">NamingException</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">init</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.主动设置初始化环境变量(就是在上一节提到的环境变量)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="nf">InitialContext</span><span class="o">(</span><span class="n">Hashtable</span><span class="o">&lt;?,?&gt;</span> <span class="n">environment</span><span class="o">)</span><span class="kd">throws</span> <span class="n">NamingException</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">environment</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">environment</span> <span class="o">=</span> <span class="o">(</span><span class="n">Hashtable</span><span class="o">)</span><span class="n">environment</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">init</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来会调用init函数来初始化InitalContext.defaultInitCtx变量，该变量也是Context类型，并且由具体的容器来实现，它才是真正的实现者。待defaultInitCtx创建好之后，InitalContext的所有操作就会被分发给defaultInitCtx执行，InitalContext本质上讲就是defaultInitCtx的工厂和代理。</p>

<h2>初始化过程</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">(</span><span class="n">Hashtable</span><span class="o">&lt;?,?&gt;</span> <span class="n">environment</span><span class="o">)</span><span class="kd">throws</span> <span class="n">NamingException</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">myProps</span> <span class="o">=</span> <span class="n">ResourceManager</span><span class="o">.</span><span class="na">getInitialEnvironment</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">myProps</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">INITIAL_CONTEXT_FACTORY</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// user has specified initial context factory; try to get it</span>
</span><span class='line'>        <span class="n">getDefaultInitCtx</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="n">Hashtable</span> <span class="nf">getInitialEnvironment</span><span class="o">(</span><span class="n">Hashtable</span> <span class="n">env</span><span class="o">)</span>
</span><span class='line'>        <span class="kd">throws</span> <span class="n">NamingException</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">String</span><span class="o">[]</span> <span class="n">props</span> <span class="o">=</span> <span class="n">VersionHelper</span><span class="o">.</span><span class="na">PROPS</span><span class="o">;</span>   <span class="c1">// system/applet properties</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">env</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">env</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Hashtable</span><span class="o">(</span><span class="mi">11</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">Object</span> <span class="n">applet</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">APPLET</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Merge property values from env param, applet params, and system</span>
</span><span class='line'>    <span class="c1">// properties.  The first value wins:  there&#39;s no concatenation of</span>
</span><span class='line'>    <span class="c1">// colon-separated lists.</span>
</span><span class='line'>    <span class="c1">// Read system properties by first trying System.getProperties(),</span>
</span><span class='line'>    <span class="c1">// and then trying System.getProperty() if that fails.  The former</span>
</span><span class='line'>    <span class="c1">// is more efficient due to fewer permission checks.</span>
</span><span class='line'>    <span class="n">String</span><span class="o">[]</span> <span class="n">jndiSysProps</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="na">getJndiProperties</span><span class="o">();</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">props</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Object</span> <span class="n">val</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">props</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">val</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">applet</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">val</span> <span class="o">=</span> <span class="n">AppletParameter</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">applet</span><span class="o">,</span> <span class="n">props</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">val</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="c1">// Read system property.</span>
</span><span class='line'>                <span class="n">val</span> <span class="o">=</span> <span class="o">(</span><span class="n">jndiSysProps</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>                    <span class="o">?</span> <span class="n">jndiSysProps</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>
</span><span class='line'>                    <span class="o">:</span> <span class="n">helper</span><span class="o">.</span><span class="na">getJndiProperty</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">val</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">env</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">props</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">val</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Merge the above with the values read from all application</span>
</span><span class='line'>    <span class="c1">// resource files.  Colon-separated lists are concatenated.</span>
</span><span class='line'>    <span class="n">mergeTables</span><span class="o">(</span><span class="n">env</span><span class="o">,</span> <span class="n">getApplicationResources</span><span class="o">());</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">env</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数实际上就是从一些环境变量（参数）源搜集jndi需要的环境变量，然后再以map的形式返回。</p>

<ol>
<li>InitalContext(environment)构造函数传递的环境变量。</li>
<li>如果a中指定了javax.naming.applet对象，则转换为Applet对象，这个Applet对象也成了源(applet)</li>
<li>System.getProperties()提供的环境变量(systemProperties)</li>
<li>应用程序提供的环境变量(application)。</li>
</ol>


<p>这些环境变量的优先级如下：2和3只能够提供以下的环境变量，其他的变量将被忽略：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">final</span> <span class="kd">static</span> <span class="n">String</span><span class="o">[]</span> <span class="n">PROPS</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[]</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">javax</span><span class="o">.</span><span class="na">naming</span><span class="o">.</span><span class="na">Context</span><span class="o">.</span><span class="na">INITIAL_CONTEXT_FACTORY</span><span class="o">,</span>
</span><span class='line'>    <span class="n">javax</span><span class="o">.</span><span class="na">naming</span><span class="o">.</span><span class="na">Context</span><span class="o">.</span><span class="na">OBJECT_FACTORIES</span><span class="o">,</span>
</span><span class='line'>    <span class="n">javax</span><span class="o">.</span><span class="na">naming</span><span class="o">.</span><span class="na">Context</span><span class="o">.</span><span class="na">URL_PKG_PREFIXES</span><span class="o">,</span>
</span><span class='line'>    <span class="n">javax</span><span class="o">.</span><span class="na">naming</span><span class="o">.</span><span class="na">Context</span><span class="o">.</span><span class="na">STATE_FACTORIES</span><span class="o">,</span>
</span><span class='line'>    <span class="n">javax</span><span class="o">.</span><span class="na">naming</span><span class="o">.</span><span class="na">Context</span><span class="o">.</span><span class="na">PROVIDER_URL</span><span class="o">,</span>
</span><span class='line'>    <span class="n">javax</span><span class="o">.</span><span class="na">naming</span><span class="o">.</span><span class="na">Context</span><span class="o">.</span><span class="na">DNS_URL</span><span class="o">,</span>
</span><span class='line'>    <span class="c1">// The following shouldn&#39;t create a runtime dependence on ldap package.</span>
</span><span class='line'>    <span class="n">javax</span><span class="o">.</span><span class="na">naming</span><span class="o">.</span><span class="na">ldap</span><span class="o">.</span><span class="na">LdapContext</span><span class="o">.</span><span class="na">CONTROL_FACTORIES</span>
</span><span class='line'><span class="o">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>优先级是environment > applet > systemProperties</p>

<p>最后的env会和application（应用指定的）环境变量合并（如果env没有提供就采用application的，如果env有了，那么就会和application的合并，用逗号分割），如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">mergeTables</span><span class="o">(</span><span class="n">Hashtable</span> <span class="n">props1</span><span class="o">,</span> <span class="n">Hashtable</span> <span class="n">props2</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Enumeration</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">props2</span><span class="o">.</span><span class="na">keys</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">while</span> <span class="o">(</span><span class="n">keys</span><span class="o">.</span><span class="na">hasMoreElements</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">prop</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span><span class="n">keys</span><span class="o">.</span><span class="na">nextElement</span><span class="o">();</span>
</span><span class='line'>        <span class="n">Object</span> <span class="n">val1</span> <span class="o">=</span> <span class="n">props1</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">prop</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">val1</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">props1</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">prop</span><span class="o">,</span> <span class="n">props2</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">prop</span><span class="o">));</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">isListProperty</span><span class="o">(</span><span class="n">prop</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">String</span> <span class="n">val2</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span><span class="n">props2</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">prop</span><span class="o">);</span>
</span><span class='line'>            <span class="n">props1</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">prop</span><span class="o">,</span> <span class="o">((</span><span class="n">String</span><span class="o">)</span><span class="n">val1</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot;:&quot;</span> <span class="o">+</span> <span class="n">val2</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后来看下怎么获取application(应用级别)的环境变量:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="n">Hashtable</span> <span class="nf">getApplicationResources</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">NamingException</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">ClassLoader</span> <span class="n">cl</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="na">getContextClassLoader</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">propertiesCache</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Hashtable</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">Hashtable</span><span class="o">)</span><span class="n">propertiesCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">cl</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">NamingEnumeration</span> <span class="n">resources</span> <span class="o">=</span>
</span><span class='line'>                <span class="n">helper</span><span class="o">.</span><span class="na">getResources</span><span class="o">(</span><span class="n">cl</span><span class="o">,</span> <span class="n">APP_RESOURCE_FILE_NAME</span><span class="o">);</span>
</span><span class='line'>            <span class="k">while</span> <span class="o">(</span><span class="n">resources</span><span class="o">.</span><span class="na">hasMore</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Properties</span><span class="o">();</span>
</span><span class='line'>                <span class="n">props</span><span class="o">.</span><span class="na">load</span><span class="o">((</span><span class="n">InputStream</span><span class="o">)</span><span class="n">resources</span><span class="o">.</span><span class="na">next</span><span class="o">());</span>
</span><span class='line'>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">result</span> <span class="o">=</span> <span class="n">props</span><span class="o">;</span>
</span><span class='line'>                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">mergeTables</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">props</span><span class="o">);</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// Merge in properties from file in &lt;java.home&gt;/lib.</span>
</span><span class='line'>            <span class="n">InputStream</span> <span class="n">istream</span> <span class="o">=</span>
</span><span class='line'>                <span class="n">helper</span><span class="o">.</span><span class="na">getJavaHomeLibStream</span><span class="o">(</span><span class="n">JRELIB_PROPERTY_FILE_NAME</span><span class="o">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">istream</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Properties</span><span class="o">();</span>
</span><span class='line'>                <span class="n">props</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">istream</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">result</span> <span class="o">=</span> <span class="n">props</span><span class="o">;</span>
</span><span class='line'>                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">mergeTables</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">props</span><span class="o">);</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">NamingException</span> <span class="n">ne</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConfigurationException</span><span class="o">(</span>
</span><span class='line'>                    <span class="s">&quot;Error reading application resource file&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="n">ne</span><span class="o">.</span><span class="na">setRootCause</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>            <span class="k">throw</span> <span class="n">ne</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Hashtable</span><span class="o">(</span><span class="mi">11</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">propertiesCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">cl</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>实际上就是使用当前线程的ContextClassLoader去尝试加载两个peropery形式的配置文件：</p>

<ol>
<li>APP_RESOURCE_FILE = jndi.properties</li>
<li>&lt;java.home>/lib/jndi.properties</li>
</ol>


<p>这个步骤对于某些jndi容器来说是相当重要的，因为前面提到了环境变量指定方式都需要应用做额外的配置或者写特定的代码，这个步骤就可以让容器的实现者可以将自己的配置放在约定的配置文件里，供jndi使用。比如jetty8的jndi容器实现就是通过<code>classpath://jndi.properties</code>来做配置的:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">java</span><span class="o">.</span><span class="na">naming</span><span class="o">.</span><span class="na">factory</span><span class="o">.</span><span class="na">url</span><span class="o">.</span><span class="na">pkgs</span><span class="o">=</span><span class="n">org</span><span class="o">.</span><span class="na">eclipse</span><span class="o">.</span><span class="na">jetty</span><span class="o">.</span><span class="na">jndi</span>
</span><span class='line'><span class="n">java</span><span class="o">.</span><span class="na">naming</span><span class="o">.</span><span class="na">factory</span><span class="o">.</span><span class="na">initial</span><span class="o">=</span><span class="n">org</span><span class="o">.</span><span class="na">eclipse</span><span class="o">.</span><span class="na">jetty</span><span class="o">.</span><span class="na">jndi</span><span class="o">.</span><span class="na">InitialContextFactory</span>
</span></code></pre></td></tr></table></div></figure>


<p>之前有个朋友问他的jetty中的应用为什么InitalContext.lookup总是报错，配置不对。实际上就是没有将jetty-jndi-[version].jar依赖进来，这个里面就包含了jndi.properties的配置文件，除非使用jetty-all.jar的集合包，否则要想让jetty提供jndi的功能就一定需要该jar包。</p>

<p>好了通过上面的分析，最后搜集到了所有的环境变量的值，并保存在InitialContext.myProps中，继续初始化defaultInitCtx&hellip;</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">(</span><span class="n">Hashtable</span><span class="o">&lt;?,?&gt;</span> <span class="n">environment</span><span class="o">)</span><span class="kd">throws</span> <span class="n">NamingException</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">myProps</span> <span class="o">=</span> <span class="n">ResourceManager</span><span class="o">.</span><span class="na">getInitialEnvironment</span><span class="o">(</span><span class="n">environment</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">myProps</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">INITIAL_CONTEXT_FACTORY</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// user has specified initial context factory; try to get it</span>
</span><span class='line'>        <span class="n">getDefaultInitCtx</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果环境变量里指明了INITAL_CONTEXT_FACTORY(java.naming.factory.inital)就开始初始化默认的Context:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="n">Context</span> <span class="nf">getDefaultInitCtx</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">NamingException</span><span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(!</span><span class="n">gotDefault</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">defaultInitCtx</span> <span class="o">=</span> <span class="n">NamingManager</span><span class="o">.</span><span class="na">getInitialContext</span><span class="o">(</span><span class="n">myProps</span><span class="o">);</span>
</span><span class='line'>        <span class="n">gotDefault</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">defaultInitCtx</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoInitialContextException</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">defaultInitCtx</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="n">Context</span> <span class="nf">getInitialContext</span><span class="o">(</span><span class="n">Hashtable</span><span class="o">&lt;?,?&gt;</span> <span class="n">env</span><span class="o">)</span>
</span><span class='line'>    <span class="kd">throws</span> <span class="n">NamingException</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">InitialContextFactory</span> <span class="n">factory</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">InitialContextFactoryBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="n">getInitialContextFactoryBuilder</span><span class="o">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">builder</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// No factory installed, use property</span>
</span><span class='line'>        <span class="c1">// Get initial context factory class name</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">String</span> <span class="n">className</span> <span class="o">=</span> <span class="n">env</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span>
</span><span class='line'>            <span class="o">(</span><span class="n">String</span><span class="o">)</span><span class="n">env</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Context</span><span class="o">.</span><span class="na">INITIAL_CONTEXT_FACTORY</span><span class="o">)</span> <span class="o">:</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">className</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">NoInitialContextException</span> <span class="n">ne</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NoInitialContextException</span><span class="o">(</span>
</span><span class='line'>                <span class="s">&quot;Need to specify class name in environment or system &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;property, or as an applet parameter, or in an &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;application resource file:  &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="n">Context</span><span class="o">.</span><span class="na">INITIAL_CONTEXT_FACTORY</span><span class="o">);</span>
</span><span class='line'>            <span class="k">throw</span> <span class="n">ne</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">factory</span> <span class="o">=</span> <span class="o">(</span><span class="n">InitialContextFactory</span><span class="o">)</span>
</span><span class='line'>                <span class="n">helper</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span><span class="n">className</span><span class="o">).</span><span class="na">newInstance</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">NoInitialContextException</span> <span class="n">ne</span> <span class="o">=</span>
</span><span class='line'>                <span class="k">new</span> <span class="nf">NoInitialContextException</span><span class="o">(</span>
</span><span class='line'>                    <span class="s">&quot;Cannot instantiate class: &quot;</span> <span class="o">+</span> <span class="n">className</span><span class="o">);</span>
</span><span class='line'>            <span class="n">ne</span><span class="o">.</span><span class="na">setRootCause</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>            <span class="k">throw</span> <span class="n">ne</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">factory</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">createInitialContextFactory</span><span class="o">(</span><span class="n">env</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">factory</span><span class="o">.</span><span class="na">getInitialContext</span><span class="o">(</span><span class="n">env</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出创建Context的过程实际上是一个工厂模式，要先找到这个工厂(InitalContextFactory)</p>

<ol>
<li>首先检查NamingManager中是否配置的有IntialContextFactoryBuilder（Context工厂的工厂），如果有的话就用指定的factoryBuilder创建一个ContextFactory</li>
<li>否则就用环境变量里java.naming.factory.inital指定的工厂。</li>
<li>得到工厂后，就用这个工厂去创建这个defaultContext(InitalContext就是这个真正的Context的代理）。</li>
</ol>


<p>至于这个defaultContext是怎么实现的就依赖具体的容器了，只要符合jndi的规范就可以了，但是实际上规范中对这块的要求也是很少的，只是对一些概念和接口做了确定。</p>

<p>回头看来其实jndi的初始化是很简单的，就是简单的指定一些环境变量，特别是<code>INITAL_CONTEXT_FACTORY(java.naming.factory.inital)</code>参数，特工一个真正Context的工厂就行了，连创建的过程都交给具体容器去实现了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jetty常用handler之GzipHandler]]></title>
    <link href="http://shenzhang.github.io/blog/2013/07/27/gziphandler-in-jetty/"/>
    <updated>2013-07-27T04:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/07/27/gziphandler-in-jetty</id>
    <content type="html"><![CDATA[<p><code>org.eclipse.jetty.server.handler.GzipHandler</code>提供了将response压缩成gzip格式的功能，该handler需要放在真正数据处理的handler(ServletHandler,ResourceHandler等)前面。</p>

<p>它的实现原理也非常简单，实际上是将HttpServletResponse进行了一个包装，在后续的handler需要OutputStream或Writer的时候返回一个被Gzip流包装过的OutputStream，以便在输出流的时候对数据流进行压缩。除此之外，它还对request请求头做了检查，如果client不支持gzip格式，那么就不会做包装，直接交给后续handler。</p>

<p>由于该handler通用性很强，因此也导致了它的效率不高，每次请求都需要做gzip压缩处理，没有任何缓存功能，服务端的开销会增大。如果使用了WebAppContext，那么该功能完全可以被DefaultServlet取代，DefaultServlet也会对client的gzip支持特性做检查，如果请求的是静态文件，DefaultServlet会优先检查是否存在.gz后缀的同名文件，有的话就直接用.gz文件进行返回，但是缺点是不支持动态响应的压缩功能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jetty常用handler之DebugHandler]]></title>
    <link href="http://shenzhang.github.io/blog/2013/07/27/debughandler-in-jetty/"/>
    <updated>2013-07-27T03:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/07/27/debughandler-in-jetty</id>
    <content type="html"><![CDATA[<p><code>org.eclipse.jetty.server.handler.DebugHandler</code>是一个内部逻辑非常简单的handler，主要用于输出调试信息，虽然doc中表示该handler可以用于生产环境，但是我觉得功能还是太简单，并且输出内容也不是很实用。</p>

<p>该handler主要被放置在handler链的头部，它会在请求开始处理的时候向指定的OutputStream输出当前时间以及请求路径等信息，并且在该request处理完成后输出当前时间，主要用于分析不同资源的请求处理时长。可以调用<code>DebugHandler.setOutputStream</code>来指定输出目的地。</p>

<p>显然这种将所有请求都进行输出的方式不但影响性能，同时对于大量的日志还需要专门的程序进行分析。更好的方式是直接设定输出阈值，处理时间超过了该阈值就进行输出，当然如果对于日志还有其他的分析目的就另当别论了，有点类似RequestLogHandler。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jetty常用handler之DefaultHandler]]></title>
    <link href="http://shenzhang.github.io/blog/2013/07/27/defaulthandler-in-jetty/"/>
    <updated>2013-07-27T01:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/07/27/defaulthandler-in-jetty</id>
    <content type="html"><![CDATA[<p><code>org.eclipse.jetty.server.handler.DefaultHandler</code>，从名字就可以看出是jetty里的默认handler，之所以是默认不是Jetty预设的handler，而是说一般将该handler作为handler链的最后一个handler来处理请求。如果前面的handler都没能顺利处理请求(request.setHandled(true))，那么就让该handler来处理。</p>

<p>DefaultHandler提供了以下功能：</p>

<ol>
<li>如果请求的是/favicon.ico，那么就将jetty自己的icon图标返回给客户端。</li>
<li>如果请求的是/，那么就将当前jetty里所有的context根路径配合简单的html标签返回给客户端，比如说jetty提供了/app1和/app2两个引用，但是用户并不知道该server提供的应用的context，那么就可以直接输入/路径，DefaultHandler如果处理该请求就会用友好的方法告诉用户“当前的jetty提供了/app1和/app2两个引用”</li>
<li>其他情况一律返回404代码及对应的出错页面。</li>
</ol>


<p>其实自己看下上述三种功能，在实际应用中都不实用，最多开发阶段供调试使用。不过里面的代码还是值得一看的，既简单又反映了标准的handler编写模式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jetty中的ScopedHandler]]></title>
    <link href="http://shenzhang.github.io/blog/2013/07/26/scopehandler-in-jetty/"/>
    <updated>2013-07-26T03:27:00+08:00</updated>
    <id>http://shenzhang.github.io/blog/2013/07/26/scopehandler-in-jetty</id>
    <content type="html"><![CDATA[<p>jetty中的<code>org.eclipse.jetty.server.handler.ScopedHandler</code>主要用于ServletContextHandler以及WebAppContext，粗略看了下有点糊里糊涂的，后面仔细看了之后觉得实际上他就是想实现一个具有以下执行流程的HandlerWrapper:</p>

<pre><code> A.handle(...)
   A.doScope(...)
     B.doScope(...)
       C.doScope(...)
         A.doHandle(...)
           B.doHandle(...)
              C.doHandle(...)  
</code></pre>

<p>其中A包含B，B包含C。该执行流程主要应用在WebAppContext中。WebAppContext包含了SessionHandler,SecurityHandler, ServletHandler，但是从request的流程来看实际上是WebAppContext->SessionHandler->SecurityHandler->ServletHandler，所有后续执行逻辑都是被包含在前面的handler逻辑中的，或者所起堆栈是嵌套的。这样最大的好处是环境（context）共享和异常处理。内部的逻辑必须是在外部逻辑创造的环境内执行，比如所ServletHandler必须是在SessionHandler初始化好的session环境中处理。</p>

<p>因此ScopedHandler需要两个过程：</p>

<p><em>doScope:</em> 进入环境，并做响应的环境初始化,并在其中调用子handler的doScope，最后再做退出环境的逻辑。</p>

<p><em>doHandler:</em> 执行该handler真正要处理的事情，并在其中调用子handler的doScope</p>

<p>拿SessionHandler举例，它的doScope就是将session恢复好，并且再调用子handler的doScope进一步对SecurityHandler做环境初始化；它的doHandler实际上就没有做任何事情，仅仅是调用子handler的doHandler：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">never</span><span class="o">())</span>
</span><span class='line'>        <span class="n">nextHandle</span><span class="o">(</span><span class="n">target</span><span class="o">,</span><span class="n">baseRequest</span><span class="o">,</span><span class="n">request</span><span class="o">,</span><span class="n">response</span><span class="o">);</span>
</span><span class='line'>    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">_nextScope</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">_nextScope</span> <span class="o">==</span> <span class="n">_handler</span><span class="o">)</span>
</span><span class='line'>        <span class="n">_nextScope</span><span class="o">.</span><span class="na">doHandle</span><span class="o">(</span><span class="n">target</span><span class="o">,</span><span class="n">baseRequest</span><span class="o">,</span><span class="n">request</span><span class="o">,</span><span class="n">response</span><span class="o">);</span>
</span><span class='line'>    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">_handler</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>        <span class="n">_handler</span><span class="o">.</span><span class="na">handle</span><span class="o">(</span><span class="n">target</span><span class="o">,</span><span class="n">baseRequest</span><span class="o">,</span><span class="n">request</span><span class="o">,</span><span class="n">response</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>doScope的递归调用还算比较简单，但是如何从最底层的handler.doScope回到最上层的handler.doHandler呢，而且是嵌套的调用？</p>

<p>ScopedHandler实际上维护了两个变量：</p>

<p><em>_nextScope:</em> 指向下一个子handler</p>

<p><em>_outterScope</em> 指向最外层的handler</p>

<p>初始化：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doStart</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="k">try</span>
</span><span class='line'>        <span class="o">{</span>
</span><span class='line'>            <span class="n">_outerScope</span><span class="o">=</span><span class="n">__outerScope</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">_outerScope</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span>
</span><span class='line'>                <span class="n">__outerScope</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="kd">super</span><span class="o">.</span><span class="na">doStart</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">_nextScope</span><span class="o">=</span> <span class="o">(</span><span class="n">ScopedHandler</span><span class="o">)</span><span class="n">getChildHandlerByClass</span><span class="o">(</span><span class="n">ScopedHandler</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">finally</span>
</span><span class='line'>        <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">_outerScope</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span>
</span><span class='line'>                <span class="n">__outerScope</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的_outerScope的初始化我觉得实在是不优雅，显然整个jetty中那个最先初始化的ScopedHandler将会作为所有ScopedHandler的outerScope，显然不能再jetty中提供多个顶层ScopedHandler，这个需求可能是针对WebAppContext专门设计的，但是有点不符合Jetty这种灵活的可插拔式的定义。哪怕通过set方法主动设值都要好的多。</p>
]]></content>
  </entry>
  
</feed>
